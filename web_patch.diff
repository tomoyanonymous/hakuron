diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..e43b0f9
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+.DS_Store
diff --git a/_index.md b/_index.md
new file mode 100644
index 0000000..90e9c29
--- /dev/null
+++ b/_index.md
@@ -0,0 +1,55 @@
+---
+title: 音楽土木工学を設計する——音楽プログラミング言語mimiumの開発を通じて（Web版）
+layout: single
+ogpimage: ogp.jpg
+enableInlineShortcodes: true
+---
+# 音楽土木工学を設計する——音楽プログラミング言語mimiumの開発を通じて（Web版）
+
+九州大学大学院芸術工学府 博士論文
+
+松浦知也
+
+主査：城一裕　副査：久保田晃弘、中村美亜
+
+原版：2022年3月　（[**PDF - 九州大学図書館リポジトリ**](http://hdl.handle.net/2324/4784631)）
+
+Web版公開日： 2022年7月23日
+
+Web版最終更新日： 2022年7月23日
+
+## Web版を読むにあたっての諸注意
+
+- 内容に関わる違いはありませんが、正式に学位論文として提出したものとは別もの扱いと考えてください。特に以下の点に留意してください。
+  - Web版にはページ数との対応関係が無いため、引用などをするときはあくまでPDF版を確認した上でお願いします。
+  - 学位審査に提出後見つかった誤字を一部修正しています。
+- 組版の都合上、参考文献リストはPDFと違い各章ごとに掲載されています。また節や図、参考文献などの相互リンクは一部を除いて動きません。
+- 原著でPDFとして読み込んでいたベクター画像はすべてPNGに変換されています。
+
+## 本文
+
+#### **[用語集](./glossary_rendered)**
+
+### [概要](./abstract_rendered)  /  [Abstract](./abstract_en_rendered)
+
+### [第1章 - 序論](./chapter1_rendered)
+
+### [第2章 - 歴史を記述しなおすデザインリサーチ](./chapter2_rendered)
+
+### [第3章 - メタメディアとしてのコンピューター](./chapter3_rendered)
+
+### [第4章 - PLfM史の再考](./chapter4_rendered)
+
+### [第5章 - PLfMに関する諸用語と概念の整理](./chapter5_rendered)
+
+### [第6章 - 最小限のPLfM：mimiumの設計と実装](./chapter6_rendered)
+
+### [第7章 - 結論：音楽土木工学とは何なのか、どこへ向かうのか](./chapter7_rendered)
+
+**[付録(mimiumのシンタックス定義)](./appendix_rendered)**
+
+
+---
+
+**[謝辞](./acknowledgement_rendered)**
+
diff --git a/abstract.md b/abstract.md
index 2e79552..d892f53 100644
--- a/abstract.md
+++ b/abstract.md
@@ -1,3 +1,8 @@
+---
+title: 概要
+draft: true
+---
+
 本論文では、音楽のためのプログラミング言語（Programming Language for Music: PLfM）mimiumの開発の経験を通して、音楽土木工学という、音楽に関わる既存の工学的実践とは異なる学術研究領域を提示する。
 
 第1章では音楽土木工学の概念と論文全体の構造を示す。音楽土木工学とは、プログラミング言語やOS、計算機アーキテクチャのように、音楽のためだけに作られたわけではないが、音楽の技術環境に大きく影響を与えるものを音楽の視点から再考する研究アプローチである。今日、理論的にはあらゆることが可能な電子計算機を介さずに、音楽を作ったり聴くことはもはや難しい。しかしそうした環境にもかかわらず、表現者自らプログラムを書き道具を作るという、パーソナルコンピューティングの当初の思想、メタメディア（Kay and Goldberg 1977）としての電子計算機の利用は主流から程遠く、音楽の技術環境は常に技術インフラストラクチャに依存している。本研究は、そうした環境の変化を促す行動である音楽土木工学という学問をPLfMの設計と開発という実践と思索の中から描きだす。
diff --git a/abstract_en.md b/abstract_en.md
index 773c955..688227f 100644
--- a/abstract_en.md
+++ b/abstract_en.md
@@ -1,3 +1,8 @@
+---
+title: 概要
+draft: true
+---
+
 This dissertation aims to present Civil Engineering of Music（CEoM） as an alternative research field for technology and music through the practice in the development of mimium, a programming language for music(PLfM).
 
 In chapter 1, an overall structure of the dissertation and the concept of  CEoM are presented. CEoM is an approach for research that rethinks fundamental technologies which are not built for music but that have a significant impact on the technological environment of music, such as programming languages, operating systems, and computer architectures. Today, it is difficult to make or listen to music without any intervention of the electronic computer that can, theoretically, do anything. Nevertheless, the computer as a Meta-Medium(Kay and Golderg 1977), the original idea of personal computing that the users make programs for their own tools, is still not a straightforward way and the technological environment of music always depends on technical infrastructures. This dissertation draws a view of CEoM, an action to push a change of such environments through the circulation between a speculation and a practice in the design and development of PLfM.
diff --git a/acknowledgement.md b/acknowledgement.md
index 5d63131..f01a4d7 100644
--- a/acknowledgement.md
+++ b/acknowledgement.md
@@ -1,3 +1,9 @@
+---
+title: 謝辞
+draft: true
+---
+
+
 本論文を書き上げるまでの過程で、多くの人に支えていただきました。
 
 まずは、修士から続けて指導教員を務めてくださった城一裕先生に心からの感謝を申し上げます。副査を務めていただいた久保田晃弘先生、中村美亜先生にも論文執筆にあたって多くのアドバイスや批評的な視点をいただきました。
diff --git a/appendixA.md b/appendixA.md
index c1a5aaf..75f6a75 100644
--- a/appendixA.md
+++ b/appendixA.md
@@ -1,10 +1,15 @@
+---
+title: 付録
+draft: true
+---
+
 <!-- # mimiumのEBNFによるシンタックス定義 -->
 
 [@lst:bnfdef]に、mimium言語（バージョン0.4.0時点）のシンタックス定義をEBNF記法で示した。
 ここでは演算子の優先順位をつけていないが、実際の優先順位は一般的なプログラミング言語の優先順位に準じた上で、`@`演算子が一番低い優先順位となっている。
 
 
-\begin{lstlisting}[float,floatplacement=h,caption=mimiumのシンタックスのEBNFによる定義。,label=lst:bnfdef]
+```rust
   number ::= ?numbers?
   symbol ::= ?all_alnum_and_underscore?
   string ::= ?double_quote?<symbol>?double_quote?
@@ -41,4 +46,5 @@
   typealias ::= "type" <symbol> "=" <type>
 
   program ::= <statements>
-\end{lstlisting}
+```
+: mimiumのシンタックスのEBNFによる定義。 {#lst:bnfdef}
\ No newline at end of file
diff --git a/chapter1.md b/chapter1.md
index 7a458fa..ef14168 100644
--- a/chapter1.md
+++ b/chapter1.md
@@ -1,3 +1,7 @@
+---
+title: 第1章 - 序論
+draft: true
+---
 # 序文の前に
 
 2021年9月。北九州市の植物園でこのイントロダクションを書いている。
@@ -145,7 +149,7 @@ SFPCのプログラムはこうした歴史的背景をもとに、ブラック
 
 [^civil]: Civil Engineerという語は一般的に、1750年ごろにイギリスの工学者ジョン・スミートンが自らの専門を、相容れない軍事的な研究と区別するために名乗り始めたことが起源とされている[@Florman1988]。
 
-コンピューター自体が軍事的用途のために作られ、戦後も軍事技術の国家予算のもと多くの研究がなされてきたことはもはや言うまでもない。しかし、音楽に関わるコンピューティング技術に関してもそれは例外ではない。Maxを開発したミラー・パケットは、Maxにおけるもっとも基礎的な値を持たないデータである`bang`や、それを処理する`trigger`といった語の由来は文字通り軍事技術に由来するものだろうと述べている[@Puckette2020]。実際、1980年代にはパケットが務めていた電子音楽研究所IRCAMでコンピューター音楽のために作られた高性能なワークステーション4Xは、商業化を試みた結果として軍事的なシミュレーションにだけ利用されると言う結果を生んでいる（[@sec:ircamcontradiction]参照）。こうした歴史は、工学の中でも芸術や人文学に関わる分野でさえも、政治的、倫理的立ち位置に中立な研究などあり得ないことを端的に示している。
+コンピューター自体が軍事的用途のために作られ、戦後も軍事技術の国家予算のもと多くの研究がなされてきたことはもはや言うまでもない。しかし、音楽に関わるコンピューティング技術に関してもそれは例外ではない。Maxを開発したミラー・パケットは、Maxにおけるもっとも基礎的な値を持たないデータである`bang`や、それを処理する`trigger`といった語の由来は文字通り軍事技術に由来するものだろうと述べている[@Puckette2020]。実際、1980年代にはパケットが務めていた電子音楽研究所IRCAMでコンピューター音楽のために作られた高性能なワークステーション4Xは、商業化を試みた結果として軍事的なシミュレーションにだけ利用されると言う結果を生んでいる（[第4章](../chapter4_rendered)参照）。こうした歴史は、工学の中でも芸術や人文学に関わる分野でさえも、政治的、倫理的立ち位置に中立な研究などあり得ないことを端的に示している。
 
 つまり、音楽土木工学とは音楽とテクノロジーという都市における土と木に相当する要素を考える学問であると同時に、音楽のための市民工学という意味合いを持つ。この両面のアナロジーは、筆者が学んだSchool for Poetic Computationを立ち上げた人物の1人、アーティスト/アクティビストのチェ・テユン（Taeyoon Choi）の『Open Circuit, Open City』という文章からインスパイアされたものだ[@Taeyoon2016]。
 
@@ -157,7 +161,7 @@ SFPCのプログラムはこうした歴史的背景をもとに、ブラック
 
 > 都市は、コンピュータと似て、美学的熟考のための中立的対象ではない。そうではなく、競合し合う政治性と、危うくて不安定〔precarious〕な生活とが置かれた場なのだ。[@Taeyoon2016,筆者訳]
 
-![チェ・テユンによるHandmade Computerプロジェクトのひとつ、4 BIT FSM（Finite State Machine）[@Taeyoon2015]。](img/taeyoon_handmade.jpg){#fig:taeyoon width=70%}
+![チェ・テユンによるHandmade Computerプロジェクトのひとつ、4 BIT FSM（Finite State Machine）[@Taeyoon2015]。](../img/taeyoon_handmade.jpg){#fig:taeyoon width=70%}
 
 チェが行っているのはむしろ、自らが作ったり（DIY）誰かと一緒に作ったりする（DIWO：Do it with Others）過程で、そもそもテクノロジーとは誰が誰のために形作るものなのか、という問いを投げかける行為だ。
 
@@ -208,7 +212,7 @@ PLfMが一般的に多くのアーティストにとって、使うだけなら
 
 # 構成
 
-![本論文全体の構成。](img/thesis_structure.pdf){#fig:structure width=100%}
+![本論文全体の構成。](../img/thesis_structure.png){#fig:structure width=100%}
 
 
 第2章以降は以下のような構成で論じる。本論文全体の構造を[@fig:structure]に示した。全体としては、2〜4章で1960年代から2020年までの歴史をデザインリサーチ、メディアとしてのコンピューター、音楽のためのプログラミング言語というそれぞれの視点から振り返る。これらの歴史は例えばデザインリサーチとデザインであれば1970年代以降のコンピューターを用いた機器のインタラクションデザインという点で重なりはするものの、概ね独立して読めるような構成になっている。第5章は通時的な視点でのPLfMの整理、第6章は実際の言語設計と実装についての解説、第7章はその実装の問題点を起点にした省察である。なお、第2章から4章にかけての歴史的文脈の整理は、必ずしもmimiumという言語制作の背景として事前に定まっていたわけではないことに注意する必要がある。第2章で詳しく説明するように、本研究の特徴的な点は実践を通じたこれまでとは異なる視点での歴史記述にあるからだ。本研究全体は歴史の批判的考察と、mimiumの設計と実装を相互に繰り返しながら互いにその結果をフィードバックし合うことで成立している。その意味で、第2章から第5章は研究背景であると同時にリサーチのアウトプットでもある。
diff --git a/chapter1_5.md b/chapter1_5.md
deleted file mode 100644
index f9c5539..0000000
--- a/chapter1_5.md
+++ /dev/null
@@ -1,131 +0,0 @@
-
-Epistemic Tool
-
-Epistemic Thing
-
-# Andrew Sorensen
-
-Cyber-physical Programming
-
-特に
-
-、またそれを引き継いだ、PinchとBilkerに代表される技術の社会構築理論(Social C onstraction of Technology:SCOT)
-
-
-デザインと並んで芸術実践、ラボラトリーにおける研究においても
-
-ありうる(Possible-Plausible)未来の可能性の中からもっとも現状のままでは起こりやすそうな(Probable)未来を、望ましい(Prefereble)未来の方向へと少しでも変えていくという未来へ目線を向けたもの、あるいは、過去の
-対象の拡大：
-
-方法論の拡大：
-
-
-水野はこれを[#fig:pyramid]のように表している。こうした傾向は、ユーザー個人の行動や経験に対するデザインだけでは複雑な利害関係が絡み合う意地悪な問題に対処できないことへの対応として見て取れる。
-
-こうした大きな社会問題を射程に入れたデザインのアプローチとしては、DunneとRabyによるスペキュラティブデザインに代表される、並行世界の未来に存在しうる人工物を作り出し、その鑑賞者に議論を促すような方法論が長く培われてきた。
-
-また1つの解決策によって即効的に1つの問題が解決できず、解決できるとしても時間がかかることを認めた上で取れるアプローチ
-
-音楽にまつわるテクノロジーという領域においてもこうした傾向を反映することは必要になってくるはずだ。特に、プログラミング言語は序章で述べたように、完成という概念がもともと希薄であり、時間をかけて少しづつ変化していく人工物であるという視点は、カーネギーメロン大学が提示したTransition Designという潮流などにも呼応する。
-
-
-
----
-
-本論文は、音楽のためのプログラミング言語mimiumの設計と実装を通じて、音楽のためのプログラミング言語(Programming Language for Music:**PLfM**)を作るという行為の概念化を試み、その上であるべきコンピューターと音楽の関係性を考え直すものである。
-
-本論文で議論する「音楽のためのプログラミング言語」は、テキストや人間が知覚、操作可能な記号体系を用いて[^defplfm]コンピューターで音楽を生成するための人工言語である。
-
-[^defplfm]: 人間が知覚、操作可能な記号体系という遠回しな表現を用いるのは、（とくに音楽を扱う）プログラミング言語の中には、Maxのようにテキストではなく、入出力のあるボックス同士をマウスやタッチパッドなどでつないでいくことでプログラムを構成するものがあるからである。
-
-プログラミングを用いた音楽表現は、リアルタイムにセンサーの入力を読み取り、信号処理をしてアコースティック楽器では不可能な音を生成する、「ハイパー楽器」的にコンピューターを扱うものであったり、近年ではソースコード[^source]を書くプロセスそのものを演奏として見せるライブコーディングのような表現なども登場しており、その領域はますます広がりを見せている
-
-[^source]:プログラミング言語で記述された、プログラムを生成するためのテキストやそのファイルデータのこと。Maxのような、テキストを用いず配線を繋いでいくようなビジュアル言語ではパッチと呼ぶこともあるが、本研究でソースコードと言ったときには音を生成するためのプログラムを記述したもの全般を指している。単にコードと略すこともある。
-
-プログラミングに限らず音楽とコンピューターの関係性へと視野を広げてみれば、2021年現在、音楽を聴いたり、演奏したり、作ったりする上で、コンピュータが一切関与しない、という状況を考えるのは難しくなっている。作曲にはProtoolsやCubaseに代表されるDAW（Digital Audio Workstation）ソフトウェアを使用し、配信にはApple MusicやSpotifyのようなストリーミングサービスを通じて、デジタルデータという形で音楽は配布される。最終的に、コンピューターやスマートフォン上のソフトウェアでそのデータをデコードし、DAC(Digital-Analog Converter)によって電気信号へと変換され、その信号はスピーカーへと送られようやく空気の振動になり、私たちの耳へ届く。スピーカーの中にさえデジタル信号処理(DSP:Digital Signal Processing)用のチップが入っていて計算によって音質の調整をしていることも珍しくはない。2020年以後のコロナウィルスの影響も含めれば、クラシック音楽のコンサートさえもその場で空気の振動を体感することよりも録画録音されたものをコンピューターを通じて摂取することの方が多くなってしまったかもしれない。とかく音楽文化を見れば、マーク・ワイザーの提唱したユビキタス（Ubiquitous:遍在する）・コンピューティング[@Wiser1999]の概念は字義通りには達成されたようにも見える。
-
-それにもにもかかわらず、音楽文化全体を見てみれば、音楽制作自体にコンピューターの可変性を十分に活かせるはずのプログラミングという手段を用いること自体はメインストリームとは程遠いと言える。たとえば、今日のDAWソフトウェアの中で、プログラムを用いてソフトウェアそれ自体を拡張する方法は、Ableton社のLiveにおける、音楽プログラミング環境Maxを内部拡張として用いることができるMax for Live、独自のスクリプト言語を使用できるReaperなどを除けば、VSTプラグインなど一部の仕組みに限られる。こうした拡張も、多くはC++のような、音楽を専門とする人には難易度の高いプログラミング言語で記述する必要があり、作家が自ら道具の機能を拡張するには未だハードルが高い。
-
-音楽にプログラミングを用いることですらこの現状であるので、音楽のためのプログラミング言語や環境自体を作ることの事例はますます限られている。今日ソースコード共有サービスGitHubにおいて、「Programming Language」と検索すれば87502のリポジトリが出てくるのに対して、「Programming Language Music」では137しか出てこないことからその探究の規模の小ささががわかるだろう。実際、第3章で見ていくことになる2000年代以後に開発された音楽プログラミング言語は多く数えて30ちょっとに限られ、年を追うごとに開発者の数が増えているとも言い難い。
-
-そして、受容の形式という視点で音楽とテクノロジーとの関わりを見てみると、どれだけ高度なテクノロジーを用いて生成された音声も、最終的には何らかの5〜10分の音声ファイルとして編集され、ほとんどの場合スピーカーやヘッドホンという2chの音波を発する装置によって発され耳に届くという、コンピューターが発明される前の19世紀の録音技術黎明期の受容の形式から大きくは変化していないと言える。
-
-本論文での、音楽プログラミング言語を設計する第一の問題意識となるのは、このような、コンピューターが本来万能とも言ってもいい可変性を持っているはずで、しかも現状音楽に関与するあらゆるマシンの中にコンピューターが関与しているにも関わらず、音楽や音を用いた表現の形式には変化が乏しいのは何故だろうかという疑問、そして、コンピューターの可変性を十全に発揮するための道具とも言えるプログラミング言語を、音楽という目的に特化させて作ることは音楽表現の新たな可能性の追求としては一見最も素直なアプローチにも見えるのに、なぜ未だにその開発事例が少ないのか、という疑問である。
-
----
-
-# 音楽のためのプログラミング言語:PLfMの指すもの
-
-すでに音楽のためのプログラミング言語：PLfMという用語を用いたが、この語は関連研究に置いても一般的に使われる用語ではない。この語が意味するところは文字通りの意味合い以上のものはないにせよ、なぜわざわざ新しい語を用いるかについての説明をしておく必要はあるだろう。
-
-まず、音楽のためのプログラミング言語は既存の文献では、Computer Music Language[@McCartney2002;@Mcpherson2020]、Language for Computer Music[@Dannenberg2018]、Computer Music Programming Systems[@Lazzarini2013]などといった呼ばれ方がされており、それぞれの語の使用に明確なコンセンサスがあるわけではない。その中でも敢えて筆者がComputerという語を使わない理由のひとつは、Computer Musicという語が、コンピューターを用いることで新しい音楽表現を追求する歴史的な取り組みの中にある、特定の音楽様式と結びついてしまうことを避けるためだ。既に述べたように、今日ではあらゆる音楽制作と再生のためにコンピューターが用いられている以上、あらゆる音楽が**弱い意味でのComputer Music**と呼ぶことができる。しかしそれらの多くはコンピューターでなければ不可能な、コンピューターというメディア固有の表現を行っているわけではない。同様に、たとえばFaust[@Orlarey2004]のような、信号処理のアルゴリズムを抽象化することに特化したプログラミング言語は新しい音楽表現を必ずしも目的としていないが、その技術的要素の多くはComputer Musicのための言語と共通するところがある。またPLfMという枠組みを用いることで、これまでの文献では比較対象に入れられること自体が少なかった、MML:Music Macro Languageのような、五線譜上の記法を直接的にテキストに置き換えたような、単にコンピューター上のテキストというフォーマットで音楽を表すことを目的とした言語たちも、チップチューンのような広い意味でのコンピューターを用いた音楽文化を作るための要素として議論の土台にあげることができる。
-
-加えて、Programming EnvironmentやProgramming Systemといった語を用いない理由も説明しておこう。これは、音楽のためのプログラミング言語といった時に、たとえばMaxのような、ある特定のアプリケーションを想像するニュアンスを抑えるための選択だ。たとえば、汎用プログラミング言語の理論においては、プログラミング言語、と言った時にはその言語を実行するためのソフトウェアやプログラムのことを必ずしも指していない。たとえば同じC++という言語であったとしても、それを実行するソフトウェア（コンパイラ）はGCC、Clang、Microsoft Visual C++といったように複数存在し得るからだ。これらのコンパイラは、どれもC++の厳格な言語仕様で定まっている通りの動作をするが、言語仕様で未定義とされてる動作はそれぞれ異なるし、コンパイラが出力する実行バイナリ（≒アプリケーション）の中身は同じソースコードだったとしても異なる。音楽プログラミング言語においては、基本的にある言語＝特定のアプリケーションであることがほとんどだが、根本的にはアプリケーションの設計実装という作業とプログラミング言語の設計実装という作業は異なり、本研究が対象にしたいのは言語の設計なのだ。こうしたニュアンスを込めて筆者はEnvironmentやSystemという語を用いないことにした。極論を言えば、Faustのような厳密に意味論が定義されている言語においては、コンピューターを用いなくてもそのソースコードを手作業で解釈し実行することが可能だということを考えれば、プログラミング言語はコンピューターを使うための道具であることは間違いないにせよ、人間が直接的にバイナリを操りプログラムを構築するには限界があるという理由で開発されているという意味で、逆説的に徹頭徹尾人間のための道具でしかない。だからComputer Music Languageとも、Computer Programming Languageとも、呼ばずに、ただ音楽のためのプログラミング言語：Programming Language for Music、PLfMなのだ。
-
-# 方法論：メディア考古学デザイン・リサーチ
-
-本研究は、mimiumというPLfMの設計と実装を通して、音楽の制作や聴取環境においてプログラミングという手段がなぜメインストリームな手段とならないのか、音楽におけるコンピューターの利用のされ方が旧来の文化様式に固定されたままなのかの示唆を得ようというものだ。それゆえ、一見PLfMはコンピューター科学における音楽という応用分野として捉えられそうだが、本研究はその研究パラダイムの見直しも射程に入れている。
-
-一般に音楽や、表現のためのソフトウェアやツールのデザイン、制作は、学術的研究としてはコンピューター科学の枠には入るとはいえ、その学問としての枠組みは理論物理学のような、世界を構成する要素を実験によって確かめたり、その法則を数式で記述するようなものとは大きく異なる。ある表現を支援するための道具作りには必ずその表現の様式が先立っており、数多ある表現の種類の中からその特定の表現の存在を肯定するための主張は常に恣意的なものにしかなりえないからである。この時、とくにコンピューターを用いた表現につきものである、 *新しい*表現を可能にする道具を開発するという行為を肯定するためには、まだ誰も見たことも聞いたこともなく、それを記述するための言葉も存在しないような表現の存在を認めなければならないという、記号の投機的導入が必要になってしまう。
-
-この困難に対して、本研究ではmimiumというプログラミング言語を作ることによりあるXという表現（既存のものでは、たとえばアルゴリズミック・コンポジション、スペクトラル・プロセッシング、マイクロサウンドなど）が可能になると言った主張をせず、コンピューターを用いるユーザーが、自分自身で新しい様式や表現方法を開拓することを阻むような重力のようなものに引き寄せられているのではないか、そしてその重力の発生源を突き止めるには、表現のための道具をリバースエンジニアリングすることで（たとえ道具の構造そのものには問題がないとしても）迫れるのではないかという仮説のもとに行動することにする。そしてその時、音楽のためのプログラミング言語をリバースエンジニアリングの対象とする理由は、道具を作るための道具というメタ的存在であること、一般的な音楽を作るための楽器やソフトウェアよりも、必要な背景知識がプログラミング言語理論という音楽とは一見遠そうな分野の知識を含む分、一層複雑に見えるからだ。
-
-このようなリバースエンジニアリングのプロセスを含め、筆者は**メディア考古学**という研究アプローチを参照している。メディア考古学とはそれ自体が明確な定義を与えられることを嫌うような性質を持っているため注意を要する用語ではあるが、ここでの定義は80年代や90年代以降のエルキ・フータモのようなメディア研究者が試みてきた、映画や映像メディアの正史には普通記述されない、万華鏡のような装置に最新テクノロジーへの熱狂の繰り返しの萌芽を見出す[@Huhtamo2015,p83][@Okubo2021,p289]ような、**歴史の中に埋没したメディアを掘り返すことで所与のものとされている歴史に別の物語を与えるアプローチ**としておこう。
-
-メディア考古学のアプローチに存在する微妙なスペクトラムを大久保はメディア環境を形成する要因を「社会-技術」のどちらで捉えるか、学術的貢献の形として重視するのが「歴史-理論」のどちらに重きを置くかという2つの視点で整理しており、この視点はどちらもメディア考古学に共通する思想的背景となっているフーコーの『知の考古学』の解釈に大きく影響されるとしている[@Okubo2021,p285〜289]。「社会-技術」の軸では、作られたメディアテクノロジーが既存の社会的言説の影響のもとに生まれると考えるか、メディアテクノロジー自体がテクストではない形で（たとえばキットラーの例を借りれば、レコードや映画、タイプライターが）言説を形成すると考えるかという違いがある。この中でも「社会」寄りのアプローチとしては、キャロリン・マーヴィンの『古いメディアが新しかった時』に代表される、科学技術社会論（STS）の分野における社会の技術的構成（Social Construction of Technology:SCOT）という領域とも重なることは大久保も指摘しているが、SCOT的研究の中にはそれほど埋没したメディアの掘り下げといった側面を含まず、あくまでテクノロジーが社会的要請によって決定されるという、アンチ技術決定論的側面の方が大きいものも含まれる。SCOTの中で本研究と関連するものとしてはたとえばピンチとトロッコによるモーグ・シンセサイザーの歴史的記述を行った『Analog Days』[@Pinch2004]や、電子楽器用プロトコルMIDIの規格成立過程を追いかけたディドゥックの博士研究及び『Mad Skills』[@Diduck2018]のような研究が挙げられる。
-
-一方「歴史-理論」の軸では、これまで取り上げられなかったメディア装置の一次史料の収集と記述に重きを置く、より歴史学的なアプローチか、既存の史料の中からの選択をし直すことで歴史的記述を再考することに重きを置いているとされる（もっともこれらのアプローチの違いは大久保も強調しているように、対立しているものではなく論者によって重点を置く場所が違うということで、多様なアプローチがあるメディア考古学という領域の見取り図として機能はするという程度のものだと考えた方がいい）。
-
-メディア考古学は注目する対象が多岐にわたるためその全容を一望することは難しいが、本研究はメディア考古学の中でも音、コンピューター、インフラストラクチャという3つの要素が関わる研究であるため、ここでそれぞれの領域において行われているメディア考古学的実践について触れておく。
-
-まず音に関してだが、メディア考古学というアプローチをこの語を用いて整理する研究は映像のような視覚メディアが中心的ではあるものの、音に関わるメディア文化史に関しても、ジョナサン・スターン『聞こえくる過去』[@Sterne2016]に代表される、サウンド・スタディーズと呼ばれる研究領域はメディア考古学と近しい性質を持っている。サウンド・スタディーズ（音研究）は現在では視覚優位のメディア文化論に対するアンチテーゼ[^visualmedia]や、音楽学に収まりきらない、音が関わる文化全般に対するカルチュラル・スタディーズや文化人類学的アプローチによる研究といった側面を持つものの、スターンが前掲書で行った音響再生産文化（Sound Reproduction Technology）としてのフォノグラフやレコードに関わる文化史の再考を「わざと思索的に語った歴史」「歴史をある種の実験室として用いている。それは、音、技術、文化に関して新しい問いを提示することを学ぶため」(ibid,p44)と表現していることが大久保の「移行期にあるメディア理論を再構築するための『実験室』『驚異の部屋』としてメディア考古学的視点が機能しているのだ」[@Okubo2021,p295]という表現と重なることからわかるように、明らかなメディア考古学的アプローチと言える。
-
-[^visualmedia]: もっとも、音文化の研究において視覚優位なメディア文化観に対する聴覚の重要性だけを強調することは、結果的に不要な二項対立や聴覚の神秘化を引き起こしかねないものとして「視聴覚連\UTF{79B1}」とスターンが批判しているもの[@Sterne2016,p27〜34]である。
-
-そして2つ目、コンピューターに関しては、コンピューター自体が「ニューメディア」と表現されることがあるために考古学というアプローチと一見遠い分野に見えそうな一方、計算機に関わる技術自体が驚異的な速度で、様々な隣接領域を巻き込みながら成長している分野である以上、その過去を忘却する速度や歴史的記述の多面性という意味ではコンピューター史以上にメディア考古学的実践が似合う領域もない。それゆえ、この分野では歴史的記述の長さそのものは短くとも、積み上げられてしまった技術要素を研究者自ら解体することによって、透明な背景となっている歴史や文化観を析出させるような性質が強い。古いものではフリードリヒ・キットラーのインテルCPUに搭載されたプロテクトモード批判[@Kittler1998]のような論考が挙げられる。またこうした研究はソフトウェア研究（Software Studies）と呼ばれる分野においてウエンディ・フイ・キョン・チュンが1950年代の最初機コンピューターにおけるプログラミングからソフトウェアに内在するイデオロギーについて検討したように[@Chun2001]、またアレクサンダー・ギャロウェイがTCP/IPのような基礎的プロトコルの成立過程などから新しい形の管理/制御（Control）の権力構造を議論したように[@Galloway2017]、さらに、ソフトウェアやプログラムに完結しきらない、ハードウェアとの連関を考慮するプラットフォーム研究(Platform Studies)におけるイアン・ボゴストとニック・モントフォートのアタリ製ゲーム機が生み出す映像の研究[@Bogost2009]のように、コンピューターというメディア装置の研究においてメディア考古学的省察は至る所で行われている。またこうしたソフトウェア・スタディーズやプラットフォーム・スタディーズに共通する態度としては、研究者自らがプログラミングを行うことで、高度に専門化されているコンピューティング技術やそれに関わる産業構造の批評を表層的な知識でなく実践的に行う、ブラックボックスを開く態度という特徴がある。このことはソースコードそのものを批評的に読み解くクリティカル・コード・スタディーズという研究を行うマーク・C・マリノによるキットラーがソフトウェア研究の過程で残したソースコードの検討[@Marino2001]や、キットラーの研究を行う梅田拓也による、キットラーのアナログシンセサイザー制作経験を彼のプロテクト・モード論考の背景として検討したもの[@Umeda2021]などに見ることができる。
-
-本研究で特に着目するのは（第3章で詳しく検討するが）アラン・ケイとアデル・ゴールドバーグが提示したメタメディアとしてのコンピューターに対する歴史的位置づけと評価である。レフ・マノヴィッチは『ニューメディアの言語』[@Manovich2001]において映画との比較という、これもある意味での考古学的検証においてコンピューターのメディア固有性について検討したが、続く『Software Takes Command』ではコンピューターが新しいメディウム自体を自分自身で生み出せるメタメディアであることにその特徴をより強調し、その原点としてケイとゴールドバーグのDynabookという装置をおいた[@Manovich2013]。一方で、コロラド大学ボルダー校においてMedia Archaeology Labを主宰するロリ・エマーソンは具体詩（コンクリート・ポエトリー）とコンピューターを用いた視覚表現を行うアーティストの歴史的接点として、ケイとゴールドバーグのメタメディアとしてのコンピューターの思想を歴史的原点に位置付けるが、それはマノヴィッチと対照的に、現代のパーソナルコンピューティング環境がメタメディアの不完全な形で社会実装であり、アクセス不可能な装置となってしまった失敗の歴史として位置付けている[@Emerson2014]。本研究はエマーソンの立場に近い態度で、音楽ソフトウェアという異なる領域からやはりDynabookのようなメタメディアとしてのコンピューターの思想を検討することになるが、この立場におけるメディア考古学としてのコンピューター史は、映像や音響メディア史において歴史に記述されることの少なかったメディア装置を掘り返すこととは異なり、ケイとゴールドバーグのようにある種の正当な歴史においても原点として位置付けられている活動を、むしろ失敗した試みとして書き換える試みである。これは「歴史-理論」の軸でいえば既存の歴史に置かれている要素をあえて読み替える「理論」側に寄った位置づけであり、より厄介で注意を要するものだが、本研究における音楽プログラミング言語の制作の一体どこがメディア考古学的なのかという質問への回答は、エマーソンと同じく**歴史を辿ることで現代のコンピューター環境を、万能メディア装置のなり損ないと位置付ける**ことにあると言えるだろう。
-
-3つ目にインフラストラクチャという視点におけるメディア考古学的アプローチという立場だ。ここで筆者が言うインフラストラクチャとは主にISOやANSI、JISで定義されるような標準規格（Standard）やフォーマットのことを意味しており、補集合的な補足をすれば、装置でもなく、アルゴリズムでもなく、コンピュータープログラムでもないが社会や文化に大きな影響を与えているもの、という表現ができるだろう。このインフラストラクチャへの注目の大きな背景としては、科学技術社会論における研究対象が、社会に大きくインパクトを与えた革新的研究（イノベーション）ではなく、すでに社会に浸透してしまったテクノロジーに注目するという反動を起こしたことが挙げられる。ふだん不可視のインフラストラクチャに着目することで知の伝播や政治的権力関係のかたちを明らかにするというアプローチを、ボウカーは「インフラ的転倒(Infrastructural Inversion)」[^inversion][@Star2001,p34]と呼んだが、このインフラの分析においてその成立過程の記述のような通時的分析が多く含まれればそれはメディア考古学的アプローチと多く共通するところがある。これは既に挙げたギャロウェイのプロトコル概念の分析も含まれるし、スターンが『聞こえくる過去』の後に『MP3』で提示したフォーマット理論[@Sterne2012]の概念と大きく共通する。またボウカーはインフラ的転倒の代表例としてベッカーの『アート・ワールド』[@Becker2019]のような、芸術を、それを支える美術館や経済システム、特定の集団の方に着目することで、 「アート作品を生み出す社会分業こそが、それに固有の作品を生産する」（ibid、p423訳者解説）という視点の転換を例に挙げているが、これは音楽という領域で検討すれば、スモールの『ミュージッキング』[@Small2009]のように、ある文化を構成する社会的集団を、たとえば音楽であれば作曲家や演奏家、聴衆だけではなくコンサートのスタッフや楽器製作者も含めることでよりその権力関係や文化のあるべき姿の議論の焦点を合わせやすくするアプローチとも捉えられる。実際スターンはスモールの議論を延長し、「音楽産業など存在しない」というエッセイで、音楽ソフトウェアの開発者が音楽文化を構成する一員として捉えられることが少ないことの不自然さを指摘している[@Sterne2017]。本研究においても、Computer Music Languageという、ある種独立して捉えられてきたソフトウェア群の歴史を、コンピューターを用いている音楽の中におけるソフトウェアというより広い枠組みのなかで編み直すことを目標としており、かつそうした音楽ソフトウェアやプログラミング言語は、それらを用いて作られた音楽だけを事後的に分析する上では不可視なインフラストラクチャと言える点で、これらの研究と問題意識を共有している。
-
-[^inversion]: 「インフラ的転倒」という訳は[@Fukushima2017]に倣っている。
-
-また最後に、芸術実践としてのメディア考古学的アプローチという要素も本研究と接する部分であることを説明する必要がある。フータモが岩井俊雄やポール・デマリーニスのような芸術家の取り組みをメディア考古学的実践のひとつとして位置付けていたり[@Huhtamo2015,7章]、パリッカとハーツがサーキット・ベンディングという電子回路を意図的に壊すことで楽器として用いるアプローチを同様に分析している[@Parikka2014]ように、メディア装置自体を作る、あるいは既存のメディア装置の用途をねじ曲げるような芸術実践は後付け的にメディア考古学的と評されることもある。近年ではこれを作品製作の方法論として自ら用いる（これを**メディア考古学的制作**と呼ぼう）ものが、たとえば情報科学芸術大学院大学（IAMAS）において城一裕が中心となって活動した『車輪の再発明』プロジェクト[@Jo2016]や、Human-Computer Interactionの分野から派生した音楽表現のための新しいインターフェースの会議（New Interface for Musical Expression:NIME）におけるレプリの『Cembalo Scrivano』[@Lepri2018]などのように現れてきている。何より筆者自身も意図的に音響遅延線メモリーのような使われなくなった装置を再構築することで、デジタルデータの身体性を再考するサウンドインスタレーション作品『遅れ/送れ | post/past』[@Matsuura2016]を製作してきたように、そのバックグラウンドはコンピューター科学でもメディア研究でもなく、音を用いた芸術作品制作にあり、そのための方法論としてメディア考古学を用いてきていたということを表明しておくべきだろう。なぜならメディア考古学を制作の方法論として自覚的に用いるということは、単にこれまで描かれることのなかった歴史を描くのみならず、その先頭に自らが作った作品を配置することでその歴史の先に進むべき方向を表明する政治的態度が多分に含まれるという点において、第三者にメディア考古学的アプローチと位置付けられた作品と異なるからだ。その点では、城が背景に挙げるように過去の事象を探索し、ありえたかもしれない現在や、ありうるかもしれない未来（Alternative Presents & Speculative Futures）について思索し議論を引き起こすことを目的としたデザイン・フィクション[@Auger2010]やスペキュラティブ・デザイン[@Raby2013]といった概念との共通点が見出せるだろう。オージャーによれば[@fig:auger]の通り、デザイン・フィクションには大きく分けて現在発展しつつあるテクノロジーが普及した先にある社会像について検討することで「文化のリトマス試験紙」的な役割を果たすことを目指す「Speculative Futures」と、一方で現在のテクノロジーを異なるイデオロギーや組み合わせで用いることで、「我々の現状がなぜこうなのか」を問いかけ直す「Alternative Presents」という2種類の方向があるとしている。メディア考古学的制作は過去の歴史を編み直すという部分でAlternative Presentsの方に近いと言えるが、さらに少し先の未来についても問いかける点でSpeculative Futuresの要素も持ち合わせている。ともあれ、本研究はプログラミング言語を作るという作業を中心に置く以上、メディア考古学という歴史の再組織化を中心においた方法論だけでは研究としての位置づけは片手落ちといったところだろう。そのため、本研究における実際の制作に関してはこうしたデザインにおける運動の中に位置付けることで補完することにする（これは2章で詳しく議論する）。
-
-![[@Auger2010]より、Alternative PresentとSpeculative Futuresの概念を表した図。](img/auger_alternativepresent.png){#fig:auger width=100%}
-
-# mimium制作の目標設定
-
-メディア考古学とデザインという背景をもとにしていることで、mimiumの設計と開発は学術的研究としては次の3つのような特徴を持っている。
-
-**1:まず、研究のアウトプットのひとつであるプログラミング言語、mimiumの設計や実装はプロトタイプではなく、実際に使われることを想定している。**
-
-なぜなら、音楽プログラミング言語がなぜ多くは作られていないのかという疑問に答えるには、その言語の機関部分だけを作るーつまり、Proof-of-Work的なプロトタイプを作るだけでは、たとえば実際にソースコード共有サイトへのアップロード、リリースの作業、さらにリリース後のメンテナンスや、ドキュメンテーションといった、ツールを実際に運用するプロセスの中にも、言語を実際に作るにあたって高いハードルが存在しているかもしれなからだ。実際に、mimiumの実行プログラムのソースコードはすでにGithubに公開されており、何人かが開発の一部に参加してくれてもいる。
-
-<!-- また音楽向けの言語はオリジナルの開発者が中心的役割になって継続的開発、運用を続けているケースが多数を占める。代表的な例としてはPure Dataを開発したMiller Pucketteは今日まで30年近く開発とメンテナンスを続けている。数少ない例外としてはオリジナルの作者が早期に開発から抜け、コミュニティベースで運用を行っているSuperColliderや、Cycling'74という企業によってメンテナンスされるMaxといった例を挙げることができる。 -->
-
-**2:しかし、研究のアウトプットとしてのプログラムで実用的に役に立つほどに完成はしていなくてもよいものとする。**
-
-LISPというプログラミング言語のプログラマーで『ハッカーと画家』というエッセイ集を書いたポール・グレアムはプログラミング言語が常に完成しないという特徴を次のように表現している。
-
-> また、プログラミング言語はまず、 完成されたプログラムの形ではなく、 プログラムがまさに開発されている最中の形をとるということを忘れないで欲しい。 芸術の分野で仕事をしている人なら誰でも、その二つの過程には 異なる媒体が必要になるだろうと言うだろう。 例えば、大理石は最終的な考えを保持するには素晴らしく長持ちする媒体だが、 新しい考えを発展させている時にはおそろしく融通の利かない媒体でもある。
-
-> （中略）われわれはつい、 完成したプログラムがどれだけ良く見えるかで言語の良さを測ってしまいがちだ。 二つの言語で書かれた同じプログラムを眺めて、 片方がもう片方よりうんと短かかったりすると、その議論にはひどく説得力がある。 だが芸術の方向からこの問題に取り組んでみれば、 そういう測り方をしてしまうことは少ないだろう。 プログラミング言語を、大理石のような、完成形は美しいけれど それを使った製作が苦痛であるような媒体にはしたくはないだろう。[@Graham2003](http://practical-scheme.net/trans/desres-j.html)
-
-この文章にはプログラミング言語自体の評価の難しさに、「そのプログラミング言語で書かれたソースコードの読みやすさや簡潔さ」や「そのプログラミング言語でプログラミングをする時のユーザー体験」や、さらには「そのプログラミング言語自体を開発する過程の困難さ」といったことまでを含める必要があると提起しているように読める。
-
-実際のところ、LISPに限らずプログラミング言語やそれを実行するプログラムには明確な完成という状態を定義しにくい。常に新しい言語仕様が追加されたり削除されたりを繰り返しながら時間をかけてアップデートされていく。同じC++という言語でも、C++98という初期バージョンの言語とC++20という最新の仕様では、言語仕様もそれで書かれるソースコードの様式もほとんど別の言語と言ってもいいほどに大きく異なる。
-
-さらに、プログラミング言語の開発やそれが実際に使われるようになるまでには一般的に2年を超える長い時間がかかるため、実用になって初めてその内容を研究として提示するプロセスを取ってしまっては研究サイクルとして時間が掛かりすぎるという問題がある。たとえばRubyを開発したまつもとゆきひろによればRubyの開発自体は1993年に成され、最低限の機能が揃ったのは半年後[@Matsumoto2014,51p]ながら、最初に公開されたバージョンである0.95は1995年と2年の時間を要している。音楽系の言語の例で言えば、mimiumの参考になっている言語であるFaustはプロジェクト自体が始まったのが2002年(https://faust.grame.fr/about/)だが、最初にリリースされた正式なバージョン0.9.0はやはり2年後の2004年になってリリースされている（https://github.com/grame-cncm/faust/tree/v0-9-0）。
-
-それでも研究対象としては具体的な幾つかの言語仕様に焦点を当てて議論を行うことで学術的な知見を生み出すことは十分に可能だと言えるはずだ。実際にmimiumは最初のバージョンをリリースするのに9ヶ月、そもそも音楽のための言語でありながら信号処理をして実際に音がなるまでに7ヶ月の時間を要しており、この論文が書かれている現在(バージョン0.4.0)でも、外部ファイルを読み込むinclude機能は単なるテキスト置換で行っており、実行性能の効率も悪いし予期しない動作を引き起こしかねないという、とりあえずの間に合わせとして実装されているように、暫定的な機能やバグが多数存在する。
-
-**3:学術的研究として、作った言語の評価としてユーザーからのフィードバックを（定量的な実験結果であれ、インタビュー等の質的な内容であれ）必ずしも必要としない。**
-
-これはコンピューター科学の研究として考えると一見異質に思えるかもしれないが、その理由としては、筆者が焦点を当てたいのは音楽プログラミング言語がなぜ使われないかよりも、なぜ作る人の人数が増えないのかという問題であること、さらには、プログラミングという行為は、誰かの作ったライブラリのソースコードが公開されてさえいれば、その中身をどこまでも辿っていける、知識の階層を思うがままに辿っていける道路のネットワークであるにもかかわらず、コンピューターの中で音を（アプリケーションなどを通して）扱うことと、音楽や音のためのプログラムを作ること、さらには音楽や音を**記述するためのプログラム**：音楽プログラミング言語を作るということにはそれぞれ大きな隔たりがある、という問題であるからだ。この疑問に答えるために調べなければいけない対象は、すでに多く研究対象となっているユーザー：音楽のためのプログラム、アプリケーションや音楽プログラミング言語を仕様する人たちだけではなく、むしろ研究主体である自分自身とその経験なのだ。つまり音楽プログラミング言語やそれを作るという行為がブラックボックス化されている現状を、自らの手で作ることによって開き、そこで使われる知識や語彙の体系化を改めて試みることで疑問に対するヒントを掴むような道筋を辿ることになる。
-
-もちろんこれは、1.で述べたように実用的なツールとしてもmimiumを開発している以上、そのツールをよりよいものにしていくために今後ユーザーにインタビューなどの形でフィードバックを求めること自体は有益になるだろう、という意見を否定するものにはならない。
-
-まとめると、本研究は、何か既存の言語に足りない機能があったり、既存の言語ではできない表現があるので新しい言語を作るのではなく、言語の実装と文献調査を通して、音楽プログラミング言語という研究領域はどういった領域か、またその領域にどんな課題があるかといったものを明確化することを主眼においている。いわば、音楽のためのプログラミング言語という、コンピュータ科学や音楽全体からすれば応用分野である領域において基礎研究を行おうとしている。そのため、プログラミング言語mimium自体も特定の問題意識や仮説に基づいた設計や実装が行われてはいるものの、実装するうちにその問題意識も徐々に変化していることには留意する必要がある。第2~4章におけるPLfMの歴史的背景と第5章で議論するPLfMの存在論はmimium実装のためのモチベーションであると同時に、mimiumを実装することによって得られたリサーチ・アウトプットでもある。
-
-このような考察→設計→実装→考察…といった循環的な作業を行う以上、それを問題提起→解決という線状のプロセスに形式的にでも開くことは、試行と実験を繰り返す中で発生する考えの変遷のディテールを削いでしまうことは否定できない。そこで、それを補うためにもmimiumの設計と実装が時系列的にどのように行われてきたかについてをまず簡単にまとめておくことにする。
diff --git a/chapter2.md b/chapter2.md
index 73528d6..e55b808 100644
--- a/chapter2.md
+++ b/chapter2.md
@@ -1,6 +1,14 @@
+---
+title: 第2章 - 歴史を記述しなおすデザインリサーチ
+draft: true
+---
+
 <!-- どうコンピュータ音楽プログラミング言語を研究するか -->
 
-\epigraph{歴史的出来事は、この「人間的コンテクスト」の中で生成し、増殖し、変容し、さらには忘却されもする。端的に言えば「過去は変化する」のであり、逆説的な響きを弱めれば、過去の出来事は新たな「物語行為」に応じて修正され、再編成されるのである。}{『\citefield{Noe1990}{title}』\citep[p11]{Noe1990}}
+<!-- \epigraph{歴史的出来事は、この「人間的コンテクスト」の中で生成し、増殖し、変容し、さらには忘却されもする。端的に言えば「過去は変化する」のであり、逆説的な響きを弱めれば、過去の出来事は新たな「物語行為」に応じて修正され、再編成されるのである。}{『\citefield{Noe1990}{title}』\citep[p11]{Noe1990}} -->
+
+> 歴史的出来事は、この「人間的コンテクスト」の中で生成し、増殖し、変容し、さらには忘却されもする。
+> 端的に言えば「過去は変化する」のであり、逆説的な響きを弱めれば、過去の出来事は新たな「物語行為」に応じて修正され、再編成されるのである。[@Noe1990,p11]
 
 # 音楽のための道具づくりを研究するとはいったいなんなのか
 
@@ -42,7 +50,7 @@ RtDが立ち上がる中で重要視されてきたのは研究を行う中で
 
 # 隣接する学術領域 {#sec:researchfield}
 
-![音楽とコンピューティングに関わる研究領域の見取り図。](img/musiccomputing.pdf){#fig:musiccomputing width=100%}
+![音楽とコンピューティングに関わる研究領域の見取り図。](../img/musiccomputing.png){#fig:musiccomputing width=100%}
 
 まず、音楽のためのコンピューターを用いた道具づくりや、本研究で行う音楽のためのプログラミング言語（Programming Language for Music:PLfM）の研究を取り巻く研究領域について概観しよう。代表的な研究領域の重なりを[@fig:musiccomputing]に示した。
 
@@ -78,7 +86,7 @@ RtDが立ち上がる中で重要視されてきたのは研究を行う中で
 
 # デザインリサーチの変遷——デザインサイエンス、デザイン思考、RtD
 
-![デザインリサーチの歴史の見取り図。](img/design_history.pdf){#fig:designhistory width=100%}
+![デザインリサーチの歴史の見取り図。](../img/design_history.png){#fig:designhistory width=100%}
 
 それでは、こうした学問的付置はどのような歴史的経緯で成立してきたのだろうか。本稿ではその成立過程をデザイン学の歴史的変遷を中心にした視点で追いかける。[@fig:designhistory]はその大まかな見取り図と運動に影響を与えた代表的文献を時間軸上に配置したものである。
 
@@ -149,7 +157,7 @@ RtDが立ち上がる中で重要視されてきたのは研究を行う中で
 
 この奇妙さについて科学社会技術論の文脈でなされた説明がある。ハロ・ヴァン・レンテらが「科学技術における『期待』の社会学」と銘打った研究の中では、ムーアの法則のような未来予測は結果の予測というよりもむしろ、産業を発展させるための投資をブーストさせるような「期待」を自ら引き起こすことで、産業界などの動向を決定づけるための要因として自己参照的に働くものだとされる。結果的に技術者たちがその期待に応えることによって予測通りの形に落ち着いているように見えている、と解釈するのである[@Yamaguchi2019,p7]。ブラウンやレンテらはこの自己反映的なプロセスを[@fig:brown]の様に入れ子状の過程として説明している[@Brown2003]。
 
-![ブラウンらによる、技術発展における約束と要求の推移過程を示した図。[@Brown2003]をもとに筆者が作成。](img/brown.pdf){width=100% #fig:brown}
+![ブラウンらによる、技術発展における約束と要求の推移過程を示した図。[@Brown2003]をもとに筆者が作成。](../img/brown.png){width=100% #fig:brown}
 
 何らかの技術的要素が社会的利益を生みそうだという兆候がまずある未来予測（≒ムーアの法則）を生み、その予測をもとに科学技術の進むべき方向性が決定され、一度それが可能な研究となった場合、その研究分野の開発は研究者たちへ「権限が委任(mandate)」される。このとき科学者にとっては安定して研究開発に臨む保護された領域が作られると同時に、その目標の達成に責任（≒ムーアの法則に追いつくこと）を負うことになる。そして実際の実現のためにはこのプロセスがより小規模な可能性と兆候、未来予測に基づいて再起的に発生していくというモデルだ。このネストした循環というのは、たとえばレイ・カーツワイルのシンギュラリティ論[@Kurzweil2007]の様な、典型的技術決定論者の未来予測という大きなループの根拠にムーアの法則が用いられる状況をよく説明している。
 
@@ -219,7 +227,7 @@ RtDにおけるもう1つの重要な視点は、デザインされたものを
 
 # 歴史を作り直すデザイン
 
-![オージャーによる、Alternative PresentとSpeculative Futuresの概念を表した図[@Auger2010]。](img/auger_alternativepresent.pdf){#fig:auger width=90%}
+![オージャーによる、Alternative PresentとSpeculative Futuresの概念を表した図[@Auger2010]。](../img/auger_alternativepresent.png){#fig:auger width=90%}
 
 さて、Research through Designのアプローチは例えばクリティカル・デザインやスペキュラティブ・デザインの文脈ではサイエンス・フィクションから影響を受けてきたように、作った物を利用している状況を映像作品として提示するなど、物語を有効活用してきたという特徴も挙げられる。こうした物語のデザインへの活用は特にスペキュラティブ・デザインでは『The Pillow』のように、未来のありえるかもしれない技術の姿への想像力を喚起するためのツールとして人工物を用いることが多い。しかしサイエンス・フィクションは未来の姿を想像するだけでなく、過去への探索をきっかけとして、例えば電気技術ではなく蒸気機関が極端に発達した世界を描くスチームパンクのような、並行世界の現在の姿を描きだすという立場も考えられる。デザイン研究者のジェームズ・オージャーはこの違いを[@fig:auger]のように、*ありえるかもしれない未来（Speculative Futures）*と、*ありえたかもしれない現在（Alternative Present）*という違いとして表している[@Auger2010]。
 
@@ -263,7 +271,7 @@ RtDにおけるもう1つの重要な視点は、デザインされたものを
 
 大久保はメディア考古学研究群のアプローチに存在する微妙なスペクトラムを、メディア環境を形成する要因を「社会-技術」のどちらで捉えるか、また学術的貢献の形として「歴史-理論」のどちらに重きを置くか、という2つの視点で整理している[@Okubo2021,p285〜289]。大久保によれば、この視点はどちらもメディア考古学に共通する思想的背景となっているフーコーの『知の考古学』の解釈に大きく影響されるとしている。[@fig:mediaarch]にこの立場の広がりの概念を示した。
 
-![[@Okubo2021]をもとに作成した、メディア考古学の立場の広がりを示した図。](img/mediaarchaeology_position.pdf){#fig:mediaarch width=80%}
+![[@Okubo2021]をもとに作成した、メディア考古学の立場の広がりを示した図。](../img/mediaarchaeology_position.png){#fig:mediaarch width=80%}
 
 横軸である「社会-技術」の軸では、作られたメディアテクノロジーが既存の社会的言説の影響のもとに生まれると考えるか、メディアテクノロジー自体がテクストではない形で（たとえばフリードリヒ・キットラーの例を借りれば、レコードや映画、タイプライター[@Kittler1999]が）思考や言説を形成すると考える違いがある。この中でも「社会」寄りのアプローチとしては、キャロリン・マーヴィンの『古いメディアが新しかった時』[@Marvin2003]に代表される、STSにおける社会構築主義的立場の1つ、社会の技術的構成（Social Construction of Technology:SCOT）という領域とも重なる。SCOT的研究の中にはそれほど埋没したメディアの掘り下げといった側面を含まず、あくまでテクノロジーが社会的要請によって決定されるというアンチ技術決定論的側面の方が大きいものも含まれる[^scot]。
 
@@ -273,15 +281,15 @@ RtDにおけるもう1つの重要な視点は、デザインされたものを
 
 メディア考古学はメディアの歴史や、メディアがわたしたちの身体や知覚に及ぼす影響を考察するためのフレームワークという側面が大きい。とはいえ、使われなくなったメディアに着目することは、ニューメディアアートやインタラクションデザインなどにおける作品制作のアプローチとしてメディア考古学という概念が立ち上がるよりも前から行われ続けてきた。フータモは岩井俊雄のゾートロープ的装置を拡張する『時間層』シリーズのような作品群や、ポール・デマリーニスの『エジソン効果』の中で陶器の壺に刻まれた溝をレコードとして扱い音を読み出す試みのような芸術家の取り組みを、メディア考古学的実践のひとつとして位置付けている[@Huhtamo2015,7章]。同様にパリッカとハーツがサーキット・ベンディングという電子回路を意図的に壊すことで楽器として用いるアプローチを分析している[@Hertz2012][^bending]。これらの分析には作家の意図に関わらず、いわば後付け的にメディア考古学と評される場合も含まれる。例えばデマリーニスの場合は作品制作の中のリサーチにで過去の期限の切れた特許資料の中からアイデアを得ていたり、明確に過去のメディアに対するリサーチを行っている。一方で、サーキット・ベンディングのようなアプローチは実践している者からすれば面白い音が鳴るように回路を改造しているだけという側面も強い。
 
-[^bending]: [@sec:failure]も参照。
+[^bending]: [第3章](../chapter3_rendered)も参照。
 
 その上で近年では、作品制作にメディア考古学の方法論を明確に自覚して用いるプロジェクトが現れてきている。たとえば第1章で既に例示した、情報科学芸術大学院大学（IAMAS）において城一裕が中心となって活動した『車輪の再発明』プロジェクト[@Jo2016]や、NIMEのような楽器制作の方法論の文脈でもジャコモ・レプリの『Cembalo Scrivano』[@Lepri2018]のような例があらわれている。本稿ではこのような、メディア考古学的視点を自覚的に作品制作のプロセスに導入する立場を**メディア考古学的制作**と呼ぶ。
 
-何より、筆者自身が意図的にメディア考古学を作品制作の方法論として用いてきた1人である。例えば磁気コアメモリよりもさらに古い1950年代の電子計算機黎明期に用いられた、音響遅延線メモリーと呼ばれる音波のフィードバックループを用いてデジタルデータを保存する記憶装置を空間に開かれた形で再構築するインスタレーション作品『送れ｜遅れ / post｜past』では、物質的状態を固定しないままにデータを保存する音響遅延線メモリを物理的に分離された2台の通信装置として構成することで、通信と記録の不可分性を顕在化させた[@Matsuura2016]（[@sec:delaymemory]も参照）。
+何より、筆者自身が意図的にメディア考古学を作品制作の方法論として用いてきた1人である。例えば磁気コアメモリよりもさらに古い1950年代の電子計算機黎明期に用いられた、音響遅延線メモリーと呼ばれる音波のフィードバックループを用いてデジタルデータを保存する記憶装置を空間に開かれた形で再構築するインスタレーション作品『送れ｜遅れ / post｜past』では、物質的状態を固定しないままにデータを保存する音響遅延線メモリを物理的に分離された2台の通信装置として構成することで、通信と記録の不可分性を顕在化させた[@Matsuura2016]（第4章も参照）。
 
 別の例を挙げれば、筆者が2018年に、第1章冒頭で説明したSFPC滞在中に作った『Electronic Delay Time Automatic Calculator（EDTAC）』（[@fig:edtac]）がある。EDTACは、「はじめからコンピューターの設計の中に時間の概念が組み込まれていたらどうなっているか」という問いを提出するために作られた、極めてプリミティブな計算機である[@Matsuura2018;@Matsuura2019,第4章]。現在使われている一般的なコンピュータは音楽のように時間に関係する処理を日常的に行っているにもかかわらず、その理論的基盤には時間の概念が一切含まれていない。EDTACはプログラムされた通りに時間を分割しクリック音を鳴らし続けるだけの機能しか持っていない。しかしちょうど世界最初の電子計算機であるENIACがケーブルを配線し直すことで物理的にプログラムを構成していたように、抵抗の内蔵されたケーブルと光ファイバーという物質的接続によって分割する時間間隔が決定される、というように、ハードウェアレベルで時間操作がその中核に組み込まれている。EDTAC手で作られた回路彫刻として提示され、全く異なる形の計算機の存在の可能性を問いかけるようになっている。
 
-![Electronic Delay Time Automatic Calculator（EDTAC）（2018）。撮影：Filip Wolak](img/edtac-filipwolak.jpg){#fig:edtac width=80%}
+![Electronic Delay Time Automatic Calculator（EDTAC）（2018）。撮影：Filip Wolak](../img/edtac-filipwolak.jpg){#fig:edtac width=80%}
 
 こうしたメディア考古学的実践を今日のデザイン研究の中に位置付けるにあたり注意を要し、かつ自分自身も不満を残し続けてきたのは、メディア考古学的制作における作者や作品といった単位の問題である。クリティカル・デザインのような未来についての問いかけを行うデザインは、現実的には役に立ちそうもないものだからこそ、その発表の場としてギャラリーや美術館という場所が選ばれる。このことはメディア考古学的制作をデザインのアプローチとして用いる場合にも共通する点だが、2つの点で問題を招く。ひとつはCultural Probeで問題意識に据えられていたように、ギャラリーのようなあらかじめ美術を想定して作られた場にデザインした物を置くことによって、それは人々の日常生活から離れて、単に鑑賞の対象となってしまうことである。もうひとつはロスナーが批判した個人主義のように、デザインされた物とデザイナー個人の記名性が過剰に結びついてしまい、デザインの内容そのものよりも誰がどういった内容の作品制作を続けているかという点に重きがおかれ、社会の中におけるデザイン運動の中の流れの1つとして捉えることが難しくなってしまうことだ。
 
diff --git a/chapter2_memo.md b/chapter2_memo.md
deleted file mode 100644
index 1e54139..0000000
--- a/chapter2_memo.md
+++ /dev/null
@@ -1,152 +0,0 @@
-日常的行為の中に存在する、体系化されることのない様々な技法（method）に着目するエスノメソドロジーの分野の代表的研究者であるエリック・リビングストンは数学の証明プロセスや科学実験を自ら行うことによってその過程に存在する暗黙的なテクニックの存在を明らかにする研究を行っている[@Livingston1986]。エスノメソドロジーは通常その分析方法が会話分析という手法と結び付けられているが、西阪はリビングストンのような自ら実践することで明らかにするという手法も存在することを強調している[@UCILAB2020]。
-
----
-
-ここでフレイリングの提言の以下の部分を改めて読み直すと、彼がリサーチ行為の枠組みをinto、through、forという3つのリサーチとして示そうとしていた理由は実のところ、研究プログラムのメタ研究といったモチベーションよりも、研究の形骸化や自己目的化への危惧であるように読める。
-
-> 確かに、研究〔ここではResearchの訳〕は学術的な問題であると同時に、同じくらい政治的、もしくは財政的な問題になってしまった。そして、少し脱線するが、アカデミアで生計を立てている人たちが自分で「アカデミック」という用語を軽蔑の意味で使っているのを見ると可笑しくなってしまう。研究は概念的や実践的なものまでもと同様に肩書きの問題になってしまった。そして正直なところ私はこれを心配している。こうした感情的伝統の中で研究を行える場所も残るかもしれないが、肩書きや階級、逆スノッブについて白熱した議論を交わすのではなく冷静な研究を行う必要がある。[@Frayling1993,筆者訳]
-
-フレイリングはRが大文字のResearchという単語における辞書的な定義がイノベーションのための基礎研究という意味が小文字のrのresearchよりも強調されるようになったという変化にまず着目していた[^rosenberg]。学術研究を行う機関である大学でさえも、その研究を行うために必要な資金がある特定の「期待」された領域に向けて投入される様な状況がある限り、リッテルがデザインサイエンスにおける意地悪な問題で提起したように、またレンテやブラウンが期待の社会学で議論したように、研究開発が合理性という皮に隠れた無自覚の自己反映的なループに巻き込まれざるを得ない。フレイリングの議論の焦点もまた、3つの区分けそのものよりも、研究という行為への自己反省の足らなさの方だったのだ。
-
-[^rosenberg]:Researchという語がResearch & Development（R&D）という用語として、この大文字の意味合いを含み始めた原点には、何らかの知の発見（≒効率化）によって物の生産コストが低下するという、経済学の中にテクノロジー発展が重要な要素として考慮されるようになった歴史がある。ローゼンバーグはその原点に、今日のコンピューターにおける、データとプログラムを等価に扱う考え方を先取りしていた、機械式計算機である階差機関/解析機関を開発したチャールズ・バベッジの『機械類と製造業の経済について』という論考にあると評している。バベッジのこの論考はカール・マルクスの資本論における労働と生産の関係性に影響を大きく与えたことが言及されている[@Rosenberg2001]。[@Arato1996,p133]も参照。
-
-こうした意図から離れてリサーチの3つの分類だけが広まってしまい、RtDをひとつのメソドロジー程度の認識で用いるという、結果的に皮肉にもフレイリングが危惧した研究プログラム自体の形骸化とも言える状況が発生している。とはいえもちろん、ツィマーマンをはじめとして研究としてのデザインについて考察し続けている者からは、フレイリングの3分類が曖昧であり、デザイン研究者が取るべき実践のガイドラインとしての理論たりえないという理由をもとに批判的な形で継承がなされてきてもいる[@Jonas2004][^fraylingcrit]。これはSSK自体が行き過ぎた相対主義として後に批判を喰らったことの相似形とも言えよう。そうした批判的視点を持ちつつも、形骸化する事なく実践としての知の創出をする学問としてのデザインのフレームワーク作りは継続して試みられている。代表的なものがコスキネンやツィマーマンらによる『構成的デザインリサーチ（Constructive Design Research）』である。
-
-[^fraylingcrit]: 筆者としては、そもそもフレイリングは3つの分類の用語を提示することそのものは硬化した研究プログラムの区分けを崩す例示のひとつとしてあげたに過ぎないと見る方が妥当で、フレイリングを責める事はお門違いのようにも感じる。とはいえ例えばフレイリングの『新しいバウハウス：21世紀の芸術教育』[@Frayling2007]という論文を始めとして、彼の議論には自らの手でものを製作したり、制作を通じて教える事に重きが置かれ、言葉を用いたコミュニケーションや理論作りの重要性が相対的に軽んじられ過ぎているように読めるのも確かではある。
-
-[^ofandinto]: フレイリングの論文ではintoだったが、ofやaboutといった語が用いられることもある。
-
-コスキネンらは、広がりつつあるデザインの対象とその手法を活動の場という視点でLab、Field、Showroomという3つに分類した[@Koskinen2015]。LabにおけるRtDは本論文でも中心的に議論の対象となっている、HCI研究、生態学、認知心理学などに由来し、プロトタイピングと評価実験を繰り返しその価値を提示する。FieldでのRtDは文化人類学などに由来する、ユーザーがいる環境を社会科学的な質的な調査法を中心に理解することを目指した研究である。そしてShowroomでのRtDはいわゆるクリティカル・デザイン[@Marpus2019]やスペキュラティブ・デザイン[@Dan2013]に代表される、ありえるかもしれない並行世界に存在しうるような装置や、時にユーモアを交えた不合理さを持つ、必ずしも現代において役立つものではないプロダクトのような人工物を、物語、展示や映像といった表象を組み合わせることで、社会構造に対する批評的役割を担ったり、議論を促すことを目的としたアプローチだ。
-
----
-
-# NIMEの研究法に関する研究
-
-ダールは音楽のための新しいインターフェース：NIME研究は学術研究としてどのように位置づけられるかを、特にデザイン学を中心に検討した論考の中で、いくつかの指摘と問題提起を行う[@Dahl2015]。まず、新しい楽器を作ることは意地悪な問題の一類型であるということだ。もちろん、楽器の研究という領域が、例えば環境問題のように複数の関係者が相反した利害関係にあるような大規模な問題と全く同じような類の意地悪さではないのは確かだが、最低でも明確な議論のガイドラインが存在しないということや、一般化できる事例が少な過ぎて理論化しづらいという意味では、明確に科学的事実を明らかにする研究パラダイムとは異なるということは直感的に受け入れられる。
-
-加えて、ダールはストークスの研究という行為を基礎的理解(≒知の創出)のための研究であるか？という軸、実用されることを考慮されているか？という軸の2つで分割した「パスツールの象限」[@Stokes1997]を参照しNIME研究の位置付けを試みる。[@fig:stoke]において、知の創出かつ実用を目的としない左上の領域は例えば量子力学におけるボーアのような基礎研究の領域であり、一方実用されることだけを目的とし知の創出そのものは目的としない右下のエジソンの発明群、そして、右上に実用的な理由に牽引されつつも新しい知の基礎となったパスツールの乳酸発酵の研究などがある。
-
-![ストークスによる研究の象限。[@Dahl2015]より。](img/stokequad.png){#fig:stoke width=50%}
-
-この象限にNIME研究を位置付けるとすればどこになるだろうか？右下の実用だけを意識したものだとすれば、それは企業が生産する楽器群とどのように区別ができるのだろうかという問題がある。実際にダールは、フォールマンによるデザインリサーチの3つ組という分類[@Fallman2003]を参照し、パスツールの象限における右下の領域と対応する、「産業とのインターフェース」であるDesign ProcessというカテゴリはNIME研究において企業が一般的に楽器を作るプロセスと対応するという。
-
-一方右上の実用を通じて知の創出を得る研究なのだとすれば、1.その知とは一体なんなのか、2.その知をいかに証明できるか、3.その知は一体いつ発生するのかといった問題群が浮かび上がってくる。仮にNIMEで創出できる知もゲイバーがいうようなAnnotated Portfolioのように、理論として一般化することができず、個々の差異との比較によって議論されるものだとしたらいったん1.(What)と2.(How)は横に置いておいてもよいだろう。しかし3.(When)は筆者のようなソフトウェアを研究するものにとっては考えるべき重要な問題になる。つまり、NIME研究をするという時に、楽器を作る過程で得られる知見と、その楽器を演奏するとき、あるいは評価実験などでユーザーに使ってもらうことで得られる知見とが混在していることをダールは指摘しているのだ。
-
-
-# プログラミング言語における量と質の相互作用
-
-こうしたデザインの個別性に伴う理論の一般化や評価の困難さは本論文で検討するもう1つの領域、プログラミング言語一般に関する評価について検討することでもう少し明確な議論をすることができる。
-
-音楽目的に限らない、システムレベルのソフトウェア開発などに使われるプログラミング言語の設計を考えれば、その言語によって作られるアプリケーションの実行速度は明らかに重要な評価指標であり、また（使われるマシンの種類などの環境を揃えれば）定量的に計測することが可能である。では、あるプログラミング言語のコンパイラの機能Xの実装を工夫することにより、実行速度を20%ほど改善できたとしたら、それはなんらかの事実を解明したことになるのだろうか、それともある手法やソフトウェアといった人工物を生成したことになるのだろうか？といったように、プログラミング言語という分野自体、1960年頃から工学的なアプローチで長く研究がされている中、学術的研究としてどう正当化するか、特にどのように評価すればよいかという話題は2009年のACM SIGPLAN（Special Interest Group of Programming Language:プログラミング言語の国際会議を主催する団体で最も大きなもの）主催の*PLATEAU: Evaluation and Usability of Programming Languages and Tools*が開催されるまであまり触れられてこなかった。
-
-2010年のPLATEAUでマークストラムは新しい言語の実装や設計などのアイデアを論文として提示する際の正当化の方法として、**主張と根拠の整合性(Claim-Evidence-Correspondense)**という見方を提示する[@Markstrum2010]。マークストラムによれば、プログラミング言語の論文で提示される主張は大きく分けて3種類あるという。1つ目はこれまで存在しなかった新機能を作ったというもの、2つ目はすでにある既存の機能の効率性を上げるような内容、3つ目は望ましい言語の特徴(property)、つまりこの言語は直感的である、読みやすい、効率的であるといったような内容だ。しかしこれまでのプログラミング言語の提案の論文には、1と2、つまり新機能と機能の増強に関しては論文が査読されたものであるならば十分認められるものであるが、望ましい言語の特徴に関してはその主張と、それを支える根拠は両方とも提示されているが論理的な結びつきは不十分なものが多数あるとしたのだ。
-
-こうした研究はのちにより近年のコブレンツらによるプログラミング言語における評価語彙の整理（第5章で詳しく紹介する）などにつながる。主張と根拠の整合性を証明する方法論は統計的な評価実験のような実証主義的方法だけでは不十分とマークストラム自身も警鐘しており、例えば近年のミュラーとリングラーの修辞的フレームワークのように、論文中で主張された表現の変遷などを人文学的手法で辿ることで明らかにするような研究が進んでいる[@Muller2020]。
-
-つまりプログラミング言語という領域における知の創出の体系は、新しい文法の提示のような生成的な人工物、ベンチマークテストのような量的に計測、比較ができる結果、ユーザーインタビュー調査のような質的調査の結果、主観評価実験のような統計的手法による量的なユーザーフィードバックといった様々な種類の論拠を組み合わせて、効率が良い、読みやすい、表現力が高いと言った主張をなんらかの修辞的な方法によって結びつけることによって行われる。
-
-このようにプログラミング言語という領域が、論拠に関してはある程度反証可能性が存在する、しかし最終的に作られた言語そのものの定量、定質的評価が難しいという形而上学とも形而下学(≒科学)とも言える独特の体系を持つ理由としては、量的な特徴の変化がその言語の質的な変化に大きく影響を与えることが時にあるという事情も挙げられる。
-
-例えば音楽プログラミング言語に関していえば、アルゴリズムを用いた作曲を同じ手法でも、人間が手動では行えないような計算速度を借りることによって異なる種類の音楽にすることができるし、第4章で見るように、音楽プログラミング初期の一度信号処理の結果をテープに書き込んでから再生する方式と、80年代以降のリアルタイムに信号処理ができる環境とでは作られる音楽の質も大きく異なる。一見単純な実行速度という量的な指標はある段階から質的な問題へと転化するのだ。加えて、より事情を複雑にする問題としては、例えばライブコーディングのような、プログラムの動的変更のしやすさという質的特徴を強化した言語を作ろうと思うと、プログラムの実行性能は静的な言語と比べると低くならざるを得ないという、いわば**量的特徴と質的特徴間のトレードオフ**が発生するという問題がある。
-
-こうした事情を鑑みれば、ベンチマークや主観評価実験、インタビュー調査といったあらゆる手法による証拠そのものにはそれが存在するだけである程度一次資料として有用性もあるし、ただ実行速度が上がるような改善をもたらすだけでもその言語の存在意義に関わる変化となる可能性はある。そこから先の、その言語を使うことによって何が起きるか、何が可能になるかといった主張の正当化の手段として、ゲイバーの言うような人工物のAnnotationを補強するものとしてこれらの論拠を使い、個別の言語の具体性をより高め、理論化は個々の差異を見ることによって可能になる反証できない生成的学問として取り扱う。このような実証的研究法と形而上学的研究法の棲み分けをすることでRtDとしてのプログラミング言語研究という領域を定義することができよう。音楽プログラミング言語は、汎用プログラミング言語よりも量的に測れない指標が必然的に多くなってくる研究対象であるため、半ば惰性的に続けられている工学的アプローチ以外の研究方法を定義しておくことは有益なはずだ。
-
-
-
-# 音楽プログラミング言語のデザインという研究領域
-
-![ゲイバー、マークストラム、ミュラーらの議論を統合した、RtDとしてのプログラミング言語の研究の概念を表した図。](img/researchprogram.png){#fig:researchprogram width=80%}
-
-さて、ここまでの議論を[@fig:researchprogram]にまとめた。プログラミング言語のための新しい文法やアルゴリズムを提案するという作業は時に既存の研究内容から飛躍することもある生成的な作業である。そしてそれによって成される主張は時に主観的な用語を用いる不明瞭なものでもある。そうした主張を支えるものとして、ある程度反証可能な方法で論拠を提示する。これには主にベンチマークや主観評価実験に基づく定量的データによる論拠、文献調査、インタビューとその分析、エスノグラフィと言った様々な手法によって得られる質的なデータによる論拠、時にその両方が存在することになる。その論拠と主張は適切な修辞によって結び付けられ、そのclaim-evidenceの結び目を持って生成した言語やアルゴリズムという人工物に注釈：Annotationを付ける。これらの要素はある程度独立性があるため、例えば論拠となっているベンチマークの測定に間違いがあったり、質的データ分析の方法論が適切でなかったとしてそれらのデータを取り下げたとしても、作られた音楽プログラミング言語という人工物そのものを丸ごと棄却しなければならないわけではない。新たにデータを分析し直して適切に主張と結びつけ直すことができればその言語の学術的価値を改めて提示することができるだろう。
-
-注意しなくてはならないのは、論拠はあくまでも主張と結びつくことによってはじめて意味があるものとなるので、単に言語Aにおけるベンチマークと言語Bのベンチマークを比較してAのほうが性能が高かったからといって、言語Bは淘汰されるべきということにはならない。これは量的特徴と質的特徴のトレードオフの問題を考えれば当然とも言えることだろう。加えて、論拠には様々な研究パラダイムが混在しており、質的研究の中でも実証主義的—解釈主義的なスペクトラムが存在しているため、自分がどの立ち位置で論拠を見出そうしているのかを依然自覚する必要がある[@Otani2019,p30~p32]。それゆえ、例えば実証主義的な方法に依った論拠として、ベンチマークを取るのであればその手法や環境は再現可能性が担保されているべきだし、評価実験を行なったのであれば、その実験自体も追試が可能なものであり、実験によって得られたデータの分析方法も検証可能なものでなければならない。音楽プログラミング言語という人工物を提示することによる主張それ自体が反証不可能だからといって、そのための注釈もすべて反証不可能であり再現性が担保される必要もないということには当然ならない。
-
-加えて、音楽プログラミング言語という領域で考えれば、ダールのNIME研究におけるWhenの問題を考えれば、作られた音楽プログラミング言語を用いて作った音楽、プログラム、パフォーマンスといった二次人工物とでも言うべきものが、それ自体デザインの成果としての比較対象になる独立性を持ちながらも、その経験を通したインタビューやエスノグラフィといった、新たに一次人工物に注釈を付けるための材料にもなっているという、再帰的な構造を持っていることがわかる。
-
-
----
-
-メディア考古学は注目する対象が多岐にわたるためその全容を一望することは難しいが、本研究はメディア考古学の中でも音、コンピューター、インフラストラクチャという3つの要素が関わる研究であるため、ここでそれぞれの領域において行われているメディア考古学的実践について触れておく。
-
-まず音に関してだが、メディア考古学というアプローチをこの語を用いて整理する研究は映像のような視覚メディアが中心的ではあるものの、音に関わるメディア文化史に関しても、ジョナサン・スターン「聞こえくる過去」[@Sterne2016]に代表される、サウンド・スタディーズと呼ばれる研究領域はメディア考古学と近しい性質を持っている。サウンド・スタディーズ（音研究）は現在では視覚優位のメディア文化論に対するアンチテーゼ[^visualmedia]や、音楽学に収まりきらない、音が関わる文化全般に対するカルチュラル・スタディーズや文化人類学的アプローチによる研究といった側面を持つものの、スターンが前掲書で行った音響再生産文化（Sound Reproduction Technology）としてのフォノグラフやレコードに関わる文化史の再考を「わざと思索的に語った歴史」「歴史をある種の実験室として用いている。それは、音、技術、文化に関して新しい問いを提示することを学ぶため」(ibid,p44)と表現していることが大久保の「移行期にあるメディア理論を再構築するための『実験室』『驚異の部屋』としてメディア考古学的視点が機能しているのだ」[@Okubo2021,p295]という表現と重なることからわかるように、明らかなメディア考古学的アプローチと言える。
-
-[^visualmedia]: もっとも、音文化の研究において視覚優位なメディア文化観に対する聴覚の重要性だけを強調することは、結果的に不要な二項対立や聴覚の神秘化を引き起こしかねないものとして「視聴覚連\UTF{79B1}」とスターンが批判しているもの[@Sterne2016,p27〜34]である。
-
-そして2つ目、コンピューターに関しては、コンピューター自体が「ニューメディア」と表現されることがあるために考古学というアプローチと一見遠い分野に見えそうな一方、計算機に関わる技術自体が驚異的な速度で、様々な隣接領域を巻き込みながら成長している分野である以上、その過去を忘却する速度や歴史的記述の多面性という意味ではコンピューター史以上にメディア考古学的実践が似合う領域もない。それゆえ、この分野では歴史的記述の長さそのものは短くとも、積み上げられてしまった技術要素を研究者自ら解体することによって、透明な背景となっている歴史や文化観を析出させるような性質が強い。古いものではフリードリヒ・キットラーのインテルCPUに搭載されたプロテクトモード批判[@Kittler1998]のような論考が挙げられる。またこうした研究はソフトウェア研究（Software Studies）と呼ばれる分野においてウエンディ・フイ・キョン・チュンが1950年代の最初機コンピューターにおけるプログラミングからソフトウェアに内在するイデオロギーについて検討したように[@Chun2001]、またアレクサンダー・ギャロウェイがTCP/IPのような基礎的プロトコルの成立過程などから新しい形の管理/制御（Control）の権力構造を議論したように[@Galloway2017]、さらに、ソフトウェアやプログラムに完結しきらない、ハードウェアとの連関を考慮するプラットフォーム研究(Platform Studies)におけるイアン・ボゴストとニック・モントフォートのアタリ製ゲーム機が生み出す映像の研究[@Bogost2009]のように、コンピューターというメディア装置の研究においてメディア考古学的省察は至る所で行われている。またこうしたソフトウェア・スタディーズやプラットフォーム・スタディーズに共通する態度としては、研究者自らがプログラミングを行うことで、高度に専門化されているコンピューティング技術やそれに関わる産業構造の批評を表層的な知識でなく実践的に行う、ブラックボックスを開く態度という特徴がある。このことはソースコードそのものを批評的に読み解くクリティカル・コード・スタディーズという研究を行うマーク・C・マリノによるキットラーがソフトウェア研究の過程で残したソースコードの検討[@Marino2001]や、キットラーの研究を行う梅田拓也による、キットラーのアナログシンセサイザー制作経験を彼のプロテクト・モード論考の背景として検討したもの[@Umeda2021]などに見ることができる。
-
-本研究で特に着目するのは（第3章で詳しく検討するが）アラン・ケイとアデル・ゴールドバーグが提示したメタメディアとしてのコンピューターに対する歴史的位置づけと評価である。レフ・マノヴィッチは「ニューメディアの言語」[@Manovich2001]において映画との比較という、これもある意味での考古学的検証においてコンピューターのメディア固有性について検討したが、続く「Software Takes Command」ではコンピューターが新しいメディウム自体を自分自身で生み出せるメタメディアであることにその特徴をより強調し、その原点としてケイとゴールドバーグのDynabookという装置をおいた[@Manovich2013]。一方で、コロラド大学ボルダー校においてMedia Archaeology Labを主宰するロリ・エマーソンは具体詩（コンクリート・ポエトリー）とコンピューターを用いた視覚表現を行うアーティストの歴史的接点として、ケイとゴールドバーグのメタメディアとしてのコンピューターの思想を歴史的原点に位置付けるが、それはマノヴィッチと対照的に、現代のパーソナルコンピューティング環境がメタメディアの不完全な形で社会実装であり、アクセス不可能な装置となってしまった失敗の歴史として位置付けている[@Emerson2014]。本研究はエマーソンの立場に近い態度で、音楽ソフトウェアという異なる領域からやはりDynabookのようなメタメディアとしてのコンピューターの思想を検討することになるが、この立場におけるメディア考古学としてのコンピューター史は、映像や音響メディア史において歴史に記述されることの少なかったメディア装置を掘り返すこととは異なり、ケイとゴールドバーグのようにある種の正当な歴史においても原点として位置付けられている活動を、むしろ失敗した試みとして書き換える試みである。これは「歴史-理論」の軸でいえば既存の歴史に置かれている要素をあえて読み替える「理論」側に寄った位置づけであり、より厄介で注意を要するものだが、本研究における音楽プログラミング言語の制作の一体どこがメディア考古学的なのかという質問への回答は、エマーソンと同じく**歴史を辿ることで現代のコンピューター環境を、万能メディア装置のなり損ないと位置付ける**ことにあると言えるだろう。
-
-3つ目にインフラストラクチャという視点におけるメディア考古学的アプローチという立場だ。ここで筆者が言うインフラストラクチャとは主にISOやANSI、JISで定義されるような標準規格（Standard）やフォーマットのことを意味しており、補集合的な補足をすれば、装置でもなく、アルゴリズムでもなく、コンピュータープログラムでもないが社会や文化に大きな影響を与えているもの、という表現ができるだろう。このインフラストラクチャへの注目の大きな背景としては、科学技術社会論における研究対象が、社会に大きくインパクトを与えた革新的研究（イノベーション）ではなく、すでに社会に浸透してしまったテクノロジーに注目するという反動を起こしたことが挙げられる。ふだん不可視のインフラストラクチャに着目することで知の伝播や政治的権力関係のかたちを明らかにするというアプローチを、ボウカーは「インフラ的転倒(Infrastructural Inversion)」[^inversion][@Star2001,p34]と呼んだが、このインフラの分析においてその成立過程の記述のような通時的分析が多く含まれればそれはメディア考古学的アプローチと多く共通するところがある。これは既に挙げたギャロウェイのプロトコル概念の分析も含まれるし、スターンが「聞こえくる過去」の後に「MP3」で提示したフォーマット理論[@Sterne2012]の概念と大きく共通する。またボウカーはインフラ的転倒の代表例としてベッカーの「アート・ワールド」[@Becker2019]のような、芸術を、それを支える美術館や経済システム、特定の集団の方に着目することで、「アート作品を生み出す社会分業こそが、それに固有の作品を生産する」(ibid、p423訳者解説)という視点の転換を例に挙げているが、これは音楽という領域で検討すれば、スモールの「ミュージッキング」[@Small2009]のように、ある文化を構成する社会的集団を、たとえば音楽であれば作曲家や演奏家、聴衆だけではなくコンサートのスタッフや楽器製作者も含めることでよりその権力関係や文化のあるべき姿の議論の焦点を合わせやすくするアプローチとも捉えられる。実際スターンはスモールの議論を延長し、「音楽産業など存在しない」というエッセイで、音楽ソフトウェアの開発者が音楽文化を構成する一員として捉えられることが少ないことの不自然さを指摘している[@Sterne2017]。本研究においても、Computer Music Languageという、ある種独立して捉えられてきたソフトウェア群の歴史を、コンピューターを用いている音楽の中におけるソフトウェアというより広い枠組みのなかで編み直すことを目標としており、かつそうした音楽ソフトウェアやプログラミング言語は、それらを用いて作られた音楽だけを事後的に分析する上では不可視なインフラストラクチャと言える点で、これらの研究と問題意識を共有している。
-
-[^inversion]:「インフラ的転倒」という訳は[@Fukushima2017]に倣っている。
-
----
-
-# ブラックボックス
-
-ブラックボックスとはそもそもサイバネティクスの中でAshbyが挙げたとされる概念である。
-
-## ブラックボックスの4分類
-
-<!-- 1. ????：起きている現象が・・・・何だ？ -->
-1. 知識的：技術に対する知識の欠如
-1. 身体機能的：起きている現象が人間の生理的/認知的限界を超えている
-1. 言語的：何が起きているかはわかっているが、その現象を言語化できない
-1. 社会的：契約や法律によって技術の内部を覗き見ることが不可能である
-
-### 理解不可能性：知識的ブラックボックス
-
-例えばAppleの最新のMacbookProに入っているCPUのことを考える。我々は普段CPUがどう動いているかについてわからないままにCPUを使うことができてしまっている。
-わからない最もシンプルな理由は、CPUとは何かについて勉強してないので、それがどういうものかわからない、ということである。このカテゴリで重要なのは”学習すれば解決できる”という話である。
-この例えを使っている例としてはPrikkaとHerzのサーキットベンディングをメディア考古学的実践として捉える論考がある。彼らは次のような図としてアマチュアが中身の動作原理を理解しないまま、回路をつなぎ変えることで別の目的に（例えば、幼児向けおもちゃをノイズ楽器へと）再利用するモデルを示している。彼らがNon-expertという用語を使っていることからも、ここでの意図は改造者に電子回路の詳しい知識がないことに重きが置かれていることがわかる。
-
-
-### 知覚不可能性：身体機能的ブラックボックス
-
-しかし、私はCPUの基本的な仕組みや構成方法を知っているが、CPUが実際に動いているところを眺めたところで、いまCPUのこの機能が使われているのだということを知覚することは不可能だ。仮に自分でトランジスタを一つ一つはんだ付けしていってCPUを自作したとしても、それが正しく動いている”らしい”と判断できるのは、結局のところ入力に対して期待した出力が出てくることで確かめている＝ブラックボックスとしての利用であることに変わりはない。
-もっと単純な例で、１つのトランジスタが動く場合を考える。トランジスタがゲート-エミッタ間を流れる電流に伴ってコレクタ-エミッタ間を流れる電流を増幅させる作用があることを私たちは勉強で知っているし、不純物の混入で余った/足りなくなった電子が電圧によって移動して～というミクロスケールでの動作の概念についても理解している。しかし私たちは実際に電子が移動している様をこの目で確かめたわけではない。結局これも、入力に伴って出力が変化した、という入出力の対応をもって確かめているに過ぎない。
-
-これは突き詰めれば人間の身体機能が限界にある、といって良いだろう。我々は電子が移動する様を直に見ることはできないし、3GHzで変化するHIGH/LOWの電圧変化をリアルタイムのスピードで知覚することはひとまずできない。
-
-ここで、1.の学習も人間の身体機能の一部なのでまとめても良いのではないかという考えもあるだろう。しかし、電子が移動する様を眺めるには何か（例えばオーグメンテッドヒューマン的に視力を改造するSF的処置が未来に可能になったとして）、外在的な要因で身体機能を強化することでなら可能になるだろうが、人一人が自らの力だけでそこまでの身体的変化を起こすことはまず不可能だろう。まあ、学習のための本とかだって立派なテクノロジーであって外部的要因でしょ、ということもできるのだが、ひとまずCPUの例では直感的に別種の要因であると言えそうなのでこのままにしておこう。
-
-### 翻訳不可能性：言語的ブラックボックス
-
-これは少しCPUの例では説明の仕方を変えよう。言語化不可能なことによるブラックボックス性といった時に筆者が想定しているのは、主に機械学習のモデルが下す判断の根拠を説明するのが不可能である、といった問題である。
-与えられた画像がイヌかそうでないかを判断するプログラムがあったとしよう。人間が画像認識のアルゴリズムを組み合わせてモデルを構築した場合、プログラムのソースコードにおける関数や変数の名前は人間が解釈可能なものとして残っている。そのため、何かイヌじゃない画像を入れたのに結果がイヌと判断されてこれはおかしい、となった時に、少なくともどの時点での計算での結果がおかしいかがわかり、構築したモデルが正確でない要因をある程度判断することができる。
-これが、学習ベースの推論の場合は、モデル自体は大量の並列化された非線形関数とそれ同士の入出力重みづけが並んでいるだけで、学習に伴ってその重みづけのパラメーターが少しづつ変化していくだけだ。イヌかどうかを99%近くの確率で判断できたとしても、中身を開けたとしても”なぜ”イヌと判断できるのかの理由はわからない。まぁ実際にはCNNのような二次元の重み付けをつけるようなモデルでは、最終的に重みづけの分布も二次元になるのでなんとなく、この層ではこういう特徴を抽出しているっぽい、とかいう解釈らしいこともできるし、機械学習の判断として実用的に（例えば社会的信用スコアをAIで出す時に根拠が出せないのは結構困るので）モデルの説明をするような研究も進んでいる。 https://tjo.hatenablog.com/entry/2019/12/19/190000
-もちろん、別に機械学習モデルでなくても、例えば我々の目や脳が何かを見た時にあれをイヌだとかイヌじゃないとか判断していたとして、脳の電気信号をいくら計測したところで”なぜ”イヌかがわかるわけじゃないので、機械学習の方が劣っているとかそういう話をしたいのではここではない。そもそも前掲の記事でも紹介されているように説明する必要性がないという議論もあるhttps://arxiv.org/abs/1811.10154　。
-重要なのは1とも2とも違って、人間が頑張って学習すれば剥がれるブラックボックスでもないし、人間の身体機能をいかに強化したところで解決する問題でもないという意味で種類が違う、ということである。
-
-
-### アクセス不可能性：社会的ブラックボックス
-
-さて、1,2のCPUの例えに戻る。私はCPUの仕組みを勉強していて動作原理をある程度理解しているが、最新のMacbookProに搭載されているCPUの構造を知ることはできない。なぜなら最新のMBPに搭載されているM1チップというAppleが独自に設計したチップの仕様はオフィシャルには公開されていないので知ることができない、ということである。
-こうしたことは大概のプロプライエタリなソフトウェアでも同じことがいえ、ブラックボックスの入出力の対応を確かめる＝リバースエンジニアリングによってある程度内部の仕組みを知ることができる可能性はある。しかし、場合によってはエンドユーザー利用規約でリバースエンジニアリングが禁止されており、中身を知ろうとしたことがバレれば訴えられる……こともあるかもしれない。
-1~3のブラックボックスと明らかに異なるのは、誰かが意図的にこのブラックボックスを作っていることだ。それは経済的、政治的な都合などによって生み出され、社会的に存在する権力構造を利用して存在し続けている。
-なので、コンピューターを自由な装置として利用するべきであるという方向性での、メガプラットフォーム批判に使われる材料になる。iPhoneという小さなコンピューターを、OSレベルでカスタマイズすることはできず、Appleの公証を受けたアプリケーションしかインストールすることができない、とかに対して。
-
-## ブラックボックスの混用
-
-さて、例えばこの4種類のブラックボックスが混ざって使われている例を少し見てみる。
-例えば緒方の「コンヴィヴィアル・テクノロジー」（2021）の序章には以下のような文が並ぶ。
-
-
-> ～わたしたちはもはや、自分一人でスマホを作ることはできないし、SNSのタイムラインがどのようなアルゴリズムで表示されているのかを理解することもできない。あるテクノロジーのメカニズムやアルゴリズムがブラックボックス化することは、人々をブラックボックスを作る側と使う側、管理する側とされる側に知らず知らずのうちに分断してしまう。ブラックボックス化された道具がますます便利になり、不自由を感じなくなればなるほど、ここをもっとこうしたいとか、もっと別のこんなものがあったらいいのにといった創造的な発想が生まれなくなってしまい、道具を自分なりに改良したり、新しい道具を自らつくりだそうという主体性がだんだんと奪われていくのである。(34p)
-
-> ～行き過ぎた専門化は化学をブラックボックス化し、知識への盲信（または不信）を招く、そうしてわたしたちは、自ら世界と関わり、考え、判断し、意思決定する能力を徐々に失っていくのである。(55p)
-
-ひとつ目の文章は1:学習と4:社会的の2つの要素で構成されているように思えるが、ふたつ目の文章は1に重きが置かれているように思える。自分一人でスマホを作ることができないのは、やろうと思えばできる事だが自分一人でやろうとすると、膨大な量の勉強が必要なことに加えて、作るのに必要な道具や設備の必要性など、コストパフォーマンス的な面からも現実的でなくなるからだ。だが、実際には作れなくはない。実際、肥大化し過ぎた科学の知識体系を自分の手で可能な限りゼロから作る事で明らかにする試みとしてはトマス・トウェイツの「トースター・プロジェクト」のような例がある。
-だが一方で、SNSのタイムラインが表示されるアルゴリズムを我々が知ることができないのはその技術を理解するのに必要な知識量だけの問題ではなかろう。めちゃくちゃプログラミングをやっているFacebook社のエンジニアもTwitterのタイムラインが表示されるまでの仕組みを完全に知ることはできない。
-
-
-
-
-インビジブルコンピューターとは、認知言語学てきな思想に基づくインターフェースを改善するための思想だったと言える。
-
-そこで重視されてきた（と思われてきた）のは身体感覚と言語機能の接続であり、適切な概念モデルを元にシグニファイア（シニフィアン）を作ることが良いインターフェースデザインの方法だったと言える。
-
-しかし一方でこれらの思想の中で軽視されてきたものとして、ノーマンはインフラストラクチャの重要性を指摘していたことを思い出すべきだ。
-
-すなわちある集団に対してのインターフェースデザインをするためには、その集団で共有されている概念モデルを（例えばエスノグラフィなどによって）同定し、
-
diff --git a/chapter3.md b/chapter3.md
index 481119e..e4122ff 100644
--- a/chapter3.md
+++ b/chapter3.md
@@ -1,8 +1,18 @@
+---
+title: 第3章 - メタメディアとしてのコンピューター
+draft: true
+---
+
 <!-- なぜ音楽プログラミング言語を作るか、研究するか -->
-\epigraph{「まるでサーカスだ」、「芝居じみてる」、「映画じゃあるまいし」などといった、昔ながらの表現、自然主義的な非難の言葉は、もはや問題ではない。シミュレーションの時代には、\emph{現実の衛星化}、すなわち、昔の現実をいろどっていたさまざまな幻覚とは無関係の、決定不能な現実軌道に乗せることが要求される。}{『\citefield{Baudrillard1992}{title}』\\ \citep[p177]{Baudrillard1992}}
+<!-- \epigraph{「まるでサーカスだ」、「芝居じみてる」、「映画じゃあるまいし」などといった、昔ながらの表現、自然主義的な非難の言葉は、もはや問題ではない。シミュレーションの時代には、\emph{現実の衛星化}、すなわち、昔の現実をいろどっていたさまざまな幻覚とは無関係の、決定不能な現実軌道に乗せることが要求される。}{『\citefield{Baudrillard1992}{title}』\\ \citep[p177]{Baudrillard1992}} -->
+
+> 「まるでサーカスだ」、「芝居じみてる」、「映画じゃあるまいし」などといった、昔ながらの表現、自然主義的な非難の言葉は、もはや問題ではない。シミュレーションの時代には、*現実の衛星化*、すなわち、昔の現実をいろどっていたさまざまな幻覚とは無関係の、決定不能な現実軌道に乗せることが要求される。[@Baudrillard1992,p177]
 
-\epigraph{鉄道をコントロールするものが、周囲の領地をコントロールする。\\こうしたことは、我々にとって、忘れようもないことがらではある。\\しかし、今日、我々が必要としているのは破産宣告を受けた鉄道などではなく、衛星ネットワークである。}{『\citefield{Haraway2017}{title}』\\ \citep[p490注]{Haraway2017}}
+<!-- \epigraph{鉄道をコントロールするものが、周囲の領地をコントロールする。\\こうしたことは、我々にとって、忘れようもないことがらではある。\\しかし、今日、我々が必要としているのは破産宣告を受けた鉄道などではなく、衛星ネットワークである。}{『\citefield{Haraway2017}{title}』\\ \citep[p490注]{Haraway2017}} -->
 
+> 鉄道をコントロールするものが、周囲の領地をコントロールする。
+> こうしたことは、我々にとって、忘れようもないことがらではある。
+> しかし、今日、我々が必要としているのは破産宣告を受けた鉄道などではなく、衛星ネットワークである。[@Haraway2017,p490注]
 # なぜ音楽のためのプログラミング言語を研究するのか
 
 本章では、メディア装置としてのコンピューターの思想と、音楽家のような芸術実践のあり方の関係性の歴史を記述する。序章で触れたように、本研究で音楽のための道具作りの中でPLfMという事例に着目するのは、パーソナルコンピューティングの初期の構想の中ではユーザーのプログラミングによる機能拡張がセットになっていたからだ。しかし今日、コンピューターを用いた音楽を作るための道具を使うにあたり、プログラミングという行為は徐々に普及しつつはあるものの、未だメインストリームからは程遠い状況にある。
@@ -16,7 +26,7 @@
 
 つまり現代の音楽制作ソフトウェアには1.のパラメーター化、カスタマイズはできても多くは2.プログラムの機能そのものを変更できないということになる。しかし繰り返しになるが、そもそもの自らの手で機能を拡張できる道具としてのコンピューターの思想で重視されていたのは2.のプログラムそのものを変更できることだった。本研究ではエマーソンによるメディアとしての計算機のメディア考古学的検証[@Emerson2014]を参照しつつ、メディア装置としてのコンピューターの原点である、ゼロックス社PARCで開発されたDynabookの思想を、**不完全な形で定着したもの**という批判的な形で位置付ける。
 
-![メタメディアとしてのコンピューターの歴史の見取り図。](img/computermedia_history.pdf){#fig:computerhistory width=100%}
+![メタメディアとしてのコンピューターの歴史の見取り図。](../img/computermedia_history.png){#fig:computerhistory width=100%}
 
 第2章と同様、1960年代から2020年代までの歴史の見取り図を、今度はメディアとしてのコンピューターの思想という視点で[@fig:computerhistory]に示した。本章で歴史区分のガイドとなるのは、ユビキタス・コンピューティングの概念を提唱したマーク・ワイザーがその概念の説明に用いた、利用者あたりに使えるコンピューターの数（コンピュータ1台あたりのユーザー数）の時代に伴う変化である。低価格化と高性能化に伴って、1人あたりが利用する計算機の数は時代とともに増えていった。1960年代には研究所やオフィスに置かれた巨大な装置を複数のユーザーがシェアして用い[^timeshare]、1980年代以降は家電のように個人が計算機を自宅で手軽に利用し、そして1990年代から今日に至ってはスマートフォンも含めて、私たちは日常的に計算機を複数台利用するようになっている。
 
@@ -34,7 +44,7 @@
 
 [^parc]: Palo Alto Research Center–ゼロックス社を母体とする、シリコンバレーに存在する研究所。
 
-なぜなら[@sec:chapter4]で詳しく見るように、コンピューターを単に計算装置として用いるのではなく、音楽の生成のために用いる試みは電子計算機のごく初期である1951年にはすでに、イギリスのBINAC、アメリカのUNIVAC I、オーストラリアのCSIRAC（CSIR Mk-I）と、世界各地で行われていたからである。もっとも、これら最初期の試みは、メディア処理のためのシステムを作ったのではなく、デバッグ目的のシステムの流用で可能な範囲の音楽生成の試みであった[@Tanaka2017]。
+なぜなら[第4章](../chapter4_rendered)で詳しく見るように、コンピューターを単に計算装置として用いるのではなく、音楽の生成のために用いる試みは電子計算機のごく初期である1951年にはすでに、イギリスのBINAC、アメリカのUNIVAC I、オーストラリアのCSIRAC（CSIR Mk-I）と、世界各地で行われていたからである。もっとも、これら最初期の試みは、メディア処理のためのシステムを作ったのではなく、デバッグ目的のシステムの流用で可能な範囲の音楽生成の試みであった[@Tanaka2017]。
 
 そのため、コンピューターをメディア装置として本格的に用いようとした思想の原点と呼ぶにはやや弱い試みである。では、ハードウェアも含めたシステムであり、あらかじめメディア装置として使うことを目的としたシステムという視点ならどうか。GUIの最初期の例である、ペン型のポインティングデバイスをディスプレイと組み合わせて使用できる、アイバン・サザーランドのSketchPad[@Sutherland1963]はこの意味合いでは最も有名なシステムだ。しかしハードウェアも込みのシステムという意味だとしても、やはり音楽分野においてより早い時期である1957年に、マックス・マシューズらがMUSICという音声合成のためのプログラミング環境を既に完成させている。MUSIC（I）自体はIBM 704という汎用のコンピューター上で動作するシステムではあったが、専用のDACと組み合わせてはじめて成立するシステムだったことを加味すれば、コンピューターをメディア装置として用いる例としてはSketchPadなどと同様に記述されるべき事例だと言える。
 
@@ -52,7 +62,7 @@ Dynabookで提示されたメタメディア概念の中核には、あらゆる
 
 > マクルーハンはその『グーテンベルグの銀河系』のなかで、しばしば新しいメディアは、当初は古いメディアの内容を取り入れる、と指摘し、聖書の写本を例に挙げている。わたしは、FLEXマシン〔ケイらがDynabookよりも前に開発していたシステム〕のような、デスクトップ・パーソナル・コンピュータは、企業や公的機関で使われるメインフレームの時分割利用のあとにくる、『グーテンベルグ聖書』なのだということに気づいた。[@Kay1992,p18]
 
-世界中の地点同士の接続により、あらゆるイベントが同時刻的に共有される地球村（Global Village）の概念に代表されるマクルーハンの思想が、今日のインターネットで繋がれたメディア環境を鋭く予見していたことは言うまでもない。しかし実のところその予見は、ムーアの法則が未来予測という形をとって社会への期待を浸透させていた状況（[@sec:expectation]）とよく似て、ケイのようにメディアとしてのコンピューター技術を作り上げてきた研究者たちがマクルーハンの思想に直接的に影響を受けることで実現されてきたという因果逆転の側面も少なくない。
+世界中の地点同士の接続により、あらゆるイベントが同時刻的に共有される地球村（Global Village）の概念に代表されるマクルーハンの思想が、今日のインターネットで繋がれたメディア環境を鋭く予見していたことは言うまでもない。しかし実のところその予見は、ムーアの法則が未来予測という形をとって社会への期待を浸透させていた状況（[第2章](../chapter2_rendered#expectation)）とよく似て、ケイのようにメディアとしてのコンピューター技術を作り上げてきた研究者たちがマクルーハンの思想に直接的に影響を受けることで実現されてきたという因果逆転の側面も少なくない。
 
 また同時に、この考え方はデザイン・サイエンスの運動に影響を与えたハーバート・サイモンの『システムの科学』における、観察ではなく、モデルを構築して、シミュレーションを行うことによって世界を理解しようというサイバネティクス的思想とも共鳴しているように読める。しかし一方で、ケイはマクルーハンを経由することで当時のサイバネティクスとコンピューター科学の関わりの主戦場であった人工知能研究や、例えば今日におけるデジタルツインの概念のように、現実世界に存在する生物や世界そのものを計算機上に完全再現することともまた違う方向を歩んだ。
 
@@ -82,7 +92,7 @@ Dynabookで提示されたメタメディア概念の中核には、あらゆる
 
 Apple IIからMacintoshで起きた変化とは、一般にコマンドユーザーインターフェース（CUI）からマウスなどを利用するグラフィカルユーザーインターフェース（GUI）への変化が挙げられ、これによりユーザーはプログラミングという作業を意識することなくコンピューターを利用できるようになったと語られる。一方でエマーソンは、それだけでなく拡張スロットの有無こそがコンピューティングの歴史を方向付ける重要なものだったと主張する。Apple IIに搭載されていた8つの拡張スロットはディスプレイやメモリ、ハードディスクを始めとした様々な機器をユーザーが自由に付け加えることのできる機能だった。しかしこうした拡張機能はオフィス用途のようなタスクの効率化のためだけにコンピューターを用いたい人には不要なものであったし、メーカーごとに異なる拡張スロットの仕様を規格化（Standardization）し統一する、もしくは無くしてしまうことが、民生機器（≒家電）としてのコンピューターの価格を下げるための重要な手段でもあり、ユーザーの混乱を避けることにもつながる。そうして初代Macintoshの拡張ポートは、フロッピーディスク、プリンタ、モデム、マウスの4つだけに限定されることになり、メインメモリの拡張は高額なオプションとする代わりに当時としては、また前身の高機能な代わりに高価格で商業的には成功しなかったLisaという機種と比べて大幅な低価格化に成功した。プログラミングの作業の隠蔽というソフトウェアのレイヤー、拡張ポートの制限というハードウェアのレイヤーにおける2つの隠蔽を行うことによって、Macintoshはその内部を覗くことのできない不可視な箱としてのパーソナルコンピューターの姿を実現したのである[^macintosh]。
 
-[^macintosh]: ただ、この後スティーブ・ジョブズは一度Apple社を去ることになり、その後1987年に発売されたMacintosh IIではディスプレイと本体が分かれ、新たにNuBusという汎用拡張スロットが備えられるようになる。[@sec:plfm1990]で触れるように、現在のProToolsの前身である音声編集ソフトウェアSoundToolsは、このNuBusスロット向けの拡張DSPボードであるSound Acceleratorと組み合わせることではじめてリアルタイム動作を実現した。
+[^macintosh]: ただ、この後スティーブ・ジョブズは一度Apple社を去ることになり、その後1987年に発売されたMacintosh IIではディスプレイと本体が分かれ、新たにNuBusという汎用拡張スロットが備えられるようになる。[第4章](../chapter4_rendered#plfm1990)で触れるように、現在のProToolsの前身である音声編集ソフトウェアSoundToolsは、このNuBusスロット向けの拡張DSPボードであるSound Acceleratorと組み合わせることではじめてリアルタイム動作を実現した。
 
 スティーブ・ジョブスがPARCでのDynabookのデモに強く触発されLisaやMacintoshの設計を行なったことはよく知られている。またケイ自身も、PARCの経営母体であるゼロックス社が、デモを除いた対外的な成果発表を許可しなかったり、ゼロックス社自身からのパーソナルコンピューターの発売に経営陣が踏み切らない中で、1984年にアップル社へ移籍している。ところが結果としてパーソナル・コンピューターの普及を決定づけたMacintoshの存在の中からは、ケイが中心においていたプログラミングという作業がユーザーから遠ざけられたものになってしまったのである。
 
@@ -272,7 +282,7 @@ MIDIは確かに音楽のデジタル化の過程で大きな功績を残して
 
 久保田も同文献中でノーマンが情報アプライアンスの一例としてMIDIが取り上げられていることに触れつつも「ノーマンが考える未来は、音楽制作の現場において、すでに過去のものになりつつある」[前掲,p18脚注]と言及するように、MIDIのような既に存在する音楽文化を埋め込んだ規格ではなく、より抽象化された数値の集まりとしての音楽表現がパーソナルコンピューティングによって主流になる可能性へ期待を示していた。しかし今日の状況を見る限り、MIDIはMIDI2.0のようなアップデートされたプロトコル[@AMEI2020]の登場により、表現できるデータの解像度などが上がったとは言えど、依然として十二音の文化様式の上に立ったプロトコルの基本形式は変わらず、音楽制作や演奏のためのハードウェア、ソフトウェアにおいて中心的役割を果たしている。
 
-さらに言えば、オルタナティブが提唱されなかったわけではない。例えば1997年にカリフォルニア大学バークレー校の研究所CNMATにより提唱された、MIDIよりも自由にその意味を設計できる、コンピューターやシンセサイザー同士の相互運用を目指して作られたOpen Sound Control（OSC）というオープンな規格[@Wright1997]がある。OSCは音楽プログラミング環境の中で、とくにコンピューター同士のIPネットワーク間のやりとりに関して重要な役割を果たしたとマグヌッソンが言及する[@Magnusson2019]ように、一定度合い普及はした。しかしながらOSCは、一般的な音楽制作ソフトウェアの中ではせいぜい一部の操作の自動化のためのオプション機能といった位置づけ[^oscdaw]にしかなっておらず、MIDIは「すでに過去のものになりつつある」状態のまま生き延び続けている。また[@sec:saol]で見るように、同時期にはCsoundというPLfMを元にして、MIDIを包括して取り扱えるプロトコルとしてのPLfM（MPEG-Structured Audio）も提案されISO標準規格として制定されたものの、ほとんど普及することは無かった。規格としてOSCは「チャンネル、ノート、オーケストラ、ベロシティのようなモデルを強要せず、音楽的に中立かつより汎用的」[@Wright1998,筆者訳]であり、同様にSAOLもMIDIを包括し完全に置き換え可能なはずが、皮肉なことにノーマン自身が言った「古いやり方がしぶとく残る」状況になっているのだ。ノーマンは以下のように述べ、情報アプライアンスの発展のためにはオープンな標準規格を定義することが重要と主張していた。
+さらに言えば、オルタナティブが提唱されなかったわけではない。例えば1997年にカリフォルニア大学バークレー校の研究所CNMATにより提唱された、MIDIよりも自由にその意味を設計できる、コンピューターやシンセサイザー同士の相互運用を目指して作られたOpen Sound Control（OSC）というオープンな規格[@Wright1997]がある。OSCは音楽プログラミング環境の中で、とくにコンピューター同士のIPネットワーク間のやりとりに関して重要な役割を果たしたとマグヌッソンが言及する[@Magnusson2019]ように、一定度合い普及はした。しかしながらOSCは、一般的な音楽制作ソフトウェアの中ではせいぜい一部の操作の自動化のためのオプション機能といった位置づけ[^oscdaw]にしかなっておらず、MIDIは「すでに過去のものになりつつある」状態のまま生き延び続けている。また[第4章](../chapter4_rendered#saol)で見るように、同時期にはCsoundというPLfMを元にして、MIDIを包括して取り扱えるプロトコルとしてのPLfM（MPEG-Structured Audio）も提案されISO標準規格として制定されたものの、ほとんど普及することは無かった。規格としてOSCは「チャンネル、ノート、オーケストラ、ベロシティのようなモデルを強要せず、音楽的に中立かつより汎用的」[@Wright1998,筆者訳]であり、同様にSAOLもMIDIを包括し完全に置き換え可能なはずが、皮肉なことにノーマン自身が言った「古いやり方がしぶとく残る」状況になっているのだ。ノーマンは以下のように述べ、情報アプライアンスの発展のためにはオープンな標準規格を定義することが重要と主張していた。
 
 [^oscdaw]: 例えばReaperではパラメータの制御にOSCを利用できる。
 
@@ -341,7 +351,7 @@ MIDIは確かに音楽のデジタル化の過程で大きな功績を残して
 
 電子機器は消費経済の中で、定期的な刷新と購入を促進するように、物理的耐久年数とは関係なく互換性がなくなっていくよう更新されていく。例えばコネクタの仕様や、OSのサポート、特定のサーバーに依存するIoT機器などを考えれば分かりやすい。ハーツとパリッカが分析したように[^hertz]、サーキットベンディングは予め想定されていない、おかしな音の鳴る楽器に変えてしまう使い方をするために、こうした**計画的廃用化（Planned Obsolescence）**に逆らう側面を持っている。
 
-[^hertz]: [@Hertz2012]。[@sec:mediaarch]も参照。
+[^hertz]: [@Hertz2012]。[第2章](../chapter2#mediaarch)も参照。
 
 グリッチを美学的な面から考察したキャレブ・ケリーは、彼がクラックド・メディアと呼ぶグリッチを含めた試みを、ハーツとパリッカの分析同様、日常的実践に基づく商品の単純な消費ではない異なる形態の利用（流用：exploitation）と捉えている。
 
diff --git a/chapter3_memo.md b/chapter3_memo.md
deleted file mode 100644
index 83198f5..0000000
--- a/chapter3_memo.md
+++ /dev/null
@@ -1,219 +0,0 @@
-## 無限のバージョニングとなめらかな忘却
-
-メディア編集ソフトウェア環境において、ユーザーが自由にプログラムを作ることができない理由を経済的な観点から省みることはソフトウェアを研究するという行為そのものの根幹にも関わる。Manovichは2013年の「Software Takes Command[^softwaretakes]」で、誰もがソフトウェアを使って表現を行っているにもかかわらず、ほとんどの人がその学術的な由来や文脈を知らないー例えば映画を作る人でLumiere兄弟を知らない人はほとんどいないのに対して、コンピューターを使って表現をしている人のうち何人がAlan Kayを知っているだろうかーという、メディア研究におけるソフトウェアに対する無関心に対する疑問を呈し、その大きな理由は経済的なものではないかと考察した。画像編集アプリケーションやCADアプリケーション、音楽制作アプリケーションなどのソフトウェアが、映画や、（同じくソフトウェアである）ゲームタイトルと違って、数十年前の作品がリイシューされて販売されることなどほとんどない。というよりも、例えば2000年のMicrosoft Wordと2021年のWordとを並べて、20年前のバージョンを好んで取り出してきて使ったり、Microsoftが20年前のバージョンをリイシューして販売したり、あるいはそれらの違いについて議論、批評する人は音楽や映画と違いそうそういないし、そもそも動作させることすら難しい。音楽プログラミング言語でも同様の例はたくさんある。Cycling'74 Maxのバージョン4と5の間でファイル保存の形式が大きく変わりインターフェースの見た目も変化した。これは、主にグラフィックの処理にこのバージョンからJUCEというC++言語向けフレームワークを導入したことが大きな理由であり、機能としても実装としてもバージョン4からバージョン5の間には大きな開きがある。何より、こうした2つのバージョンのソフトウェアは（単に機能としても、そしておそらくソフトウェアの実装的な面から見ても）もはや別物と思える程に機能が増えているけれども、表面上は同じソフトウェアだという連続性を持っている。
-
-バージョン付けの規則としてプログラマの中で最もよく使われているSemantic Versioningという規則では、`v2.14.3`というような3つの数字の並びによってソフトウェアのバージョンを表現する。この時、下位の数字から順に、`3`はバグ修正などが行われたときに増加するパッチアップデート、`14`は前方互換性がなくなるー簡単にいえば小さくとも何かしらの新しい機能追加を行うマイナーアップデート、そして`2`は後方互換性の破壊、つまり、昔のバージョンで使えていた機能が使えなくなってしまう変更を行うメジャーアップデートを表す[^semvar]。ソフトウェアの長い積み重ねを3つの数字で表すバージョン番号で最もメジャーな数字はすなわちそのソフトウェアにおける見えない歴史的切断の回数を表している。
-
-[^semvar]: https://semver.org/lang/ja/
-
-このように、ソフトウェアは新しい機能を日々追加されながら、時にメジャーアップデートなどで追加でユーザーから料金を取ったり、華々しく新機能についての宣伝で前バージョンとの差異を強調しながらも、同時に一方で両者は同じソフトウェアであるというアイデンティティを保ち続けており、それによって後から歴史を振り返ったときに文化的な系譜学（cultural genealogy）を編みにくくする。
-
-[^softwaretakes]: 日本語では未訳だが、"ソフトウェアが指揮を執る"と訳されることが多い[@Manovich2017,pxxなど]。元の意味合いとしては、コンピューターソフトウェアがコマンドを受け付ける、ということと、文化の中でソフトウェアが支配的な役割を果たしつつあるという両義性を込めたものと思われる("ソフトウェアが命令を司る"、といった方がニュアンスとしては近いように思える)。
-
----
-
-例えばReaktor[^reaktor]を用いた音楽ソフトウェアを自分で制作し音楽作りに積極的に使っているSquarepusher(トム・ジェンキンソン)は、既存の音楽制作ソフトウェアやそのためのプラグインなどが万年半額セールになっている状況を背景に、音楽制作環境が過度に消費主義的になることに警鐘を鳴らしている。
-
-[^reaktor]: reaktorの解説。Squarepusherは音楽制作にソフトウェアを用いていると度々発言してはいるが実際にどういったソフトウェア環境で制作をしているかの詳細についてはどのインタビューでも触れられておらずはっきりしない。2014年？のインタビュー映像ではPure Data、Max、Reaktorに言及しているが、映像として写されているのはReaktorのみであった。 https://www.youtube.com/watch?v=zEofbwt0zRY&t=534s
-
-
-> 僕が強く異議を唱えることのひとつに、「音楽作りのマーケット化」ってことがあってね。
-> それはどういう意味かというと、今の時代、音楽を作る人びとは『この最新の商品を買わなくちゃ』って風に駆り立てられているわけだよね？それはもちろん、ソフトウェア製造会社、あるいは楽器メーカーによるマーケティング・キャンペーンが拍車をかけているんだけど……特に若いミュージシャンの場合がそうなんだけど、彼らはどういうわけか、新しい音楽を作り出す、今風で……そうだね、そこにファッショナブルなって要素も加わるんだろうけど、そういったトレンディで新しい音楽を作るためには、この最新の楽器、あるいはこの最新のソフトウェアをゲットしなくちゃダメなんだ、そんな風に感じるように仕向けられている[^squarepusherurl]。
-
-[^squarepusherurl]: https://www.ele-king.net/interviews/004425/index-2.php
-
-
-
-
-## Ovalとソフトウェアとしての音楽
-
-
-OvalはCDの読み取りエラーを積極的に音楽に取り入れるような、グリッチと呼ばれる手法を用いる作曲家で、2000年代にovalprocessという自分のためのカスタム音楽制作ソフトウェアを制作し、ソフトウェア自体を音楽作品（さらにそれを超えて、レーベルやエディションに相当するもの）にしてしまうことを試みた。彼のovalprocessに関する論考で興味深いのは、テクノロジーが新しい音楽を生み出すと言った技術決定論的な言説に限らず、規格やフォーマットといった制度論に対して強く自覚的になっている点だ。いくつか引用しよう（いずれも強調は筆者による）。
-
-> オヴァルは、デジタル制作メディアにおける、一つの典型的なワークフローの**スタンダード**を、攻撃的に使用する。
-
-> 〜私の音楽は、改定された「音楽Ver2.0」という、新しい決定的な**スタンダード**を導入しようとしている。
-
-> 音楽制作ソフトには潜在的なリベラル的傾向があるにもかかわらず、私はその「クリエイティヴ」な可能性ではなく、ワークフローの大規模な**規格化**に焦点を当てている。
-
-> 私の個人的アプローチは、**スタンダード**を攻撃的（オフェンシヴ）に使うことに基づいている。デジタル（音楽）メディアを「実験的」に使用するよりも、スタンダードーーファイル・フォーマット、ファイル・トランスファー・プロトコル、圧縮スタンダード、コーデック（データの圧縮／慎重、COmpression／DECompressionの略）、オペレーティング・システムーーの方が、私の作業過程において重要な要素なのである。それは、これらのスタンダードが、何がコンピューターで可能であるかを決定する**土台**であるからだ。
-
-> 音楽制作ワークフローの論議に対する大衆の認識と接し方が変わらなければ、「独自」のソフトウェアを作る利点は疑わしく、何も解決しないだろう。電子音楽制作の根底にある**技術的スタンダード**に関する論議を、徹底的に見直す必要がある。カスタム。ソフトウェアを作ったとしても、それを廃れた概念や、時代遅れの音楽パラダイムに従ってデザインし、使用し続けたのでは、何の解決にもならないのだ。
-
-こうした議論を見ると、Ovalがグリッチのようなアプローチを取っていたのは、ツールを意図的に誤用したり、アマチュアリズム的に「あちこちいじくり回す」[@Cascone2005]ことによって隠された内部構造をあらわにしたり、無目的に聞いたことのないノイズ音を生み出したりすると言った目的でも、コンピューターのメディウム固有性としてマノヴィッチが挙げる、あらゆるタイプのデータを数値として表象する[@Manovich1999,p8]ことを逆手にとって、データを意図的に誤った読み替えをして新しい音楽を作るということに着目していたわけでもない。
-
-むしろ、全てが数値として表象されるときに、見えないところで大企業や標準化団体がその意図を直接的には見えない形で埋め込み、創作者に対して間接的に影響を与えていることへのカウンター行為としての積極的な規格からの逸脱や、オルタナティヴな野良規格の構築という行為だったと見ることができるだろう。
-
-最終的にovalprocessはいくつかのインスタレーション展示を除いて公にリリースされることはなかった(引用)。
-
-
-
-まとめれば、音楽において情報インフラストラクチャを作るということはその時点での音楽を構成する要素の概念モデルを定義し、その概念モデルを境界線としてユーザーとデベロッパーを切断するための仕組みだといえる。
-
-この切断によって、ユーザーは概念モデルより下層の構造の内容について意識する必要がなくなり、認知的な負荷を下げ、よりその人の集中したいタスクに専念できる。問題は、この概念モデルはある一定数以上の人数について共有されてなければ意味をなさないことと、概念モデルを標準規格(例えばMIDI)やプロトコルによって定義するためのコストを誰が払えばよいのかということである。
-
-## iPhone音楽アプリの衰勢：いつか音楽と呼ばれる（はずだった）もの
-
-RjDj
-
-Audible Realities
-
-- なぜうまく行かなかったのだろう？仮説を立てることしかできないが、制作に対するインフラストラクチャ（MIDIなど）に対しては意識的だったが、流通、受容に関するインフラストラクチャに対する意識が希薄だったのではないだろうか。
-	- 徳井のiPhone音楽アプリは機能がシンプルすぎてApp Storeの審査には通らなくなってしまう（メディアアートの輪廻転生）
-
----
-
-ケイの理想としたコンピューター像＝
-
-
-こうした変遷を時系列順に並べ直して改めて考えると、次のようになる。
-
-- 1900年代：自動演奏機械や録音メディアによる作曲や演奏の価値の変動（結果としては作曲者にロイヤリティが支払われるように落ち着く）
-- 1970年代：コンピューターの商業化の過程における労働としてのソフトウェア開発に対する支払いの妥当性の議論（作曲家のロイヤリティを例に挙げる）
-- 2000年代：録音音楽のデジタルデータ化に伴う劣化のない複製、楽器としてのコンピューター
-
-しかし実のところ、この音楽データの（経済的）価値の問題は、音楽とソフトウェアが歴史の中で互いに経済的価値に影響を及ぼしながら形成されてきた問題の二重のエコーのようなものである。もとを辿れば、1度目のエコーとして1970年代にソフトウェアの経済的価値のあり方の議論が、コンピューターのハードウェア構成やアーキテクチャが規格化され、その上で動作するプログラムもプログラミング言語によってハードウェアに依存せずにその挙動を記述できるようになる中で発生しており、さらにその前には、エコーの原音となる議論である、1900年代における音楽の複製技術の浸透と、作曲、録音されたものと経済的価値の振動があった。
-
-まず時代を1976年まで巻き戻そう。この年マイクロソフト社のビル・ゲイツは「ホビイストたちへのオープンレター」という題の文書を公開した。当時マイクロソフト社はその初めての仕事として、MITS社が発売するAltair 8800という最初期の個人向けコンピューターのための、BASICというプログラミング言語の実行プログラム（インタプリタ）を開発した。このプログラムは紙テープに保存され販売されていた。ここでいう個人向けコンピューターとは、ケイが提唱したパーソナルコンピューター概念とは違い、単にマイクロコントローラを利用した、低価格で小型の、個人でも購入可能なレベルのコンピューターという意味合いであり、Altair 8800はこの中でも最初期の製品の一つである。このAltair 8800はApple社を立ち上げたスティーブ・ジョブズとスティーブ・ウォズニアックが所属していたことで知られる、ホームブリュー・コンピューター・クラブ（HCC）というシリコンバレーのパロアルト周辺のコミュニティが立ち上がるきっかけとなった。Altair 8800のためのBASICインタプリタ、Altair BASICはHCCのコミュニティの中などで仲間内で広く使いまわされることになり、彼らはそれを特段問題視していなかった。一方でゲイツは、ソフトウェア開発というプロフェッショナルな労働に対する正当な価値に対する支払いがなされていない、「もっとも直接的に言えば、あなた方がやっていることは窃盗である」とまで批判したのだ。当時MITS社がAltairユーザーやホビイスト向けに発行していた、Computer Notes（通称 Altair newsletter）誌で、MITS社に勤めていたデヴィッド・バネルはゲイツの公開書面よりも1年前にはすでに同様の懸念を表明していた。そこに次のような文面がある。
-
-> このような行い〔Altair BASICのインタプリタを仲間内でコピーして回ったり、再販して回ること〕は〕は、全てのソフトウェアはパブリックドメインの一部になるべきだという主張によって助長されてると思う。
-
-> ここで1つ尋ねよう––音楽家は自身のレコードの売り上げからロイヤリティを徴収する権利はあるだろうか、もしくは作家は自身の本の売り上げからロイヤリティを徴収する権利があるだろうか？**ソフトウェアをコピーする人は、レコードや本をコピーしている人と何か違うのだろうか？**
-
-> Altair BASICは既存のBASICの中でもっとも進んだもので、MITS社の貴重なコストを使って開発されている。このことや、多くの企業がソフトウェアに支払っている金額のことを考えれば、Altair 8K BASICに75ドルという値段は*ほとんど窃盗である*。[@Bunnel1975,2段落目の強調は筆者]
-
-https://www.wired.com/2009/03/march-5-1975-a-whiff-of-homebrew-excites-the-valley/
-
-https://web.archive.org/web/20120323162200/http://startup.nmnaturalhistory.org/gallery/notesViewer.php?ii=75_9&p=2
-
-今日でも、ソフトウェアの権利は主にその機能ではなく著作権上の権利として他のテキストベースの表現と同じ枠組みの中で保護されているように、ソフトウェアの権利とはテクストや他の複製可能なメディウムの権利と同質だと捉えられてきたのである。
-
-しかし1900年代まで歴史をさらに巻き戻すと、レコードの売り上げから録音された曲の作曲者へ金銭的ロイヤリティが発生するべきという考えは、録音複製技術が作られ、さらにその技術が音楽を販売するビジネスとして定着していく中で、その始まりから当然のように認識されていたわけではなかった。
-
-
-
-Smalltalkが多くの後続のプログラミング言語に影響を与えるようになった理由の1つである、オブジェクト指向という考え方はケイの中庸的思想がよく現れている。
-
-## Smalltalkとオブジェクト指向
-
-Smalltalkはプログラミングにおいて明確にオブジェクト指向という考え方を打ち出したが、
-
-
-
-では2000年代以後の音楽のデジタル化とはどんな変化だったのか？と考えれば、
-
-
-ソフトウェアやレコードのように、記述されたものを再生/実行するというのは
-
-
-
-しかし、この自己反映性はユーザーがパラメーターやプリセットを調整できるという意味での弱いカスタマイズ性だけを残したコンピューターにはもはや存在していない。その時、コンピューターのユーザーはその道具を消費する者になる。このユーザーの消費者化、という変化は我々が議論の対象とする領域で置き換えて考えれば、音楽制作ソフトウェアを使う音楽家が経済的な側面から見れば、音楽を生産する者であると同時に、出来上がったソフトウェアやプラグインを消費する者（＝Customer、カスタムする主体）という二重の存在として見える、ということになる。
-
-> 意識やその流れが産業的に均質化されるという彼〔スティグレール〕の考えに反して、経験の共有領域が情動やシンボルからなる微小世界に細分化し断片化されるという考えが対置化できるだろう。アクセスできる計り知れないほどの情報量は、個人的なものであれ、政治的なものであれ、どんなに常軌を逸したものであれ、あらゆるもののために配置され整備されうる。フィルタリングとカスタム化の無限の可能性を通して、個々人は、物理的に近くにいても、互いに無関係でコミュニケーションのない世界に住むことができる。しかしながら、これらの微小世界の大部分は、明らかに異なるコンテンツにもかかわらず、それらの時間的なパターンや分節において単調な同質性を呈する。[@Crary2015,p69~70]
-
-
-# 「ブラックボックス」概念自体の分解と整理
-
-続けて紹介してきたサーキットベンディング、トウェイツのトースター・プロジェクト、UCNVのグリッチアート概念、HandredRabbitsの活動の位置付けの違いを整理するために、ここでこれらに共通するアプローチであった「ブラックボックスを開く」という行為を、より細かい意味合いに分解することから検討してみよう。
-
-そもそも、ブラックボックスという言葉は、中身の内容を知らずとも使えるという意味合いから、科学技術批評における単に自分が知らない高度な技術スタックの集合というような意味合いまである程度日常的に使う語となっているが、その語が指す意味合いには4つの複数の意味合いが包含されており、それらの概念を都合よくまとめているマジックワードといった節もある。
-
-例えば、ラトゥールは科学技術社会論の文脈における「ブラックボックス化」という語の定義を以下のように与えている。
-
-> 科学や技術の成果が、その成功それ自体によって不可視になる過程を指示する過程を指示する科学社会学の表現。機械が効率的に稼働していたり、事実に疑念の余地がない場合、インプットとアウトプットだけに焦点を当てればよく、内部の複雑な機構に着目する必要はない。したがって、逆説的ではあるが、科学や技術は、成功すればするほど、不透明で不鮮明なものになっていく。[@Latour2007,p403]
-
-> **ブラックボックス**という用語は、サイバネティクスの分野において、機器の一部や集合があまりに複雑な場合に常に用いられる。機器や命令の代わりに、入力と出力しか知る必要のない小さな箱を描くのである[@Latour2015]。
-
-しかし、ここでラトゥールがブラックボックスという用語の原点としているサイバネティクスの分野における説明を読むと、この用法はやや拡大解釈である。例えば、サイバネティクスにおいて、外部入力に対して自律的に出力を一定に保つホメオスタットという装置を作ったことで知られるロス・アシュビーは「AN INTRODUCTION TO CYBERNETICS」という書籍で、サイバネティクスにおけるブラックボックス概念を説明している。
-
-> 事実、我々が思う以上に、我々は日常生活の中でブラックボックスと共に働いている。例えば、一見自転車は全てのパーツの連結部分が見えているからブラックボックスではないと思いがちだ。しかし我々は自分自身を欺くものだ。
-> ペダルと車輪を繋ぐ究極的な連結は、金属の粒子同士をつなぎ合わせる分子間力である。これは我々の目には見えないし、自転車に乗ることを学習する子どもは単にペダルに力を込めれば車輪が回るという知識だけで上手になるものだ。
-> （中略）ここで示唆されているのは、ブラックボックスが実在するオブジェクトのように振る舞うというようなことではなく、**実在するオブジェクトの方が実はすべてブラックボックスなのだ**、ということで、我々は実際にブラックボックスたちと共に我々の暮らしを作動させてきたのだということだ。[@Ashby1956,p110、筆者訳、強調は筆者による]
-
-ラトゥールによるブラックボックス化の概念とアシュビーのこの説明の対比は、特にコンピューターの本質がシミュレーションにあるというケイやマノヴィッチの主張を採用するならば重要な問題である。ラトゥールの説明におけるブラックボックスという用語は、科学者のような特定のグループの人間にとっては構築された科学技術の詳細な内容が把握できているが、非科学者にはその内容が覆い隠されていて、科学者の提示した事実を信頼することによって使うことができている、つまり科学者がブラックボックスを構築しそれ以外の人が使用する、といった意味合いが強い。しかしアシュビーのようなサイバネティシャンにとっては、彼らが認識している世界そのものの方が大きなブラックボックスであり、科学者はそうした大きな対象を小さなブラックボックスの単位へと分節化し名前を与えることで世界を構築している、つまりブラックボックスとはむしろ分節化しきれなかった対象の残ったパーツという位置付けだと言える。
-
-いや実のところ、ラトゥールの科学技術論は、科学技術がこれまで発見されなかった事実を何処かから掘り出していくようなものではなく、（人間が時に物質や環境のような非人間的なアクターに影響を受けながら）、ある科学的事実を「制作」していく[@Kubo2019,p110]という側面を持っているため、アシュビーの考え方とそこまで相反するものではない。しかしながらラトゥールの用いた定義だけを抜き出すと、ブラックボックスとは単にスマートフォンは科学技術者たちがユーザーの理解しきれない高度な技術を詰め込んだもの、というような希少化された使い方をどうしても想起してしまう。
-
-少なくとも今日において使われているブラックボックス/ブラックボックス化という言葉は以下の4つの意味合いを、ときに包括したものとして、ときに限定的な意味合いとして用いられている。このそれぞれの意味合いを具体的に検討しつつ、ブラックボックスを開くという意味でのアーティストたちの取り組みの位置付けを検討してみよう。
-
-1. 知識的：技術に対する知識の欠如
-1. 身体機能的：起きている現象が人間の生理的/認知的限界を超えている
-1. 言語的：何が起きているかはわかっているが、その現象を言語化できない
-1. 社会的：契約や法律によって技術の内部を覗き見ることが不可能である
-
-## 理解不可能性：知識的ブラックボックス
-
-例えばAppleの最新のMacbookProに入っているCPUのことを考える。我々は普段CPUがどう動いているかについてわからないままにCPUを使うことができてしまっている。
-わからない最もシンプルな理由は、CPUとは何かについて勉強してないので、それがどういうものかわからない、ということである。このカテゴリで重要なのは”学習すれば解決できる”という話である。
-この例えを使っているものとしてはパリッカとハーツのサーキットベンディングに関する論考があてはまる。彼らはサーキットベンディングという行為を[@fig:parikkablackbox]のように、アマチュアが中身の動作原理を理解しないまま、回路をつなぎ変えることで別の目的に（例えば、幼児向けおもちゃをノイズ楽器へと）再利用するモデルを示している。彼らがNon-expertという用語を使っていることからも、ここでの意図は改造者に電子回路の詳しい知識がないことに重きがおかれていることがわかる。
-
-![パリッカとハーツによるブラックボックスを意図されない用法で用いるという意味でのサーキットベンディングの概念を表した図。](img/parikka-blackbox.png){#fig:parikkablackbox width=100%}
-
-
-## 知覚不可能性：身体機能的ブラックボックス
-
-しかし、筆者はCPUの基本的な仕組みや構成方法を知っているが、CPUが実際に動いているところを眺めたところで、いまCPUのこの機能が使われているのだということを知覚することは不可能だ。仮に自分でトランジスタを1つ1つはんだ付けしていってCPUを自作したとしても、それが正しく動いている「らしい」と判断できるのは、結局のところ入力に対して期待した出力が出てくることで確かめている＝ブラックボックスとしての利用であることに変わりはない。
-もっと単純な例で、1つのトランジスタが動く場合を考える。トランジスタがゲート-エミッタ間を流れる電流に伴ってコレクタ-エミッタ間を流れる電流を増幅させる作用があることを私たちは勉強で知っているし、不純物の混入で余った/足りなくなった電子が電圧によって移動して～というミクロスケールでの動作の概念についても理解している。しかし私たちは実際に電子が移動している様をこの目で確かめたわけではない。結局これも、入力に伴って出力が変化した、という入出力の対応をもって確かめているに過ぎない。
-
-これは突き詰めれば人間の身体機能が限界にある、といって良いだろう。我々は電子が移動する様を直に見ることはできないし、3GHzで変化するHIGH/LOWの電圧変化をリアルタイムのスピードで知覚することはひとまずできない。
-
-ここで、先述した知識や学習という視点も人間の身体機能の一部なのでまとめても良いのではないかという考えもあるだろう。しかし、電子が移動する様を眺めるには何か（例えばオーグメンテッドヒューマン的に視力を改造するSF的処置が未来に可能になったとして）、外在的な要因で身体機能を強化することでなら可能になるだろうが、人一人が自らの力だけでそこまでの身体的変化を起こすことはまず不可能だろうという点で、ここでは分けておく方が有益だと考える。
-
-## 翻訳不可能性：言語的ブラックボックス
-
-これは少しCPUの例では説明の仕方を変えよう。言語化不可能なことによるブラックボックス性といった時に筆者が想定しているのは、主に機械学習のモデルが下す判断の根拠を説明するのが不可能である、といった問題である。
-
-与えられた画像がイヌかそうでないかを判断するプログラムがあったとしよう。人間が画像認識のアルゴリズムを組み合わせてモデルを構築した場合、プログラムのソースコードにおける関数や変数の名前は人間が解釈可能なものとして残っている。そのため、何かイヌじゃない画像を入れたのに結果がイヌと判断されてこれはおかしい、となった時に、少なくともどの時点での計算での結果がおかしいかがわかり、構築したモデルが正確でない要因をある程度判断することができる。
-
-これが、学習ベースの推論の場合は、モデル自体は大量の並列化された非線形関数とそれ同士の入出力重みづけが並んでいるだけで、学習に伴ってその重みづけのパラメーターが少しづつ変化していくだけだ。イヌかどうかを99%近くの確率で判断できたとしても、中身を開けたとしても、なぜイヌと判断できるのかの理由はわからない。
-
-実際にはCNNのような二次元の重み付けをつけるようなモデルでは、重みづけの分布自体が二次元になるので、この層ではこういう特徴を抽出しているようだ、というモデル解釈に近いこともできるし、機械学習の判断として実用的に（例えば社会的信用スコアをAIで出す時に根拠が出せないのは結構困るので）モデルの説明をするような研究も進んでいる。 https://tjo.hatenablog.com/entry/2019/12/19/190000
-
-もちろん、別に機械学習モデルでなくても、例えば我々の目や脳が何かを見た時にあれをイヌだとかイヌじゃないとか判断していたとして、脳の電気信号をいくら計測したところで「なぜ」イヌかがわかるわけじゃないので、機械学習の方が劣っているという意味でもない。。
-
-重要なのは1とも2とも違って、人間が学習すれば剥がれるブラックボックスでもないし、人間の身体機能をいかに強化したところで解決する問題でもないという意味で種類が違う、ということである。
-
-
-## アクセス不可能性：社会的ブラックボックス
-
-さて、1、2のCPUの例えに戻る。私はCPUの仕組みを勉強していて動作原理をある程度理解しているが、最新のMacbookProに搭載されているCPUの構造を知ることはできない。なぜなら最新のMBPに搭載されているM1チップというAppleが独自に設計したチップの仕様はオフィシャルには公開されていないので知ることができない、ということである。
-
-こうしたことは大概のプロプライエタリなソフトウェアでも同じことがいえ、ブラックボックスの入出力の対応を確かめる＝リバースエンジニアリングによってある程度内部の仕組みを知ることができる可能性はある。しかし、場合によってはエンドユーザー利用規約でリバースエンジニアリングが禁止されており、中身を知ろうとしたことが判明れば訴えられることもあるかもしれない。
-
-1~3のブラックボックスと明らかに異なるのは、誰かが意図的にこのブラックボックスを作っていることだ。それは経済的、政治的な都合などによって生み出され、社会的に存在する権力構造を利用して存在し続けている。
-
-なので、コンピューターを自由な装置として利用するべきであるという方向性での、メガプラットフォーム批判に使われる材料になる。iPhoneという小さなコンピューターを、OSレベルでカスタマイズすることはできず、Appleの公証を受けたアプリケーションしかインストールすることができない、といった意味合いだ。
-
-
-Hackingはブラックボックス1,2,3に対しては機能するかもしれないが、4に対しては効かないだろう
-
-ブラックボックスを構成する要素をこのように4つに分類してみると、カウンターカルチャーとしてのハッキングはもはや有効な手段とは言えなくなってくる。テクノロジーを誤用したから、だからなんだっていうんだよ？と。
-高度化しすぎた知識を、誤用することによって表に出すことには一定の効果があった。サーキットベンディングで音声合成ICをめちゃくちゃに配線することでおかしな音を出したり、音声ファイルのデータをおかしな順番で読み込むことによってめちゃくちゃな音を出すグリッチも、その背後にある音声合成ICの構成や、音声データフォーマットのテクスチャ/質感ともいえる物を表に引っ張り出してきた。
-
-ハッキングが無効になる過程としてのひとつめのカテゴリとしては、アマチュアリズムが無効化されることだ。音が出る電子回路は今や音を出す以外の機能も全て一つのCPUの中に納められており、回路を適当に繋ぎ変えたところで、機械そのものが動作しなくなっておしまいだ。データをグリッチさせようとして適当にビットを弄くり回しても、そこにはエラー訂正の仕組みが入り込み、データは再生不可能な壊れた(corrupted)ものとして扱われておしまいだ。
-その上でテクノロジーを誤用し背景にあるものを引き出そうとすれば、ハッカーもまた専門的な知識を頭に入れた上で、敢えて誤用するという態度が必要になってくる。フータモが言うところの”Tinkerer”から”Thinkerer”への変化だ。グリッチの例を取れば、UCNVのThe Art of PNG Glitch[@UCNV2015]の例を考えることがわかりやすいだろう。PNGファイルは今使われる画像ファイルの中でもJPGと並んでスタンダードなもののひとつだが、先述したような、フォーマット自体にエラー訂正の仕組みが備えられているフォーマットである。UCNVはそのエラーを避ける形でなおPNGのフォーマットの持つ圧縮アルゴリズムを露呈させるようなグリッチを、自らpngglitchというrubyライブラリを作ることで可能にした。
-
-さらなる無効化の過程は、ハックするのに時間がかかるようになることだ。PNGグリッチの例を考えれば、PNGフォーマットに対する知識をつけた（＝1:学習によるブラックボックスを開けた）ところで、JPGファイルをバイナリエディタで開いて適当にデータを壊すことよりも、rubyを用いたプログラミングによってPNGファイルをグリッチさせることには、(例えライブラリの開発を自分でやっていなかったとしても)時間がかかる。
-そもそもソフトウェアのハッキングはハードウェアと比べると基本的には
-
-最後の無効化の過程が4の社会的都合によってハックが不可能になることだ。
-キットラーのCPUのプロテクト・モード
-リングプロテクション：モダンなCPUとOSの権限システム
-
-音楽における例：プリエンプティブ・スケジューリング
-
-	ユーザープログラムはOSがタイムスライスする都合に関与することができない
-	xenomaiの様なカーネル拡張を利用すれば関与できる(Bela)ーしかし、問題はほとんどのコンピューターのOSは自力で改造することができないことだ.
-
-なるべく公平に多数のユーザプログラムがCPUを使用する時間を分配するので、ユーザープログラムから仮にいじれる様なオプションがあったとしても、結局はスケジューリング優先順位の奪い合いになってしまう。これは公共性をめぐる政治そのものである。
-
-この状況下においてはもはやテクノロジーの抜け穴を突いていくセキュリティのvulnerabilityを突いていく様なCracking行為しか成立しないし、そうした獣道を作ったり見つける様な隙すらないほどに現代のコンピューターをめぐるインフラは舗装されすぎてしまっている。カスコーンの言葉を借りるならば、「失敗の美学」のような失敗をすることすら私たちにはもはや難しい。
-
-
-さらに抜け穴を探す作業すらも往年のプロフェショナルなプログラマーが手作業でセキュリティホールを見つけ出す様なやり方からFuzzingの様にそれすらもコンピューターで抜け穴を機械的に探し続けては埋める様な作業に移行しつつある。ハッキングという質の問題がコンピューティングリソースという量（あるいは、資本）の問題へと転化されていく過程は機械学習における計算リソースの問題をはじめとしてあらゆるところで発生している。
-
-コンピューターと楽器、ソフトウェアと楽譜、プログラミングと作曲（と労働）、実行と演奏（と消費）
-
-すなわち、ケイが以下のように表現した通り、コンピューターと楽器、ソフトウェアと楽譜、プログラマーと作曲家を並列するアナロジーは経済学的な視点から見ると単なる類似以上のものがある。
-
-> コンピューターはコンピュータ処理において、いわば音楽における楽器のような役割を果たす。ソフトウェアは譜面にあたり、それを「演奏」したものは、人間の能力を増幅し、精神を高める。[@Kay1984]
\ No newline at end of file
diff --git a/chapter4.md b/chapter4.md
index 04271fb..5065070 100644
--- a/chapter4.md
+++ b/chapter4.md
@@ -1,7 +1,17 @@
+---
+title: 第4章 - PLfM史の再考
+draft: true
+---
 
-\epigraph{コンピューターは「器楽的」な音楽の演奏を、作曲家を補助するために、もしくは誰の補助もなく作曲するように、プログラム可能である。}{『\citefield{Mathews1963}{title}』\\ \citep[筆者訳。]{Mathews1963}}
+<!-- \epigraph{コンピューターは「器楽的」な音楽の演奏を、作曲家を補助するために、もしくは誰の補助もなく作曲するように、プログラム可能である。}{『\citefield{Mathews1963}{title}』\\ \citep[筆者訳。]{Mathews1963}}
 
-\epigraph{コンピューターはコンピュータ処理において、いわば音楽における楽器のような役割を果たす。ソフトウェアは譜面にあたり、それを「演奏」したものは、人間の能力を増幅し、精神を高める。}{『\citefield{Kay1984}{title}』\\ \citep[p96]{Kay1984}}
+\epigraph{コンピューターはコンピュータ処理において、いわば音楽における楽器のような役割を果たす。ソフトウェアは譜面にあたり、それを「演奏」したものは、人間の能力を増幅し、精神を高める。}{『\citefield{Kay1984}{title}』\\ \citep[p96]{Kay1984}} -->
+
+> コンピューターは「器楽的」な音楽の演奏を、作曲家を補助するために、もしくは誰の補助もなく作曲するように、プログラム可能である。
+> [@Mathews1963,筆者訳]
+
+> コンピューターはコンピュータ処理において、いわば音楽における楽器のような役割を果たす。ソフトウェアは譜面にあたり、それを「演奏」したものは、人間の能力を増幅し、精神を高める。
+> [@Kay1984,p96]
 
 # 音楽のためのプログラミング言語とはなにか
 
@@ -37,7 +47,7 @@
 
 ## PLfM史概略
 
-![PLfMの歴史を、リアルタイム性、可変DSP、Lab/PCの視点で分類した概略。](./img/plfmhistory.pdf){#fig:plfmhistory width=100%}
+![PLfMの歴史を、リアルタイム性、可変DSP、Lab/PCの視点で分類した概略。](../img/plfmhistory.png){#fig:plfmhistory width=100%}
 
 そのために本章では、PLfMの歴史的推移の大枠を捉えるために3つの視点での区分を導入する（なお1.2.は西野らのサーベイで使われていた観点である）。
 
@@ -105,11 +115,11 @@ BINACはENIACを開発したジョン・プレスパー・エッカートとジ
 
 ## 音響遅延線メモリーにみる、コンピューターを作る行為としての音楽
 
-<!-- ![『Acoustic Delay (⇔) Memory』(2015)。ディスクリートICで作られた音響遅延線メモリー回路によって、展示空間に8bitのバイナリデータを保持し、Webサイト上からそのデータを読み書きできる。大きな音を出したりマイクを遮ったりすることで物理的にデータに干渉することもできる。](img/adm.JPG){#fig:adm width=80%}
+![『Acoustic Delay (⇔) Memory』(2015)。ディスクリートICで作られた音響遅延線メモリー回路によって、展示空間に8bitのバイナリデータを保持し、Webサイト上からそのデータを読み書きできる。大きな音を出したりマイクを遮ったりすることで物理的にデータに干渉することもできる。](../img/adm.JPG){#fig:adm}
 
-![『送れ｜遅れ / post｜past』(2016)。物理的には独立した2台の通信機能だけを持つ送受信デバイスが、空間に配置されることによってはじめて音響遅延線メモリーとして記憶装置の機能を果たす。](img/postpast.JPG){#fig:postpast width=80%} -->
+![『送れ｜遅れ / post｜past』(2016)。物理的には独立した2台の通信機能だけを持つ送受信デバイスが、空間に配置されることによってはじめて音響遅延線メモリーとして記憶装置の機能を果たす。](../img/postpast.JPG){#fig:adm2}
 
-\begin{figure}[H]
+<!-- \begin{figure}[H]
   \begin{minipage}{0.5\hsize}
     \begin{center}
         \includegraphics[width=1\hsize,keepaspectratio]{img/adm.JPG}
@@ -124,7 +134,7 @@ BINACはENIACを開発したジョン・プレスパー・エッカートとジ
   \end{minipage}
 
 \caption*{{『Acoustic Delay (⇔) Memory』では、ディスクリートICで作られた音響遅延線メモリー回路によって、展示空間に8bitのバイナリデータを保持し、Webサイト上からそのデータを読み書きできる。大きな音を出したりマイクを遮ったりすることで物理的にデータに干渉することもできる。『送れ｜遅れ / post｜past』は物理的には独立した2台の通信機能だけを持つ送受信デバイスが、空間に配置されることによってはじめて音響遅延線メモリーとして記憶装置の機能を果たす。}}
-\end{figure}
+\end{figure} -->
 
 真空管を大量に用いる黎明期の電子計算機では、記憶装置にデータ容量、読み書きの速度、コストのバランスを取ることが求められた。その結果、初期の計算機で用いられた記憶装置は、通信技術を転用した2つの装置のどちらかが利用された。視覚のための装置であるブラウン管ディスプレイの仕組みを応用した陰極線管メモリー（ウィリアムス管メモリー）[^williams]と、聴覚のための道具であるスピーカーとマイクロフォンを利用する音響遅延線メモリーである。
 
@@ -190,7 +200,7 @@ MUSICがそれ以前のシステムと異なっていたのは、**パルス符
 
 人間の知覚できる周波数の上限は約20000Hzなので、その2倍である40000Hz以上の標本化周波数で、かつ量子化歪みが十分少なくなるよう量子化ビット数を決めておけば、人間が知覚できる範囲ではおおよそどのような波形でも数値として表現できるということになる[^compactdisk]。
 
-![ハートレーの論文[@Hartley1928]より、PCMの概念を表した図。](img/hartley_pcm.png){width=70% #fig:hartley_pcm}
+![ハートレーの論文[@Hartley1928]より、PCMの概念を表した図。](../img/hartley_pcm.png){width=70% #fig:hartley_pcm}
 
 連続した波形を離散化する（録音音源をデジタルデータにする）ことだけが目的ならばPCMの理論はこれだけで十分なのだが、標本化/量子化した波形同士を乗算する場合にも折り返し歪みが発生する。こうしたときには一時的にサンプリング周波数を倍にするオーバーサンプリングという処理が必要になってくるなど、波形を処理する際にはもう少し細かい事情を考慮する必要が出てくる。
 
@@ -333,7 +343,7 @@ ALGOL（以下、MUSIGOLに関連する話題で単にALGOLと示した時はALG
 
 実際の、論文に示されていたサイン波を生成するインストゥルメントの関数定義を[@lst:musigolsin]に示す。[^musigolsample]。
 
-\begin{lstlisting}[float,floatplacement=Htb,language=Algol,caption=MUSIGOLにおけるサイン波生成関数のサンプル。,label=lst:musigolsin]
+```rust
 real procedure Sinoscil(Time, Frequency, Amplitude);
     value Time, Frequency, Amplitude;
     real Time, Frequency, Amplitude;
@@ -352,7 +362,9 @@ real procedure Sinoscil(Time, Frequency, Amplitude);
             (0.079487663 - 0.004362476 * XX))) * Amplitude;
         end;
     end Sinoscil;
-\end{lstlisting}
+```
+
+: MUSIGOLにおけるサイン波生成関数のサンプル。 {#lst:musigolsin}
 
 MUSICにおけるUnit GeneratorがFORTRANの関数ではなかったのと異なり、この正弦波発振器はもはやALGOLの関数そのものである。論文で示されていたノコギリ波と正弦波の実装はMUSICと異なりすべて純粋に時間`Time`の写像として表せる方式になっている。一方、内部状態を格納する変数が必要なはずのバンドパスフィルタも実装はされていたようだが、それがどのように成されていたのかに関しては情報が残っておらずはっきりしない。ただ、ALGOLには関数の引数を、2行目で示されているような`value`という宣言をしないことで、関数の内側から引数として渡された変数を書き換えることができる、名前渡しと呼ばれる機能が存在している。これを用いれば関数として内部状態付きのUGenを定義することも難しくはなかったことが予想される。
 
@@ -360,7 +372,7 @@ MUSICにおけるUnit GeneratorがFORTRANの関数ではなかったのと異な
 
 スコアも同様にALOGLの関数である。[@lst:musigolscore]に論文から引用した。`Boing`関数の引数は`開始時間、長さ、音量、音程`である。3行目の`Boing`の音程は`E4`となっており、事前にE4と対応する周波数が変数として宣言されていると思われる。次の行では音程が`Slope`関数で時間に応じてC\msharp{}4からC9まで滑らかに変化するよう指定されている。そして、この`Boing`関数自体もユーザーが、`Sinoscil`関数などを呼び出すものとして実装する部分である。
 
-\begin{lstlisting}[float,floatplacement=Htb,language=Algol,caption=MUSIGOLでのスコアに相当する関数。,label=lst:musigolscore]
+```rust
 procedure Score;
     begin 
         Boing(-3, -1.5, 20, E4);
@@ -368,7 +380,9 @@ procedure Score;
         ...
         Speaker(OUTS, 100); 
     end of Score;
-\end{lstlisting}
+```
+
+: MUSIGOLでのスコアに相当する関数。 {#lst:musigolscore}
 
 イニスによる記述を読む限り、MUSICにおけるStore Functionのような、ウェーブテーブルに一度結果を保存する機能は省かれているようで、サイン波のような比較的計算コストが高い関数も毎サンプル計算され直していたものと思われる。
 
@@ -521,15 +535,16 @@ MaxとPure Dataはその歴史的変遷が複雑なので、その時系列的
 
 パケットは1980年代に、Analogic社のAP400/AP500という配列処理に特化したプロセッサ向けのMUSIC N系派生言語であるMUSIC 400、MUSIC 500を制作していた。MUSIC 500には、マシューズが1986年ごろに提案したMIDIベースのシンセサイザー制御言語、RTSKEDを参考にした仕様が取り込まれていた[@Puckette1983]。RTSKEDには命令型のように上から順に命令を実行するのではなく、あるイベントAに対して処理Bを実行するという記述方法が導入されていた。MUSIC 500ではこの、これまでのスコアに相当する、時間方向に離散的に発生するイベントの記述をControl Processと呼んだ。このControl Processの仕様は、スコアのような記法では不可能な、同時に並行する複数のイベントの記述や、リアルタイムなセンサーからの入力のような、予め絶対時間と紐づけられないイベントに対する挙動の定義を可能にした。
 
-<!-- ![MaxとPure Dataの歴史的変遷をまとめた図。](img/max-pd-history.pdf){#fig:max-pd-history width=100%} -->
+![MaxとPure Dataの歴史的変遷をまとめた図。](../img/max-pd-history.png){#fig:max-pd-history width=100%}
 
+<!-- 
 \begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio, width=1.4\linewidth,angle=90]
-      {img/max-pd-history.pdf}
+      {img/max-pd-history.png}
  \caption{MaxとPure Dataの歴史的変遷をまとめた図。}
  \label{fig:max-pd-history}
-\end{figure}
+\end{figure} -->
 
 
 MUSIC 500は信号処理のリアルタイム実行自体も視野に入れて開発されてはいたが、実現はされなかった。しかしパケットは1985年頃よりIRCAMで、MUSIC 500のControl Processの部分を抜き出し、4Xの制御処理のためのコマンドベース言語としてMaxを開発する[@Favreau1986;@Puckette1986]。この頃のMaxはLispベースのプログラムとして作られていたが、1987年ごろよりC言語で全てを作り直し、Patcherという名前のMax用GUI環境が開発される[@Puckette1988]。
@@ -628,7 +643,7 @@ SuperColliderはテキストベースのPLfMであり、汎用プログラミン
 
 SuperColliderを開発したジェームズ・マッカートニーは大学で電子音楽を学んでいたが、卒業後にハッブル宇宙望遠鏡のシステム管理の仕事に関わる過程で言語処理系についての知識を得た。マッカートニーはC言語で書かれたノンリアルタイムなソフトウェアシンセサイザーSynth-O-Maticというプログラムと、Max上で動作する小さなスクリプティング言語Pyriteの2つを並行して開発しており、それらを統合させる形で、SuperColliderという言語を制作した[@McCartney1996]。
 
-SuperColliderは当初有償のソフトウェアとして250ドルで販売された[@mccartney_announcing_1996]が、マッカートニーが2002年にAppleへ就職したことをきっかけに、オープンソースソフトウェアとしてGPLライセンス[^gpllicense]で公開される。またこのタイミングでリリースされたバージョン3からは、言語のインタプリタ（sclang）が音声合成エンジン（scsynth）に対してOSCプロトコル（[@sec:imagination]も参考）を介して命令を送る形のサーバー・クライアントモデルが採用された。この仕組みが導入されることによって、SuperColliderの言語機能を用いずとも、OSCメッセージを送る別の言語を実装し、音声合成部分はSuperColliderに任せるという新たな形のPLfMの実装が可能になった[^synthdef]。マッカートニー自身、コンピューター音楽に特化したプログラミング言語は理論的には必要ないものの、（当時の時点で）多くの高級言語は特にガベージコレクションなどの実装が、音楽のようなリアルタイム動作を前提にしていない故に、汎用言語上のライブラリとしてPLfMを構築することは難しいと考えていた[@McCartney2002,p68]。実際、2000年代以降にはSuperColliderのクライアントとしての言語が数多く作られるようになる（次節）。
+SuperColliderは当初有償のソフトウェアとして250ドルで販売された[@mccartney_announcing_1996]が、マッカートニーが2002年にAppleへ就職したことをきっかけに、オープンソースソフトウェアとしてGPLライセンス[^gpllicense]で公開される。またこのタイミングでリリースされたバージョン3からは、言語のインタプリタ（sclang）が音声合成エンジン（scsynth）に対してOSCプロトコル（[第3章](../chapter3_rendered#imagination)も参考）を介して命令を送る形のサーバー・クライアントモデルが採用された。この仕組みが導入されることによって、SuperColliderの言語機能を用いずとも、OSCメッセージを送る別の言語を実装し、音声合成部分はSuperColliderに任せるという新たな形のPLfMの実装が可能になった[^synthdef]。マッカートニー自身、コンピューター音楽に特化したプログラミング言語は理論的には必要ないものの、（当時の時点で）多くの高級言語は特にガベージコレクションなどの実装が、音楽のようなリアルタイム動作を前提にしていない故に、汎用言語上のライブラリとしてPLfMを構築することは難しいと考えていた[@McCartney2002,p68]。実際、2000年代以降にはSuperColliderのクライアントとしての言語が数多く作られるようになる（次節）。
 
 [^gpllicense]: GNU Public Licenseの略。そのソフトウェアを利用したり改変して作られた新しいソフトウェアにも同じライセンスの適用を求めること（コピーレフト）が特徴。
 [^synthdef]: インタプリタのほとんどの機能はOSCメッセージ経由で制御できるものの、`SynthDef`のようなSuperCollider言語上でしか利用できない言語仕様も存在する。
@@ -709,7 +724,7 @@ ChucKは「strongly-timed language」をコンセプトに掲げた言語であ
 
 [@lst:chucksample]に10000サンプルごとのタイミングでサイン波の周波数をランダムに書き換える例を示した。ChucK演算子`=>`と呼ばれる独自の演算子は、値を変数に格納するための代入演算子（一般的な`=`と異なり右側に代入先を記述する、右向き代入）としての役割と、UGen同士の接続の記述を表す機能を兼ねている。また、`now`と呼ばれる値に`Time`型を持つ値を代入すると、その値の分論理時間スケジューラを停止する。このnowへの代入を用いて具体的な実行タイミングを制御するのである。
 
-\begin{lstlisting}[float,floatplacement=htb,caption=ChucKで10000サンプルごとにサイン波の周波数を変更するコードの例。,label=lst:chucksample]
+```rust
 SinOsc s => dac;
 .4 => s.gain;
 while(true)
@@ -717,7 +732,9 @@ while(true)
     Std.mtof( Math.random2(20,60) ) => s.freq;
     10000::samp => now;// advance time
 }
-\end{lstlisting}
+```
+
+: ChucKで10000サンプルごとにサイン波の周波数を変更するコードの例。 {#lst:chucksample}
 
 またChucKのもう1つの特徴は、コードをリアルタイムで書き換え演奏するライブコーディングも想定している部分である。
 
@@ -744,8 +761,7 @@ ChucKも2012年に導入されたChuGenという拡張機能を用いること
 時間軸上のデータという考え方を中心においたChronicに対して、よりUGenのような、入出力を持つグラフ構造による処理の代数的表現を追求したのが、南フランスの電子音楽研究所GRAMEで、ヤン・オーラリー、ステファン・レッツ、ドミニク・フーバーらによって同じく2002年ごろから開発されているFaustである[@Orlarey2004]。
 
 <!-- =latexがないとpandocのパースが狂う  -->
-```{=latex} 
-\begin{lstlisting}[float,floatplacement=htb,caption=Faustで有限インパルス応答フィルターを表現するコード。,label=lst:faustsample]
+```rust
 import("stdfaust.lib");
 fir(taps,gainlist) =  (_,gainlist):routes(taps):>_
     with{
@@ -758,12 +774,13 @@ fir(taps,gainlist) =  (_,gainlist):routes(taps):>_
 process =fir(3,(0.1,0.2,0.3));
 //process =fir(4,(0.1,0.2,0.3,0.4)); //increasing the order
 //process =fir(5,(0.1,0.2,0.3,0.4,0.5));
-\end{lstlisting}
 ```
 
+: Faustで有限インパルス応答フィルターを表現するコード。 {#lst:faustsample}
+
 Faustの言語の概念の中心となる概念は**ブロックダイアグラム代数（Block Diagram Algebra：BDA）**という体系である。BDAでは、定数、入力同士の四則演算、サイン波、ディレイなどのあらゆる要素が、任意の数の入出力を持つノードとして表される。そして、これらノードを、並列（`a , b`）、直列（`a : b`）、分岐（`a <: (b,c)`）、合流（`(a,b) :> c`）、再帰（`a ~ b`）という5種類の基本演算を組み合わせることによってグラフ構造を形成し、信号処理を表現する[@Orlarey2002]。Faustではのちに、アルバート・グラーフが再帰的にパターンマッチ可能なマクロの体系を導入することによって、例えば任意のオシレーターを100個入れ子状に複製する、といったような高度な抽象化が可能になった[@Graf2010]。[@lst:faustsample]にFaustにおける有限インパルス応答フィルタの記述例を示した[^faustfirsample]。`fir`関数はフィルターの次数と、次数に応じた係数のリストを受け取るとフィルター処理のBDAを生成する。FaustはプログラムだけでなくSVG（ベクター画像）ファイル形式でBDAの構造を視覚化も可能である。それぞれ次数が3、4、5、10の時の視覚化の様子を[@fig:faustmacro]に示す。
 
-![[@lst:faustsample]におけるフィルターの次数を3、4、5、10と変化させた時のBDAを表す図。](img/faust-fir.pdf){#fig:faustmacro width=100%}
+![[@lst:faustsample]におけるフィルターの次数を3、4、5、10と変化させた時のBDAを表す図。](../img/faust-fir.png){#fig:faustmacro width=100%}
 
 FaustではコンパイラがBDAをC++などの低級言語のソースコードに変換することによって、実行時性能を損なうことなく、かつプログラマがハードウェア操作を意識することもなく信号処理の記述が可能になっている。当初この信号処理の実行バイナリ生成はバッチ処理のような、一度プログラムを生成してからそれを別のプログラムで読み込んで利用といったステップを踏んでいたが、コンパイラ基盤LLVM[@Lattner2004]を利用することによって、プログラムの実行中にFaustから実行バイナリの生成、読み込みをメモリ上で完結させることができるようになった。これにより、例えばMax上の`faustgen~`というオブジェクトを利用して、MaxのプリミティブなUGenの組み合わせでは作れないような処理を、Max上のテキストエディタにFaustのコードを記述し即時利用するといった、他の言語への埋め込みが簡単に行える。
 
diff --git a/chapter4_memo.md b/chapter4_memo.md
deleted file mode 100644
index 1380d00..0000000
--- a/chapter4_memo.md
+++ /dev/null
@@ -1,135 +0,0 @@
-
-音楽のためのプログラミング言語は既存の文献では、Computer Music Language[@McCartney2002;@Mcpherson2020]、Language for Computer Music[@Dannenberg2018]、Computer Music Programming Systems[@Lazzarini2013]などの呼ばれ方がされているが、それぞれの語の使用に明確なコンセンサスがあるわけではない。その中でも敢えて筆者がComputerという語を使わない理由のひとつは、Computer Musicという語が、コンピューターを用いることで新しい音楽表現を追求する歴史的な取り組みの中にある、特定の音楽様式と結びついてしまうことを避けるためだ。既に述べたように、今日ではあらゆる音楽制作と再生のためにコンピューターが用いられている以上、あらゆる音楽が**弱い意味でのComputer Music**と呼ぶことができる。しかしそれらの多くはコンピューターでなければ不可能な、コンピューターというメディア固有の表現を行っているわけではない。同様に、たとえばFaust[@Orlarey2004]のような、信号処理のアルゴリズムを抽象化することに特化したプログラミング言語は新しい音楽表現を必ずしも目的としていないが、その技術的要素の多くはComputer Musicのための言語と共通するところがある。またPLfMという枠組みを用いることで、これまでの文献では比較対象に入れられること自体が少なかった、MML:Music Macro Languageのような、五線譜上の記法を直接的にテキストに置き換えたような、単にコンピューター上のテキストというフォーマットで音楽を表すことを目的とした言語たちも、チップチューンのような広い意味でのコンピューターを用いた音楽文化を作るための要素として議論の土台にあげることができる。
-
-加えて、Programming EnvironmentやProgramming Systemといった語を用いない理由も説明しておこう。これは、音楽のためのプログラミング言語といった時に、たとえばMaxのような、ある特定のアプリケーションを想像するニュアンスを抑えるための選択だ。たとえば、汎用プログラミング言語の理論においては、プログラミング言語、と言った時にはその言語を実行するためのソフトウェアやプログラムのことを必ずしも指していない。たとえば同じC++という言語であったとしても、それを実行するソフトウェア（コンパイラ）はGCC、Clang、Microsoft Visual C++といったように複数存在し得るからだ。これらのコンパイラは、どれもC++の厳格な言語仕様で定まっている通りの動作をするが、言語仕様で未定義とされてる動作はそれぞれ異なるし、コンパイラが出力する実行バイナリ（≒アプリケーション）の中身は同じソースコードだったとしても異なる。音楽プログラミング言語においては、基本的にある言語＝特定のアプリケーションであることがほとんどだが、根本的にはアプリケーションの設計実装という作業とプログラミング言語の設計実装という作業は異なり、本研究が対象にしたいのは言語の設計なのだ。こうしたニュアンスを込めて筆者はEnvironmentやSystemという語を用いないことにした。極論を言えば、Faustのような厳密に意味論が定義されている言語においては、コンピューターを用いなくてもそのソースコードを手作業で解釈し実行することが可能だということを考えれば、プログラミング言語はコンピューターを使うための道具であることは間違いないにせよ、人間が直接的にバイナリを操りプログラムを構築するには限界があるという理由で開発されているという意味で、逆説的に徹頭徹尾人間のための道具でしかない。だからComputer Music Languageとも、Computer Programming Languageとも、呼ばずに、ただ音楽のためのプログラミング言語：Programming Language for Music、PLfMなのだ。
-
-1970年代の区切りは2章で見てきたコンピューターをメタメディア装置として扱う思想の始まりと、パーソナルコンピューターの登場という2種類の出来事である。
-
-そもそも音楽プログラミング言語の祖先となるソフトウェアMUSICが開発されたのは正解で最初の(汎用)プログラミング言語FORTRANが作られた翌年であり、当然1章で見たアラン・ケイらによる対話的プログラミング環境や豊富な入出力インターフェースを備えるよりもずっと前のことである。
-なので、必然的に音楽ソフトウェアのプログラミング自体も機械語を直接入力するかアセンブリ言語(機械語の命令をテキストと1対1対応させたプリミティブなプログラミング言語のようなもの)しかなかったし、そのソフトウェアに対する入力データ（≒楽譜）も同様の形式を取らざるを得ないものだった。
-
-つまり、1950〜1970年代の音楽プログラミング環境は大まかにいってコンピューターで音楽を作るためのソフトウェア全般の祖先にあたるものであって、必ずしもプログラミングという行為やテキスト入力という形式の固有性を積極的に取り入れたものではない、ということだ。
-
-逆に、70年代以降の音楽プログラミング言語/環境はマウスや(文字入力や、ピアノ鍵盤どちらにせよ)キーボード入力といった直感的（WYSIWYG的）なインターフェースが選択肢として存在する中で敢えてプログラミングという手段を使うものとして設計されてきた、という違いがあると言えるだろう。プログラミング環境であっても、GUIの誕生はMax(Puckette)を代表としてテキストインターフェースだけでなく、入出力を持つボックスをマウスで繋いでいくような形式など、テキストに留まらない形式でのプログラミング行為を可能にした。これは同時に、出力された信号などもオシロスコープのようなグラフィックとしてフィードバックが返ってきたり、パッチ（Maxにおけるプログラムのこと）中にスライダーのような、プログラムされたソフトウェアを操作するためのインターフェースが同居していたりといった、それまで存在していた「プログラムを構築するステップ」と「構築されたプログラムを使用するステップ」に明確な境目が無くなっていく歴史でもある。
-
-
-また、1990年代の区切りは、パーソナルコンピューターが専用のサウンドチップなしに、CPUだけで音声信号処理をリアルタイムで行えるようになったこと、そして汎用プログラミング言語の理論が音楽向けの言語にも流入し始めたことの2種類である。
-
-
-コンピューターアーキテクチャのスタンダード（もっと言ってしまえば、x86アーキテクチャ）が定まるまでのプログラミングは、特定のハードウェアのための特定のプログラムを作るという側面が大きく、書かれたソフトウェアが様々なプラットフォームで使い回しが効くということでもなかったことも頭に入れておくべきだろう。汎用プログラミング言語はそれまでの実在するハードウェアに対する命令列を可読性のあるテキストデータから出力するためのソフトウェアという側面だけでなく、ラムダ計算（引用）のような、計算過程自体を数学的になるべく普遍的になるように記述する代数学の理論との接続を見せるようになり、LISPやML、Haskellに代表されるような関数型プログラミング言語のパラダイムが発生してきた。
-そしてこうした分野で培われたプログラミング言語の理論は現在ではFaustやKronosを代表とする、関数型でかつ音楽や音声処理のための言語の理論的基盤としても用いられるようになっている。
-
-
-つまり2020年代現在において、本論文が定義する音楽プログラミング言語とは、**コンピューターを用いて音楽を生成するためのソフトウェア群に始まりつつも、並行して発展してきた汎用プログラミング言語やその理論を取り込みつつ発展してきたソフトウェアやツール**のことを指す。なので、Maxのように前者の流れを強く汲むものは、Dannenbergが言うように、言語体系とランタイムやライブラリ、開発/実行環境があらかじめ切り離せない形式(＝実装そのものが仕様)となっていることが多い。
-逆に、汎用プログラミング言語の理論をベースに構築された言語、例えばExtemporeやFaust、Kronosでは、言語仕様は言語仕様として独立しておりランタイムが存在しないーあるいは複数のランタイムの実装があり得る、そのほか、決まったIDEが存在しなかったり、複数の開発/実行環境が存在するといった構成になっているものがある。
-
-
-音のなるおもちゃの電子回路を改造しておかしな音が出る楽器へと変えてしまうサーキット・ベンディング文化の原点の1人として捉えられる、音楽家のミシェル・ワイシュヴィッツは、1970年代にCrackleboxという、たったひとつのオペアンプ（演算増幅器）の端子を直接身体で触りフィードバックと発振を起こすことで予測不能な音を出す楽器を作った。彼はその楽器の思想の原点に子供の頃のラジオの蓋を開け、回路を直接触ることで音を変化させて遊んでいるエピソードを挙げている。
-
-
----
-
-# Unit Generatorとモジュラーシンセサイザーの関係性
-
-MUSICシリーズにおいて触れておくべきことは、MUSIC IIIにおいてはじめて**Unit Generator**と呼ばれる、今日まで用いられる概念が登場したことである。Unit Generator(UGen)とは、簡単にいえば正弦波や三角波、矩形波などの発振器や、各種フィルターといった信号処理における基礎単位を抽象化したものである。
-
-これは
-
-
-、MUSIC IVにおいてはじめてそれ自体の実装が汎用プログラミング言語(FORTRAN)で実装されたことである。
-
-まず、Unit Generatorとは〜
-
----
-
-# インターミッション–1970年代 {#sec:intermission}
-
-MUSIGOLの背景にもあったように、1960年代後半から1970年代にかけて、MUSIC Nシリーズは様々な派生系がアメリカ各地の大学で実装されるようになった。しかし、ここから現代のPLfMまでの繋がりを考えるためには、これらの派生系の系譜を追うだけでは不十分である。なぜなら、MUSIC Nの派生が多数作られた要因の一つが、トランジスタを用いたこれまでより小型なコンピューターが設置されることにあったように、電子計算機の産業化が研究にも如実に影響を及ぼすようになってきたからである。例えばDigital Equipment Corporation（DEC）社が発売したPDP-10は、スタンフォード大学人工知能研究所（SAIL）でMUS10（MUSIC 10とも呼ばれる、1966年）の開発に、PDP-11は現在まで使われるCsoundの原型であるMUSIC-11（1973年）の開発に用いられた。
-
-そこで1970年代に関しては遠回りになるが、今一度この時代の背景を、2章や3章で見てきた内容に重ねて考えてみる必要がある。まず第2章で示したとおり、1970年代はサイバネティクスの影響を受けたデザインサイエンス的運動からデザイン思考のような反省的実践の兆しが現れる移行期である。
-
-特に1970年は大阪万博での鉄鋼館スペース・シアターでスピーカーを1000個以上使った音楽作品が作られたり、ペプシ館でのExperiments in Art and Technology(E.A.T)の展示やパフォーマンスが行われるなど、芸術とテクノロジーの単純なコラボレーションとしては一時期のピークとも言える年である。しかし、コンピューターと音楽の関係性により焦点を当てると、クラシック音楽に端を欲した音楽実践で、テクノロジーを取り入れることを試みてきた中にも実は2つの対立する方向性が存在している。フランスの国立電子音楽研究所IRCAMでのフィールドワークを1984年に行なった、文化人類学者のジョージナ・ボーンはその違いをこのように説明する[@Born1995,p3]。
-
-ひとつは、無調音楽を発展させ、十二音技法と呼ばれる技法を生んだアルノルト・シェーンベルクに連なる、厳密で規則化された音価の制御を指向する、普遍主義、科学主義的モダニストである。十二音技法はさらに、音程以外の様々なパラメータもルール付けするトータル・セリエリズムに発展していく。この系列には例えばのちにフランスの電子音楽研究所でIRCAMの音楽ディレクターに就任する作曲家・指揮者のピエール・ブーレーズ、アメリカのプリンストン大学で、RCA Mark IIなど初期の大型シンセサイザーを用いて作曲を行なったミルトン・バビットなどが挙げられる。反対には、ともにシェーンベルクらに影響を受けながらも、音楽の概念自体の脱構築（図形楽譜、演奏より聴取にフォーカスする、不確定性、日常への介入、etc…）を試みた、ジョン・ケージに連なるポストモダニストたちがいた。
-
-この態度の違いは、セリエリストたちが作る難解な音楽が大衆の理解から遠ざかることに対する問題意識への違いと、芸術家の組織的援助への態度として現れた。特に、ミルトン・バビットが1958年に書いたエッセイ、「専門家としての音楽家」（原題：「人が聞くかどうかなど気にする必要があるか？」[^takaoka]）[@Babbitt2011]では、「数学者の研究が大学によって支えられているように、難解で複雑な音楽の創作も大学によって保障されるべきである」と、音楽の専門知と、大学のような研究機関の関係性に対する態度をはっきりと示し物議を醸した。
-
-[^takaoka]: 引用部分も含め訳出は[@Takoka2011]を参考にした。
-
-一方、ケージの立場に近い人間も、十二音技法や単なる楽音に留まらないオルタナティブな表現を追求しつつもどこか技術決定論的な、テクノロジーが新しい音楽を生み出してくれるという期待を持っており、それは結果的に、大学や国家ではなく大企業と資本主義という異なる形での権威との付き合い方への見直しを迫られることになっていく。そもそもケージが無音の『4分33秒』にたどり着いたのも、ハーバード大学の無響室を体験したことで完全な無音など存在しないと気づかされたことがひとつのきっかけであったし、その『4分33秒』の初演のピアニスト（実際には何もしないのが演奏なので鍵盤を弾くことはないだが）で、ケージと長く付き合いのあるデヴィッド・チュードアは自らの手で様々な電子回路を組み音楽を作る作曲家でもあった。そして何よりこうした、1960年代におけるアーティストとテクノロジーのコラボレーションを推し進めるのに一役買っていたの、E.A.Tを立ち上げたビリー・クルーヴァーは、他ならぬMUSIC Nが開発されていたベル研究所のエンジニアだった。
-
-
-
-
-
-
-
-トランジスタの登場などにより電子部品が低価格しアーティストでも利用可能になった
-
-
-E.A.T
-
-The use and the development of software involve the writing of coded instructions within a software language or the creation of a completely new language, within the context of a hierarchy of such languages. At each of the hierarchy a traslation occurs between any two adjacent language or levels of code. Instructions from the language at a higher level mus be translated into aform whereby they can be "read" and executed by the lower-level code or language without any (or with minimal) loss of "meaning"
-
-The hierarcy of codes that normally operates in computer software include, at the lowest level, machine code, the instructions that drive the hardware, written in binary form; at the next level up, assembler code, made of mnemonic abbreviations of machine code; above this, the general operating system that provides a basic framework and set of servicies; and above this, any of the major lkanguages such as FORTRAN, Pascal, C, or LISP.
-
-リアルタイムで処理できない程度に重かったこと
-楽器のモデルを計算できる理論が存在しなかったこと→Rissetに始まる物理モデリング合成研究（Analysis-Synthesisアプローチ）
-
-80年代にしては計算のシンプルさに対して複雑な音色が出せるFM合成とかはあったが、コンピューター音楽言語は大学や研究所に限られていたし、リアルタイム性にもまだ欠けていた extreme mediation, both temporal and conceptual
-
-モデルがしっかりしていないと音を改善することができないけど、トライ&エラーに時間がかかるのでモデルの妥当性を確かめるのにも時間がかかってしまうパラドックス
-
-
-技術のトリクルダウン：研究所でパイオニア的テクノロジーが発達し、それがコマーシャルに低価格化していくという考え方をIRCAMは持っていた
-一方で、マシューズのようなインターフェース系のを拒否し、かなり基礎的な部分に投資するという矛盾
-
-その上で、当時出てきたばかりのMacintoshの登場や、コンピューターアーキテクチャの発展にかなり振り回されている
-
-
-ヤマハの人がCXのデモにIRCAMにきた話
-
-4xは当時最強のスペックだった→これ何がそうさせたんだろう？オシレーターとかはソフトウェアで仮想化できたんだろうか？西野の文献読む必要あり→できた。Variable Digital Signal Processorの話
-
-OSから作ってた　ハードは凄かったがソフトとペリフェラルが弱い
-
-Chant 歌声合成、Formes PatchworkとOpenMusicの手前
-
-Chant／Formesのグループからは、音楽概念の高度な発達というコンピューターのポテンシャルを無視していると思われてた
-
-Chant/FormesはLISP製、VAX/UNIXシステムで動いていたノンリアルタイムシステム
-    users could create their own "personalized environment"
-    object oriented
-
-
-
-〜〜
-
-Computer music software such as that used and produced by IRCAM adds yet a further level of mediation, hierarchy, and translation, sincce the music languages are themselvels based upon, or written in, established general languages.
-
-Thus, Music V is written in FORTRAN, Cmusic in C, IRCAM's Chant in FORTRAN, and Formes in LISP.
-
-
-Chantを使うにはFORTRANの知識も必要だったし、Formesを使うにはLISPの知識も必要だったので、それを勉強するためにまずLISPについて勉強しなくてはならない →**つまりこの時点ではまだ、後にMcCartneyがSuperColliderの設計指針として挙げる、プログラミングというコンピューターハードウェアを使うための専門的知識が必要な事項をencapsulateし、音楽のNotationに集中させるという意味での音楽”言語”の概念は達成されていなかったということが言えるだろう。**
-
-
-ーーー
-筆者は2017年頃から、オーディオフィードバックを利用する自作の電子楽器Exidiophoneのような、コンピューターを全く使わない演奏活動を継続してきたが、一方で時折ラップトップのみの演奏も行ってきた。その中には、2018年8月のAlgorave Tokyoでの演奏も含まれる。筆者はこの時、ChucKの環境上でFaustをライブコーディング可能にする拡張機能FaucK[@Wang2016]を利用したパフォーマンスを行った。この演奏ではサンプル再生や、十二音のメロディの制御は一切行わず、波形同士のビット演算波形を加工することでリズムパターンを作りつつ、ラップトップの内蔵マイクロフォンの音量を変化させることでハウリングの発生を制御する、という演奏を行った[^algorave2018]。
-
-[^algorave2018]: 演奏の記録がほとんど残っていないが、共演者の野本直輝が撮影した動画にその一部が記録されている。 https://twitter.com/reprimande/status/1031196496761217027 2022年1月28日最終閲覧。
-
-この演奏では、多くのSuperColliderクライアント言語で焦点を当てているサンプル再生のリズムパターンとはコーディングの際の思考プロセスが全く異なる。どちらかと言えば、デモシーン（チップチューンとも歴史を共にする、小さなデータサイズで映像や音声を生成するプログラム作成を競い合う文化）で培われてきたテクニックである映像生成のための言語GLSLを利用した音楽生成[^soundshader]や、Bytebeatと呼ばれる簡単なビット演算を用いた音声生成[^bytebeat]のように、`t`の写像として音圧波形を直接を生成する方式に近い。
-
-[^soundshader]: GLSLによる映像プログラムを共有するWebサイトShadertoyでは2014年からGLSLを用いた音声合成がサポートされている[@Shadertoy2014]。
-
-[^bytebeat]: [@Montfort2013,p249〜256]の解説を参照。
-
-こうした波形の演算によって、音色の編集にとどまらずリズムパターンのような長い時間軸で音声を生成する行為の中には音色の決定と音程やリズムの決定という区分がそもそも存在していない。低レイヤーの抽象化の方法を再考することには、単にユーザーのアクセス可能性を広げるだけにとどまらず、音程、リズム、音色と言った音楽における根本的な概念自体を取り崩す意味合いも持っている。
-
-FaucKを用いたパフォーマンス、GLSLでの音声合成、Bytebeatは音圧波形の直接的計算を基本としているが、
-
-例えばパケットは2015年のICMCでの発表で、そもそもPCMを処理する（あるいはMIDIベースなど）以外にもコンピューターで可能な音圧波形、音声の抽象化方法はあり得るのではないかという問題提起をしている[@Puckette2015]。例えば計算機上で、PCMと同じように音圧波形を記述、生成することを目的とした場合にも、音圧を時間ごとに均等に区切るのではなく、直線を時間軸上に配置するようなデータ表現などもあり得るのではないかと提案する。ここで重要なのは、直線の折れ曲がりの不連続部分には理論上無限に高い周波数成分が含まれていることである。この直線の集合を直接的に電気回路として再生できるのなら、PCMでは完全に再現することができない音声信号を作ったことになる（ただし、それを実際に可能にするシステムまでは提案されていない）。
-
-あるいは、音圧波形を直接的に離散化するのではなく、音を生成する楽器に相当する微分方程式などの数学的モデルを組んでから、それを離散化して再生するというのもコンピュータープログラミング言語に可能な抽象化のひとつのはずである。実際、SPICEのような電気回路のシミュレーターなどのためのDSLは、宣言的に電子回路の部品接続を記述することで、等価な数学的モデルを構築し、自動でその微分方程式を離散化する仕組みになっているのだ。パケットも講演内で、生徒の1人であるアンドリュー・アレンが作ったバネ・マス・ダンパーをグラフィカルに接続することで物理的特性にのっとった音再生ができるインタラクティブなアプリケーションRuratae[@Ruratae2014]を引用し同様の主張を行なっている。
-
-もちろん、物理シミュレーションベースの信号処理も、例えば打楽器のような面の振動、三次元の振動体の振動などのモデルは、時間軸だけでなく空間方向にも離散化が必要になり、その結果必要な計算コストが飛躍的に増えるといった問題もある。しかし重要なのは、物理的な楽器の完全再現ができずとも、連続時間領域で数学的モデルを組み合わせていくこともあり得る抽象化の方法のひとつであり、PCMベースの処理で音圧波形にあれこれエフェクトをかけたりするのと似たようにそれなりの探索空間があり得るのではないか、そしてその探索空間はPCMベースの処理では容易にたどり着けなかったものなのではないか、ということである。似たような方法論では、コンピューター音楽にバックグラウンドを持ちつつもサーキット・ベンディングのようなオルタナティブな表現の実践と紹介をし続けてきたニコラス・コリンズも、様々な非線型振動を引き起こす数学的モデルを、何かに似せることを目指さず使うため、Errant（間違った） Sound Synthesisという方法論とともにSuperColliderのためのUGenパッケージとして提示している[@Collins2008]。
diff --git a/chapter5.md b/chapter5.md
index 8c1c230..d9479f7 100644
--- a/chapter5.md
+++ b/chapter5.md
@@ -1,3 +1,7 @@
+---
+title: 第5章 - PLfMに関する諸用語と概念の整理
+draft: true
+---
 
 第4章では時間軸に沿って、PLfMの歴史的変遷を追いかけてきた。PLfMは歴史的に、Unit GeneratorやMIDIなど、特定の音楽様式を言語仕様そのものに埋め込みながら発展してきた。しかし、2000年以後は、ブラックボックスとして与えられていたUGen自体をより一般的な代数的表現で記述するFaustのような試みや、SuperColliderを音声合成エンジンに使いながらも、これまでと異なる抽象化を試みるTidalCyclesのような試みが立ち上がってきた。当初はコンピューターを用いた音楽表現に十分可能な範囲の表現の広さを提供してくれると思われたUGenも、その抽象化方法自体を物理化したハードウェアが現れたり、UGenをベースにしたプログラミング作業の効率化を図ることによって、それ以外の抽象化方法の提示を妨げるインフラストラクチャとしての性質を持つようになっている。
 
@@ -119,7 +123,7 @@ DSLは音楽に限らず、例えばProcessingやGLSLのようなグラフィッ
 
 CoffeeColliderはSuperCollider上におけるUnit Generatorの接続をWeb Audio APIという、Webブラウザに近年標準的に組み込まれるようになった音声合成のためのインターフェースを用いることで実現している。CoffeeColliderは文字列解析を自分では行っておらず、特定のオブジェクトに対する`+`演算子や`*`演算子の挙動をオーバーロードすることで、CoffeeScriptの文法で可能な範囲の表現でシンタックスをSuperColliderへと模している。
 
-\begin{lstlisting}[float=btph,caption=CoffeeColliderのコードサンプル,label=lst:coffeecollider]
+```rust
 (->
   noise = PinkNoise.ar(0.2)
   noise = Mix Array.fill 10, (i)->
@@ -128,9 +132,11 @@ CoffeeColliderはSuperCollider上におけるUnit Generatorの接続をWeb Audio
   noise = RHPF.ar(noise, LFNoise0.kr(0.5).range(220, 880), rq:0.001)
   CombL.ar(noise, delaytime:0.5, decaytime:25).dup() * 0.5
 ).play()
-\end{lstlisting}
+```
+
+: CoffeeColliderのコードサンプル。 {#lst:coffeecollider}
 
-\begin{lstlisting}[float=btph,caption=SuperColliderのコードサンプル,label=lst:supercollider]
+```rust
 {
    var noise = PinkNoise.ar(0.2);
    noise = Mix.new(Array.fill(10, {arg i;
@@ -139,7 +145,9 @@ CoffeeColliderはSuperCollider上におけるUnit Generatorの接続をWeb Audio
    noise = RHPF.ar(noise, LFNoise0.kr(0.5).range(220, 880), rq:0.001);
    CombL.ar(noise, delaytime:0.5, decaytime:25).dup() * 0.5
 }.play;
-\end{lstlisting}
+```
+
+: SuperColliderのコードサンプル {#lst:supercollider}
 
 [@lst:coffeecollider]と[@lst:supercollider]にSuperColliderとCoffeeColliderで、等価な音を出すサンプルコードの比較を示す。2つのコードを見比べると、SuperColliderでの`{}`で囲むことでオブジェクトを生成するシンタックスを、CoffeeScriptにおける無名関数`(-> statements)`を利用して似せていることがわかる。CoffeeColliderの実装は、**演算子のオーバーロード**というホスト言語にある機能を積極的に活用することで、テキストをパースするプログラムを書くことなく、かつ、CoffeeScriptのシンタックスの中で可能な限り記法をSuperColliderに近づけている。
 
@@ -187,7 +195,7 @@ d1 $ sound "bd*4" # gain (every 3 (rev) $ "1 0.8 0.5 0.7")
 
 また、汎用OSの上で並行処理を実現しようとすると、多くのOSが採用しているプリエンプティブ・スケジューリングと呼ばれるマルチタスク管理の方法も実行タイミングの非決定性につながる。多くのOSでは、実際のCPUのコア数よりもはるかに多くのプロセスが並行して動作する。これは、OSが多くのアプリケーションの実行を適切にCPUに割り振り、さらに1つのCPUの中でも細かくそれぞれのプロセスを時分割して実行しているからである。プリエンプティブスケジューリングの特徴は、このOSが時分割を行うタイミングに、分割される側のユーザープログラム（e.g. PLfMのランタイム）が関与できないことである[^linuxscheduling]。
 
-[^linuxscheduling]: Linuxカーネルの場合にはユーザーはプロセスのスケジューリングポリシーをいくつかの種類から選択できる。 https://linuxjm.osdn.jp/html/LDP_man-pages/man7/sched.7.html 2022年1月31日最終閲覧。またそもそもLinuxの場合はOSがオープンソースなため、Bela（[@sec:intro]参照）で用いられていたXenomaiのように、ユーザーアプリケーションがメインのスケジューラーをバイパスして動作するカーネル拡張を利用する選択肢もある。
+[^linuxscheduling]: Linuxカーネルの場合にはユーザーはプロセスのスケジューリングポリシーをいくつかの種類から選択できる。 https://linuxjm.osdn.jp/html/LDP_man-pages/man7/sched.7.html 2022年1月31日最終閲覧。またそもそもLinuxの場合はOSがオープンソースなため、Bela（[第1章](../chapter1_rendered#intro)参照）で用いられていたXenomaiのように、ユーザーアプリケーションがメインのスケジューラーをバイパスして動作するカーネル拡張を利用する選択肢もある。
 
 ライブラリとしてのPLfMを実現している数少ない例外としては、Lua言語上で、コードをメモリ上でネイティブバイナリへとコンパイルし即時利用するJIT（Just-In-Time）コンパイルするLuaJITの機能を活用した音声、映像のライブコーディング環境LuaAVがある[@Wakefield2010]。LuaAVはライブラリでありながら論理時間ベースのサンプル単位の制御を保証したスケジューラーを搭載している。LuaAVというライブラリとしてのPLfMの実現にはLuaという言語自体が様々な言語やアプリケーションに埋め込んで用いることを想定した作りになっていることが反映されている（例えば、音楽制作ソフトウェアではオープンソースのDAWであるArdourが機能拡張のためにLuaを採用している）。
 
@@ -209,7 +217,7 @@ d1 $ sound "bd*4" # gain (every 3 (rev) $ "1 0.8 0.5 0.7")
 
 例えば、ブランドがChronicを開発するにあたってのモチベーションは音楽のための言語に存在する表現力の高さ（Expressiveness）と汎用性（Generality）のトレードオフの解消だった[@Brandt2002]。それを説明したのが[@fig:chronic-tradeoff]である。
 
-![ブランドがChronicを開発するにあたって説明した、ExpressivenessとGeneralityのトレードオフ。[@Brandt2002]より引用。](img/chronic-tradeoff.pdf){width=70% #fig:chronic-tradeoff}
+![ブランドがChronicを開発するにあたって説明した、ExpressivenessとGeneralityのトレードオフ。[@Brandt2002]より引用。](../img/chronic-tradeoff.png){width=70% #fig:chronic-tradeoff}
 
 ブランドは文献中で、Expressivenessを「ユーザーが読みやすく書きやすい」、 Generalを「可能な表現の範囲が広い」という意味で用いられている。またChronicはOCamlというホスト言語の実行速度の問題もあり、リアルタイムで実行はできなかった。つまりChronicではGeneralとExpressiveの両立はできたが実行時パフォーマンスという新たなトレードオフが発生していたことがわかる。
 
@@ -231,7 +239,7 @@ d1 $ sound "bd*4" # gain (every 3 (rev) $ "1 0.8 0.5 0.7")
 
 実のところ、音楽に限らずプログラミング言語という分野自体、1960年頃から長く学術的研究がされている中でその貢献をどう主張するか、特に作った言語をどのように評価すればよいかという話題は2009年のACM SIGPLAN[^sigplan]主催の*PLATEAU: Evaluation and Usability of Programming Languages and Tools*が開催されるまであまり触れられてこなかった。2010年のPLATEAUでマークストラムは新しい言語の実装や設計などのアイデアを論文として提示する際の正当化の方法として、**主張と根拠の整合性（Claim-Evidence-Correspondense）**という見方を提示した[@Markstrum2010]。
 
-[^sigplan]: 筆者の投稿したFARMなどの国際会議を主催する団体。[@sec:researchfield]を参照。
+[^sigplan]: 筆者の投稿したFARMなどの国際会議を主催する団体。[第2章](../chapter2_rendered#researchfield)を参照。
 
 マークストラムによれば、プログラミング言語の論文で提示される主張は大きく分けて3種類あるという。1つ目はこれまで存在しなかった新機能を作ったというもの、2つ目はすでにある既存の機能の効率性を上げるような内容、3つ目は望ましい言語の特徴（property）、つまりこの言語は直感的である、読みやすい、効率的であるといったような内容だ。しかしこれまでのプログラミング言語の提案の論文には、1と2、つまり新機能と機能の増強に関しては論文が査読されたものであるならば十分認められるものであるが、望ましい言語の特徴に関してはその主張と、それを支える根拠は両方とも提示されているが論理的な結びつきは不十分なものが多数あるとしたのだ。
 
@@ -242,11 +250,11 @@ d1 $ sound "bd*4" # gain (every 3 (rev) $ "1 0.8 0.5 0.7")
 
 # 音楽プログラミング行為のモデル化と評価語彙の提示
 
-![アンダーソンとキビラによる音楽プログラミングのモデル。](img/Anderson-model.png){width=75% #fig:andersonmodel}
+![アンダーソンとキビラによる音楽プログラミングのモデル。](../img/Anderson-model.png){width=75% #fig:andersonmodel}
 
 音楽プログラミングのプロセスをその表現の様式によらずモデル化したものとして、アンダーソンとキビラによるコンピューターを用いる音楽パフォーマンスのためのシステムを、彼らが開発したFORMULA（FORTH言語上に構築されたPLfM）を中心に分析した研究がある[@Anderson1990]。アンダーソンらは論文内で[@fig:andersonmodel]のように、コンピューターを用いた音楽生成を人間とコンピューターが作り出すフィードバックループ、いわゆるHuman In the Loopモデルとして捉えた。
 
-![Human In the Loopとしての音楽プログラミング言語の利用モデルを、言語を特徴付ける各要素、実際に現れる特徴で表した図。](img/humanintheloop_model.pdf){width=100% #fig:humanintheloop}
+![Human In the Loopとしての音楽プログラミング言語の利用モデルを、言語を特徴付ける各要素、実際に現れる特徴で表した図。](../img/humanintheloop_model.pdf){width=100% #fig:humanintheloop}
 
 このアンダーソンらのモデルにおいて、Computer Systemに相当する部分がコンパイラ、Synthesizerに相当する部分がランタイムシステムだと捉えれば、ライブコーディングのような近年の対話的プログラミングの実行モデルとしてもよく当てはまるように思える。
 
@@ -287,28 +295,28 @@ d1 $ sound "bd*4" # gain (every 3 (rev) $ "1 0.8 0.5 0.7")
 
 <!--
 綺麗な切り分けじゃなかったのでやめた
-![各特徴を編集時-実行時という観点と、空間的自由度-時間的自由度-効率性という観点で分類した図。](img/diagram2.png){width=80% #fig:diagram2} -->
+![各特徴を編集時-実行時という観点と、空間的自由度-時間的自由度-効率性という観点で分類した図。](../img/diagram2.png){width=80% #fig:diagram2} -->
 
 ## 各特徴間のトレードオフ
 
-![[@fig:humanintheloop]の図における特徴間に存在するトレードオフを表した図。](img/tradeoff.pdf){width=90% #fig:tradeoff1}
+![[@fig:humanintheloop]の図における特徴間に存在するトレードオフを表した図。](../img/tradeoff.png){width=90% #fig:tradeoff1}
 
 これら8つの特徴全てを同時に改善することは根本的に難しい。少なくとも、全ての要素を改善しようと思えばそれだけ開発のコストは増大してしまうことは直感的に納得できるだろう。それ以外に存在するトレードオフには、コンパイラからランタイムに渡される中間表現の抽象度が大きく影響してくる。
 
 [@fig:tradeoff1]でそれを説明する。この中で、学習のしやすさとコーディングコストについてはシンタックスとセマンティクスのデザイン、ドキュメンテーションやコミュニティの充実度合いに大きく影響を受け中間表現の粒度からは独立したものであるため除外して考えている。また、コンパイル時や実行時、開発時のコストに関する矢印の向きに関しては、一般的に少なくできる方が良いためLowの側に矢印を向けていることに注意されたい。
 
-![UGenインタプリタのような、粒度の大きい中間表現を用いる言語の特性を表した図。](img/tradeoff2.pdf){width=90% #fig:tradeoff2}
+![UGenインタプリタのような、粒度の大きい中間表現を用いる言語の特性を表した図。](../img/tradeoff2.png){width=90% #fig:tradeoff2}
 
-![粒度の大きい中間表現のプラットフォーム非依存性を上げようとすると開発コストが増大することを示した図。](img/tradeoff3.pdf){width=90% #fig:tradeoff3}
+![粒度の大きい中間表現のプラットフォーム非依存性を上げようとすると開発コストが増大することを示した図。](../img/tradeoff3.png){width=90% #fig:tradeoff3}
 
 まず、コンパイル時のコストと実行時コストは一般的には相補的な関係にある。なぜなら、実行時のコストの低下は一般的に、実行するプログラムの形式を機械語に近い形式へと変換する作業によってなされるためである。そのため、中間表現の粒度が大きいほどコンパイルコストは下がり、代わりに実行時のコストが嵩む。中間表現の粒度が上がるほど、コンパイル-実行という区別が付きづらいインタプリタ型の言語に近付いていくという表現もできる。
 
 また、中間表現の粒度が小さくなるほどプラットフォーム非依存性は一般的に上がっていく。例えばFaustはブロックダイアグラム代数のデータをC言語やRust、LLVM IR、WebAssemblyと言った様々な形式に変換できるため、同じコードを幅広いプラットフォームで動作させることができる。
 
 
-![Faustのような、粒度の細かい中間表現を用いる言語の特性を表した図。](img/tradeoff4.pdf){width=90% #fig:tradeoff4}
+![Faustのような、粒度の細かい中間表現を用いる言語の特性を表した図。](../img/tradeoff4.png){width=90% #fig:tradeoff4}
 
-![粒度の小さな中間表現の言語で動的変更をしやすくしようとすると開発コストが増大することを示した図。](img/tradeoff5.pdf){width=90% #fig:tradeoff5}
+![粒度の小さな中間表現の言語で動的変更をしやすくしようとすると開発コストが増大することを示した図。](../img/tradeoff5.png){width=90% #fig:tradeoff5}
 
 例えばPure DataをWeb上で動作させようとすると、ソースファイルの読み込み機能や様々な種類のUGenそれぞれをJavaScriptやWebAssemblyを用いてゼロから実装し直すという方法と、Emscriptenというツールを利用して、C言語で書かれたPure Dataのソースコードをそのまま利用してWebAssemblyのフォーマットとして改めてビルドするという2種類の方法がありうる。実際、前者はWebPd[^webpd]、後者はempd[^empd]というプロジェクトで実際に行われている。しかしWebPdのような方針の場合は実質Pure Dataというソフトウェアそのものを別の言語で作り直しているに等しいので開発のコストは非常に大きい。同様に、Emscriptenを経由してWebAssemblyを出力する場合、OSの機能を含め、C言語のソースコードではなく、ビルド済みのバイナリ形式のライブラリを利用している部分はやはり何らかの形で補う必要がある。また、どちらの場合にしても、多くのユーザーによって作られたエクスターナルオブジェクトはそのソースコードを手に入れ、改めてWebAssembly向けにビルドし直さなければ利用できない。
 
diff --git a/chapter6.md b/chapter6.md
index 81b193a..ebad1dc 100644
--- a/chapter6.md
+++ b/chapter6.md
@@ -1,3 +1,8 @@
+---
+title: 第6章 - 最小限のPLfM：mimiumの設計と実装
+draft: true
+---
+
 <!-- 第6章 音楽プログラミング言語mimiumの設計と実装 -->
 
 本章では、これまでの背景をもとに、実際に筆者が開発したプログラミング言語mimium(**mi**nimal-**m**usical-med**ium**)[^mimiumrepo]の具体的な実装について記す。
@@ -17,30 +22,21 @@ mimiumでは改めて、音楽に特化した言語ではあるが、プログ
 
 加えて、汎用言語をベースにした設計ではあるが、既存音楽のためのプログラミング言語を使っている人も参入しやすいように、UGenの概念に近い記法を可能にすることを目指した。
 
-第5章では音楽プログラミング言語の実装方法の観点から、中間表現の粒度とそれに伴う可能な表現の範囲、実行コスト、コンパイルコスト、動的変更のしやすさ、開発コストなどの要素にトレードオフの関係があることを示した。この中でmimiumは中間表現の粒度が比較的細かく、そのためにライブコーディングのような動的変更の機能は実装の難易度が上がることが予想されたため、あらかじめ重視しないで作っている（mimiumの選択が[@fig:tradeoff4]だとすれば、相対的にExtemporeが[@fig:tradeoff5]にあたる）。
-
-\begin{table*}[htb]
-  \caption{mimiumと既存の言語の仕様比較。}
-\label{langcomparison}
-\newcolumntype{C}[1]{>{\hfil}m{#1}<{\hfil}}
-\begin{tabular}{m{0.3\textwidth}ccccccc}
-    \toprule  
-                            & Pd/SC      & ChucK      & Extempore & Faust       &   Vult     &  Kronos  & mimium  \\
-    \midrule 
-    スケジューラ               & $\bigcirc$ & $\bigcirc$& $\bigcirc$ &     -      &     -      & $\bigcirc$ & $\bigcirc$ \\
-    \cmidrule[0.2pt](lr){2-8}
-    サンプル精度スケジューリング &     -      & $\bigcirc$ & $\bigcirc$ &     -      &     -      & $\bigcirc$ & $\bigcirc$ \\
-    \cmidrule[0.2pt](lr){1-8}
-    低レベルなUGenの定義       &     -      & $\bigcirc$ & $\bigcirc$ & $\bigcirc$ & $\bigcirc$ & $\bigcirc$ & $\bigcirc$\\
-    \cmidrule[0.2pt](lr){2-8}
-    DSPコードのJITコンパイル    &     -      &     -     & $\bigcirc$ & $\bigcirc$ & $\bigcirc$ & $\bigcirc$ & $\bigcirc$\\
-    \cmidrule[0.2pt](lr){2-8}
-    UGen内部状態の関数型表現    &     -      &     -     &      -     & Graph & \lambda 計算 & Graph & \lambda 計算 \\
-    \bottomrule
-\end{tabular}
-\end{table*}
-
-表\ref{langcomparison} はmimiumと既存の主要な音楽プログラミング言語の仕様を比較したものである。mimiumは時間方向に離散的な制御の記述と、信号処理と1つのセマンティクスで実現している。信号処理の実行速度はJIT（実行時）コンパイルを用いることでC++などの低レベル言語での記述と同等にしている。またユーザーはメモリーの確保、開放のようなハードウェアの意識をする必要がない。
+第5章では音楽プログラミング言語の実装方法の観点から、中間表現の粒度とそれに伴う可能な表現の範囲、実行コスト、コンパイルコスト、動的変更のしやすさ、開発コストなどの要素にトレードオフの関係があることを示した。この中でmimiumは中間表現の粒度が比較的細かく、そのためにライブコーディングのような動的変更の機能は実装の難易度が上がることが予想されたため、あらかじめ重視しないで作っている（mimiumの選択が[第5章のトレードオフの図4つ目](../chapter5_rendered#tradeoff4)だとすれば、相対的にExtemporeが[5つ目の図](../chapter5_rendered#tradeoff5)にあたる）。
+
+
+|                        | Pd/SC | ChucK| Extempore | Faust |Vult  |Kronos|mimium |
+| :----                  | :----:|:----:| :----:    |:----: |:----:|:----:|:----:|
+|スケジューラ              |◯      | ○    | ○         |   -   |  -   |○     | ○     |
+|サンプル精度スケジューリング |     - | ○    | ○        |     -  |  -   |○     |   ○   |
+|低レベルなUGenの定義       |     - | ○    | ○        | ○     | ○     |○     |    ○  |
+|DSPコードのJITコンパイル    |     - |  -   | ○        | ○     | ○     |○     |    ○  |
+|UGen内部状態の関数型表現    |    -  |   -  |   -      | Graph | λ計算 | Graph | λ計算 | 
+
+: mimiumと既存の言語の仕様比較。 {#tbl:langcomparison}
+
+
+[@tbl:langcomparison] はmimiumと既存の主要な音楽プログラミング言語の仕様を比較したものである。mimiumは時間方向に離散的な制御の記述と、信号処理と1つのセマンティクスで実現している。信号処理の実行速度はJIT（実行時）コンパイルを用いることでC++などの低レベル言語での記述と同等にしている。またユーザーはメモリーの確保、開放のようなハードウェアの意識をする必要がない。
 
 また低レベルなUGenの定義が言語上で可能ではあるものの、その内部表現はFaustやKronosの採用するグラフ表現と異なり、ラムダ計算をベースにしたフォーマットである。
 
@@ -54,7 +50,7 @@ mimiumでは改めて、音楽に特化した言語ではあるが、プログ
 
 mimiumの基本的なシンタックスは、Rust[@Klabnik2020]をベースにした。シンタックスの選択は常に**すでにある程度普及している言語体系**を眺めた上で設計せざるを得ない。Rustの構文は予約語が比較的短いので音楽のように素早くプロトタイピングを行う分野に適していることが主な理由である。また、既存の言語の構文と似せると、既存の言語のためのシンタックスハイライト（ソースコードを色分けして見やすくするためのツール）を再利用しやすいという副次的効果も得られる。
 
-\begin{lstlisting}[float,floatplacement=Htb,language=Rust,style=mystyle,caption=mimiumの基本的なシンタックスの説明。,label=lst:mimiumbasic]
+```rust
 //コメントはダブルスラッシュ
 //新しい名前の変数への代入が変数宣言になる
 mynumber = 1000 
@@ -99,15 +95,20 @@ fn fact(input){
 }
 // if文は式としても使える
 fact = |input|{ if(input>0) 1 else input * fact(input-1) }
-\end{lstlisting}
+```
+
+: mimiumの基本的なシンタックスの説明。 {#lst:mimiumbasic}
 
-\begin{lstlisting}[float,floatplacement=Htb,language=Rust,style=mystyle,caption=mimiumでの、1chの入力を2chに複製して返却する\texttt{dsp}関数の例。,label=lst:dsp]
+
+```rust
 fn dsp(input:(float,float)) ->(float,float){
 	left,right = input
 	out = (left+right)/2
 	return (out,out)
 }
-\end{lstlisting}
+```
+
+: mimiumでの、1chの入力を2chに複製して返却する`dsp`関数の例。 {#lst:dsp}
 
 [@lst:mimiumbasic]に基本的な言語仕様を示す。BNFによる形式的な言語仕様定義は付録\ref{sec:appendA}にて示した。
 変数の宣言は、関数のスコープ内で新しい名前の変数に何らかの値を代入することで自動的に行われる。変数を宣言する際には、コロンの後に型名を記述することで、値の型を明示的に指定できる。型名が省略された場合は、文脈から型を推測可能である。データ型には、`void`（空の値の型）、`float`（整数、浮動小数点型の区別はなく、内部的にはデフォルトで64bit-float）、`string`といったプリミティブな型のほか、任意の型の値を受け取り任意の型の値を返す`function`、任意の型を列挙する型である`tuple`、任意の型の有限長配列`array`といった合成型がある。また、ユーザー定義の型エイリアスを宣言もできる。
@@ -135,9 +136,9 @@ mimiumには組み込み関数として、基本的な算術演算、libcの *ma
 
 ソースコードのテキストデータは、まず抽象構文木（AST）に解析され、シンタックスシュガーを変換した後、ASTはラムダ計算ベースの木構造に変換される。次に、型推論、型検査を行い、すべての変数の型を決定する。ASTは、型情報とともに、すべての変数が一度だけ割り当てられる静的単一代入（SSA）形式の中間表現に変換される。この段階ではまだ関数の入れ子定義が可能になっているので、関数定義から自由変数を取り除くためにクロージャ変換が行われる。
 
-クロージャ変換と低レベルコード（LLVM IR：LLVMで利用される、C言語とアセンブリ言語の中間程度の抽象度を持つ形式）の生成器の間には、mimiumの独自仕様である状態を伴う関数関数（[@sec:statefulfun]）のための状態変数の検出を行う。この変換では、`dsp`関数を信号処理のエントリポイントとして、関数が使用する状態変数を、呼び出された状態付き関数名のノードと関数内で使われる状態変数の型を持つ木構造（図中の*State Tree*）のデータとして出力する。最後に、クロージャ変換されたIRとState TreeをもとにLLVM IRを生成する。
+クロージャ変換と低レベルコード（LLVM IR：LLVMで利用される、C言語とアセンブリ言語の中間程度の抽象度を持つ形式）の生成器の間には、mimiumの独自仕様である状態を伴う関数（[@sec:statefulfun]）のための状態変数の検出を行う。この変換では、`dsp`関数を信号処理のエントリポイントとして、関数が使用する状態変数を、呼び出された状態付き関数名のノードと関数内で使われる状態変数の型を持つ木構造（図中の*State Tree*）のデータとして出力する。最後に、クロージャ変換されたIRとState TreeをもとにLLVM IRを生成する。
 
-![mimiumのコンパイラとランタイムのアーキテクチャの構成。](img/mimium-arch-v4-affinity.pdf){width=100% #fig:arch}
+![mimiumのコンパイラとランタイムのアーキテクチャの構成。](../img/mimium-arch-v4-affinity.png){width=100% #fig:arch}
 
 ランタイムは、LLVM IRを受け取り、メモリ上でネイティブバイナリにコンパイルするJIT実行エンジン、オーディオデバイスとの入出力通信を行うオーディオドライバ、時間指定実行された関数とその論理時間の情報を保持するスケジューラの3つの部分で構成される。現在、オーディオドライバーには、オーディオデバイスをOSのAPIで抽象化したC++用のクロスプラットフォームライブラリRtAudio[@Scavone2002]を使用している。実行エンジンは、信号処理のエントリーポイントである`dsp`関数をオーディオドライバーに渡す。オーディオドライバーは、ハードウェアからの要求を基にスケジューラーに論理時間を進めるように命令し、スケジューラは、論理時間に基づいてタスクを実行したり、実行されているプログラムからタスクの登録の要求への応答、内部時間(`now`)をプログラムへ返す役割を担う。
 
@@ -147,7 +148,7 @@ LLVM IRまで変換されたコードの中では、タスクの登録と、内
 
 ## `@`演算子によるスケジューリング
 
-\begin{lstlisting}[float,floatplacement=Htb,language=Rust,style=mystyle,caption=mimiumにおける継時再帰のサンプル,label=lst:tr-mimium]
+```rust
 ntrigger = 1
 fn setN(val:float){
     ntrigger = val
@@ -162,13 +163,15 @@ fn Nloop(period:float)->void{
     Nloop(period)@(now+nextperiod) 
 }
 Nloop(12000)
-\end{lstlisting}
+```
+
+: mimiumにおける継時再帰のサンプル {#lst:tr-mimium}
 
 mimiumで時間方向に離散的に発生するイベントを記述するには、Impromptu（Extemporeの前身）で導入され、Overtone[@Aaron2013]やKronos Meta-Sequener[@Norilo2016]といった言語などでも利用されてきた、継時再帰（**Temporal Recursion**[@Sorensen2010]）と呼ばれるデザインパターンを用いる。継時再帰は、一定時間後に関数を呼び出す機能を用いて、ある関数の中で自分自身を一定の遅延とともに再帰的に呼び出すことで、時間とともに繰り返すイベント処理の記述を可能にするものである。
 
 [@lst:tr-mimium]に具体的な例を挙げる。関数呼び出しに続けて`@`演算子、さらにその後ろに数値型の式を置くと、その関数はすぐには実行されない。代わりに、時間をキーとした優先順位付きタスクキューに登録され、実行コンテキストは次の文に移る。ランタイムは、オーディオドライバのクロックを基にして、各サンプルを処理する前にタスクキューをチェックし、先頭の要素のキーが現在の論理時間に達していれば、それらを先に実行する。時刻は、ランタイム実行を開始を0とした絶対時刻（単位は現在のところサンプル）となっているが、キーワード`now`を用いてランタイムから現在の論理的な時間を取得し相対的な時間を記述できる。
 
-\begin{lstlisting}[float,floatplacement=Htb,language=Scheme,style=mystyle,caption=コード\ref{lst:tr-mimium}と等価なコードをExtemporeで記述したもの,label=lst:tr-extempore]
+```lisp
 (define ntrigger 1)
 (define setN
     (lambda (val)
@@ -182,7 +185,9 @@ mimiumで時間方向に離散的に発生するイベントを記述するに
         (playN 50)
         (callback (+ (now) (if (random > 0) (/ period 2) period)) 'Nloop period)))
 (Nloop 12000)
-\end{lstlisting}
+```
+
+: [@lst:tr-mimium]と等価なコードをExtemporeで記述したもの {#lst:tr-extempore}
 
 [@lst:tr-mimium]の場合、`ntrigger`という変数は、`Nloop`という関数が呼ばれるたびに書き換えられる。
 `Nloop`は自分自身を乱数によって不定期な間隔で再帰的に実行し続けるようになっている。継時再帰はこのように、言語仕様への最小限の機能追加で、様々なタイミングでのイベント実行を可能にする機能である。
@@ -218,7 +223,7 @@ mimiumは信号処理専用のデータ型を作らなくても、UGenを通常
 オブジェクトとは、メンバー変数のセットと、変数を変更したり他のオブジェクトにメッセージを送ったりするメンバー関数（メソッド）のセットを含むデータ構造である。オブジェクトの場合、内部状態はメンバ定数として定義されている。これを利用するには、あらかじめインスタンス化した上で、メインの処理メソッドを呼び出す必要がある。[@lst:cppexample]にC++言語でのオブジェクトを用いたphasorの表現の例を示す。
 
 
-\begin{lstlisting}[float,floatplacement=H,language=c++,style=mystyle,label=lst:cppexample,caption=phasorをC++のオブジェクトを用いて表現した例.]
+```rust
 class Phasor{
   double out_tmp=0;
   double process(double freq){
@@ -236,7 +241,10 @@ double something(){
   //use instantiated objects
   return phasor1.process(phasor2.process(10) + 1000);
 }
-\end{lstlisting}
+
+```
+
+: phasorをC++のオブジェクトを用いて表現した例. {#lst:cppexample}
 
 #### クロージャ
 
@@ -246,7 +254,7 @@ double something(){
 
 [@lst:closure]にクロージャを用いたphasorの表現をJavaScriptでの疑似コードで示す。変数`out_tmp`は最終的に返却される関数`process`の中に閉じ込められている。`makePhasor`関数を実行することはC++における`Phasor`クラスの初期化処理（コンストラクタ）の実行に相当している。JavaScriptは内部的にガベージコレクションなどを利用する言語のため実際にこのコードを利用することは難しいが、命令型ベースの読みやすいシンタックスを持ち、かつクロージャを利用可能な言語であるため例示のために用いている。
 
-\begin{lstlisting}[float,floatplacement=H,language=c++,style=mystyle,caption=phasorのクロージャを用いた表現をJavaScriptによる疑似コードで表したもの,label=lst:closure]
+```js
 //pseudo-code in javascript
 function makePhasor(tmpinit){
   let out_tmp = tmpinit;
@@ -265,7 +273,9 @@ let phasor2 = makePhasor(1);
 function something(){
   return phasor1(phasor2(10) + 1000);
 }
-\end{lstlisting}
+```
+
+: phasorのクロージャを用いた表現をJavaScriptによる疑似コードで表したもの {#lst:closure}
 
 
 #### 関数型の表現
@@ -276,19 +286,21 @@ FaustやKronosの信号処理の記述では、一時変数の読み書きなし
 
 これらの言語ではそれぞれ、Faustではそれぞれ0以上の入出力を持つUGen（定数は入力0、出力が1つの関数、`+`演算子は入力が2つで出力が1つの関数、のように）、KronosではUGenの入出力がリストとしてシンボル化されており、通常の言語のように、記号が特定のメモリアドレス上のデータに対応しているわけではない。そのためこれらの言語に汎用言語と同等の自己拡張性を期待することは難しい。
 
-\begin{lstlisting}[float,floatplacement=Htb,style=mystyle,language=Rust,caption=Faustでのphasor関数の定義の例。,label=lst:faust]
+```rust
 phasor(freq) = +(freq/4800) ~ out_tmp
 	with{
         out_tmp = _ <: select2(>(1),_,0);
  };
 // no need to instantiate.
 something = phasor(phasor(10)+1000);
-\end{lstlisting}
+```
+
+: Faustでのphasor関数の定義の例。 {#lst:faust}
 
 
 Vult言語[@Ruiz2020]では、関数定義において、通常の変数宣言である`var`ではなく、キーワード`mem`で変数を宣言すると、破壊的変更された値が時系列で保持され、UGenの内部状態を表現できる。この機能により、Faustと同じくあらかじめインスタンス化しておく必要がなく、通常の関数適用として、内部状態を持つUGenの接続を表現できる。
 
-\begin{lstlisting}[float,floatplacement=Htb,style=mystyle,language=Rust,caption=Vult言語でのphasor関数の定義の例。,label=lst:vult]
+```rust
 fun phasor(freq){
 	mem out_tmp;//"mem" variable holds its value over times
   out_tmp = out_tmp+freq/48000;
@@ -301,7 +313,9 @@ fun something(input){
 // no need to instantiate.
   return phasor(phasor(10)+1000);
 }
-\end{lstlisting}
+```
+
+: Vult言語でのphasor関数の定義の例。 {#lst:vult}
 
 Faust、Vultともに、内部状態を持つ関数は、最初にインスタンスを作成することなく仕様できる。その代わり、内部状態の初期化は関数定義時に決定され、インスタンス作成時にコンストラクタを介して初期値を決定するような操作はできない。
 
@@ -309,17 +323,19 @@ Faust、Vultともに、内部状態を持つ関数は、最初にインスタ
 
 ### 内部状態つき関数による信号処理 {#sec:statefulfun}
 
-\begin{lstlisting}[float,floatplacement=htb,language=Rust,style=mystyle,caption=mimiumでの1サンプルごとに1増加するカウンター関数の例。,label=lst:counter]
+```rust
 fn counter(){
   return self+1
 }
-\end{lstlisting}
+```
+
+: mimiumでの1サンプルごとに1増加するカウンター関数の例。 {#lst:counter}
 
 こうした様々なUGenの内部表現の例を基に、mimiumでは、内部状態付き関数をUGenのように利用できる文法を導入した。これらの関数は、Vultと同じように、通常の関数適用`f(x)`と同じシンタックスで呼び出せる。その上でFaustのように`delay`などの限られた組み込み状態付き関数を使うことで、ユーザーは内部状態の変数の宣言を行う必要がない。さらに、汎用言語の場合と同様に、変数をメモリ上のデータとしてシンボル化する体系は崩していない。
 
 また、関数定義の中でキーワード`self`を使うことで、1サンプル前の時刻でその関数が返した戻り値を参照することができ、UGenの再帰的な接続を表現することを可能にしている。`self`は、関数定義の中でのみ使用できる予約語で、時刻0では0で初期化され、関数の前回の戻り値を得ることができる。[@lst:counter]に最もシンプルな`self`の使い方として、1サンプルごとに1増加するようなカウンターの関数の例を示した。
 
-\begin{lstlisting}[float,floatplacement=H,language=Rust,style=mystyle,caption=mimiumでのphasor関数の記述例。,label=lst:phasormimium]
+```rust
 fn phasor(freq){
   res = self + freq/48000 // assuming the sample rate is 48000Hz
   return if (res > 1) 0 else res
@@ -327,7 +343,9 @@ fn phasor(freq){
 fn dsp(input){
   return phasor(440)+phasor(660)
 }
-\end{lstlisting}
+```
+
+: mimiumでのphasor関数の記述例。 {#lst:phasormimium}
 
 `self`を用いると、これまでオブジェクトやクロージャといった例で見てきたUGenの`phasor`をmimium上で定義することができる。例を[@lst:phasormimium]に示した。この例では、ユーザーは状態変数の宣言の必要も、関数を利用する際のインスタンス化の必要もないことがわかる。
 FaustでUGenの再帰的接続の表現のための中置演算子`~`が式の中で何度も利用できるのに比べて、mimiumでは再帰接続の単位は自然と関数定義の単位に分割される。
@@ -338,7 +356,7 @@ FaustでUGenの再帰的接続の表現のための中置演算子`~`が式の
 
 これに相当するものを、Faustでは[@lst:pipefaust]、Cycling'74 Maxでは図[@fig:maxexample]で示す。Faustの直列接続演算子(`:`)の他にも、ChucK言語のChucK演算子(`=>`)など、他の言語でも似たような機能を持つものはあるが、パイプライン演算子は、セマンティクスとしては通常の関数呼び出しと区別されない点が特徴である。
 
-\begin{lstlisting}[float,floatplacement=H,label=lst:pipeline,language=Rust,style=mystyle,caption=mimiumでのパイプライン演算子の利用例。]
+```rust
 fn scaleTwopi(input){
   return input* 2 * 3.141595
 }
@@ -348,21 +366,26 @@ fn osc(freq){ //normal function call
 fn osc(freq){ //pipeline operator version
   return freq |> phasor |> scaleTwopi |> cos
 }
-\end{lstlisting}
+```
 
-\begin{lstlisting}[float,floatplacement=H,label=lst:pipefaust,style=mystyle,caption=Faustでの直列接続演算子（:）の利用例]
+: mimiumでのパイプライン演算子の利用例。 {#lst:pipeline}
+
+```rust
 scaleTwopi(input) = input * 2 * 3.141595;
 osc(freq) = freq:phasor:scaleTwopi : cos;
-\end{lstlisting}
+```
+
+: Faustでの直列接続演算子（:）の利用例 {#lst:pipefaust}
 
+![Maxでのデータフロー的表現の例。](../img/max-osc-example.png){#fig:maxexample}
 
-\begin{figure}[h]
+<!-- \begin{figure}[h]
   \centering
   \includegraphics[width=0.7\columnwidth]{img/max-osc-example.png}
   \caption{Maxでのデーターフロー的表現の例。}
   % \Description{Example of dataflow syntax in Max}
   \label{fig:maxexample}
-\end{figure}
+\end{figure} -->
 
 ### 状態付き関数のコンパイル手順
 
@@ -373,7 +396,7 @@ osc(freq) = freq:phasor:scaleTwopi : cos;
 
 この時の状態変数を明示的に引数として渡すように変換した後の疑似コードを [@lst:fbdelayafter]に示す。`fbdelay`関数やそれを呼び出す`dsp`関数の引数の先頭にそれぞれ内部状態が渡されている。
 
-\begin{lstlisting}[float,floatplacement=Htb,label=lst:fbdelay,language=Rust,style=mystyle,caption=mimiumでのフィードバックディレイのコード例。]
+```rust
 // delay is a built-in stateful function
 fn fbdelay(input,time,fb){
     return delay(input+self*fb,time) 
@@ -384,9 +407,11 @@ fn dsp(){
     out = fbdelay(src,1000,0.8)+ fbdelay(src,2000,0.5)
     return (out,out)
 }
-\end{lstlisting}
+```
+
+: mimiumでのフィードバックディレイのコード例。 {#lst:fbdelay}
 
-\begin{lstlisting}[float,floatplacement=Htb,label=lst:fbdelayafter,language=Rust,style=mystyle,caption=\ref{lst:fbdelay}の内部状態付き関数の変換処理後の疑似コード]
+```rust
 // pseudo-code after lifting stateful function
 fn fbdelay(state,input,time,fb){
   //unpack state variables
@@ -400,7 +425,9 @@ fn dsp(state){
     out = fbdelay(s_fbdelay0,src,1000,0.8) +fbdelay(s_fbdelay1,src,2000,0.5)
     return (out,out)
 }
-\end{lstlisting}
+```
+
+: [@lst:fbdelay]の内部状態付き関数の変換処理後の疑似コード {#lst:fbdelayafter}
 
 ## 言語仕様の整理、既存の言語との比較
 
@@ -418,7 +445,7 @@ Kronos（とMeta-Sequencer）も同様に自己拡張性を重視した言語で
 
 # 現状の実装の問題点
 
-\begin{lstlisting}[float,floatplacement=H,label=lst:frp,language=Rust,caption=mimiumの現在の実装ではコンパイル不可能な、時間方向に離散的に変化する値を関数として抽象化するコードの例。]
+```rust
 fn frp_constructor(period){
 	n = 0
 	modifier = |x|{
@@ -431,10 +458,12 @@ fn frp_constructor(period){
 }
 val = frp_constructor(1000)
 event_val = val()
-\end{lstlisting}
+```
+
+: mimiumの現在の実装ではコンパイル不可能な、時間方向に離散的に変化する値を関数として抽象化するコードの例。 {#lst:frp}
 
 
-\begin{lstlisting}[float,floatplacement=H,label=lst:filterbank,language=Rust,caption=mimiumの現在の実装ではコンパイル不可能な、内部状態を持つ関数のパラメトリックな複製のコード例。]
+```rust
 fn filterbank(N,input,lowestfreq, margin,Q,filter){
 	if(N>0){
 		return filter(input,lowestfreq+N*margin,Q)
@@ -442,7 +471,9 @@ fn filterbank(N,input,lowestfreq, margin,Q,filter){
 	}else{
 		return 0
 	}}
-\end{lstlisting}
+```
+
+: mimiumの現在の実装ではコンパイル不可能な、内部状態を持つ関数のパラメトリックな複製のコード例。 {#lst:filterbank}
 
 現状mimiumを実用的に利用する際に3つの問題点が残っている。1つは離散的なイベントの記述は命令型、信号処理は関数型のパラダイムという2つの記法のミスマッチ、2つ目は信号処理に用いる状態付き関数をパラメトリックに複製できないこと、最後がFFTに代表されるサンプルをあるまとまった数ごとに処理をする信号処理が記述できないことだ。
 
@@ -481,22 +512,24 @@ mimiumの信号処理は1サンプルごとの処理の記述によって表現
 
 [^wcalculus]: *W*計算はフィルタのような線形時不変（Linear Time-Invariant:LTI）システムの実質的等価性を形式的に証明することを1つの目的としている。そのため厳密に言えば基本的演算に式同士の加算と、式と定数の乗算（スケーリング）のみが許されており、式同士の乗算などは許されない。しかし基本的な演算の項を追加すれば非線型システムにも対応はできる。
 
-\begin{lstlisting}[label=lst:wcalc,language=Rust,style=mystyle,caption=mimiumでの引数\texttt{incl}サンプルずつ増加するカウンター]
+```rust
 fn counter(incl:float){
     return self+incl
 }
-\end{lstlisting}
+```
+
+: mimiumでの引数`incl`サンプルずつ増加するカウンター {#lst:wcalc}
+
 
-<!-- 
 $$
 \lambda \ incl.feed \ self.(incl+self)
-$$ 
--->
+$${#eq:label}
+
 
-\begin{equation}
+<!-- \begin{equation}
 \lambda \ incl.feed \ self.(incl+self)
 \label{eq:label}
-\end{equation}
+\end{equation} -->
 
 W計算では*feed*の項の他に、式の過去のサンプルの参照、つまりディレイに相当する処理も基本操作として備えている。こうした過去のサンプルへの参照は、実用的には過去のサンプル全てを保存しなければならず、ほぼ無限のメモリを必要としてしまう問題がある。この問題は、Chronicが簡潔なデータ表現を可能にはなってはいるものの、リアルタイム実行が難しくなっていた理由の1つでもある。
 
diff --git a/chapter7.md b/chapter7.md
index 6373e7c..53520ac 100644
--- a/chapter7.md
+++ b/chapter7.md
@@ -1,4 +1,14 @@
-\epigraph{とってかわるべきシステムとは、人間が自己の自由と創造性とを責任をもってひきうけるシステムのことである。}{『\citetitle{Attali1983}』\\ \citep[p144]{Attali1983}}
+---
+title: 第7章 - 結論：音楽土木工学とは何なのか、どこへ向かうのか
+draft: true
+---
+
+<!-- \epigraph{とってかわるべきシステムとは、人間が自己の自由と創造性とを責任をもってひきうけるシステムのことである。}{『\citetitle{Attali1983}』\\ \citep[p144]{Attali1983}} -->
+
+> とってかわるべきシステムとは、人間が自己の自由と創造性とを責任をもってひきうけるシステムのことである。
+> [@Attali1983,p144]
+
+
 <!-- 第7章 議論-->
 
 本論文では、音楽のためのプログラミング言語の設計という実践を例にとりつつ、既存の工学的実践とは異なる学術研究として位置付けることを試みてきた。序章で既に述べたように、本研究は実践のなかで得られた思考を歴史的背景の描き方にフィードバックする循環的なプロセスを取っている。mimiumの実装についての具体的な記述を終えたいま、改めてその背景を振り返り、音楽土木工学という学問を打ち立てることにどういった意味合いがあるのかについて議論する。
@@ -29,7 +39,7 @@ HCIやそこから派生したNIMEのようなコンピューターを用いた
 
 テクノロジーの誤用によってその可能性をより広げるというアプローチや、ダンとレイビーがスペキュラティブ・デザインで掲げたような（そして元々はサイモンが「システムの科学」で提言したような）、「世界をより好ましい方向へ近づける」という未来への指向は、どちらも近傍探索にしかなりえないという意味で共通している。だが、もっとも好ましい未来が必ずしも近傍に存在しているとは限らない。こうした近傍探索的アプローチと、本研究の考え方の違いを表したのが[@fig:wildpath]である。
 
-![分岐するテクノロジーに対して、テクノロジーの意図的誤用という方法論と、あり得たかもしれない現在へのけもの道を作るという本研究の立ち位置の違いを概念化した図。[@Auger2010]、[@Buechley2011]、[@Dunne2015]をもとに作図。](./img/wildpath.pdf){#fig:wildpath width=100%}
+![分岐するテクノロジーに対して、テクノロジーの意図的誤用という方法論と、あり得たかもしれない現在へのけもの道を作るという本研究の立ち位置の違いを概念化した図。[@Auger2010]、[@Buechley2011]、[@Dunne2015]をもとに作図。](../img/wildpath.png){#fig:wildpath width=100%}
 
 過去への探索を行うことで、わたしたちはありえたかもしれない現在（Alternative Present）の社会の姿を想像することができる。その、ありえたかもしれない現在へと向かうための具体的行動としてのデザインこそが、音楽土木工学という学問の本質—**舗装された道の間にけもの道を作ること**である。それは、現在のテクノロジーの使われ方から見れば単なる誤用に映るかもしれないが、より遠くの具体的な目標へと向かうための行動かどうかという点で異なっている。
 
@@ -62,9 +72,9 @@ HCIやそこから派生したNIMEのようなコンピューターを用いた
 つまり、音楽のためのプログラミング言語を作るという作業は、ひとつの言語の表現力を高めていこうとすると最終的に「音楽のためのライブラリを作りやすい汎用言語を作る」と「その言語上でライブラリを作る」という2つの行為へと分裂してしまう。そして、両者で求められるスキルや関心も大きく異なるものとなってしまい、ある意味ではMulti-Languageパラダイムよりも一層分業化を進めてしまうのである。
 
 
-![従来のMulti-Languageパラダイムに基づく言語におけるプログラミングの学習経験の差を「いびつな階段」 として概念的に表した図。](img/ladder1.pdf){#fig:ladder1 width=80%}
+![従来のMulti-Languageパラダイムに基づく言語におけるプログラミングの学習経験の差を「いびつな階段」 として概念的に表した図。](../img/ladder1.png){#fig:ladder1 width=80%}
 
-![mimiumのようなブラックボックスを減らし、ライブラリとしての実装の役割を広げた言語における学習経験の差を「突然急になる坂」 として概念的に表した図。](img/ladder2.pdf){#fig:ladder2 width=80%}
+![mimiumのようなブラックボックスを減らし、ライブラリとしての実装の役割を広げた言語における学習経験の差を「突然急になる坂」 として概念的に表した図。](../img/ladder2.png){#fig:ladder2 width=80%}
 
 それゆえ、音楽のための道具を自らの手で作れるような環境づくりに、音楽様式をなるべく埋め込まないようなPLfMの設計は必要であるとはいえるが、それだけでは必要十分条件にはならない。どのみち、メタメディアとしてコンピューターを利用するためには、ユーザー（プログラマー）がコンピューターという装置の仕組みや、プログラミング言語がどのように動いているかを理解する必要が出てくる。
 
@@ -135,7 +145,7 @@ HCIやそこから派生したNIMEのようなコンピューターを用いた
 
 ## コンピューター音楽の実践的歴史研究の必要性
 
-[@sec:mediaarch]で述べたとおり、第4章におけるPLfMの歴史の批判的検証は、一次資料の新たな発見よりも既存の資料の再編成に重きを置いていた。それゆえ、既にある文献を繋ぎ直すという形を取ることで、既存の視点とは異なる描き方をしてはいるものの、依然として大学や研究所、企業、そこで活動していた人を中心とした描き方にならざるを得なかった。これは、ロスナーが批判的奇譚づくりで特定の個人のストーリーに基づく技術史観へ警鐘を鳴らしたように、今後の音楽に関わるテクノロジー史の批判的再構築における重要な課題と言える。
+[第2章](../chapter2_rendered#mediaarch)で述べたとおり、第4章におけるPLfMの歴史の批判的検証は、一次資料の新たな発見よりも既存の資料の再編成に重きを置いていた。それゆえ、既にある文献を繋ぎ直すという形を取ることで、既存の視点とは異なる描き方をしてはいるものの、依然として大学や研究所、企業、そこで活動していた人を中心とした描き方にならざるを得なかった。これは、ロスナーが批判的奇譚づくりで特定の個人のストーリーに基づく技術史観へ警鐘を鳴らしたように、今後の音楽に関わるテクノロジー史の批判的再構築における重要な課題と言える。
 
 特に、すでにハードウェアが現存していないシステムについては論文やマニュアルの内容を基にしか記述できず、実際のところどう動いていたのかという実践的な知識に関しては多くは検証できていない。たとえばMUSIC Vのプログラムは後にショットステッド（Common Lisp Musicの開発者）によりgfortranで書き直され、ラッザリーニによりソースコード共有サイトGitHub上で公開されている[^musicvg]。 しかし、MUSIC Vが実際に使われていた当時の、プログラムを1行ごとにパンチカードで打ち込んでいたようなプログラミングのプロセスと、数分の音声ファイルを作るための計算にかかった数時間という長さを考慮せずにMUSIC Vについて本当に理解したと言えるのだろうか。まして、音響遅延線メモリーの仕組みを活用して作られていた1950年代初頭の音楽生成など、エミュレーターを用いてもそのメモリの時間遅延は再現されないため、ハードウェアを再構築しない限り再現不可能である。
 
@@ -147,7 +157,7 @@ HCIやそこから派生したNIMEのようなコンピューターを用いた
 
 ## フォーマットとしてのPLfMの再考
 
-[@sec:plfm1990]で見たように、1990年代以降にソフトウェアベースのリアルタイム音声合成が可能になったことによって、PLfMには単なる制作の道具としてだけでなく、音楽を届けるためのフォーマットとしての側面も現れてきた。しかし、トップダウン的に作られたSAOLのような標準規格は結局ほとんど普及することなく、ボトムアップ的に自然発生したSuperColliderにおけるSC140のような短いコードとしての音楽流通も、ライブコーディング文化の隆盛とクロスフェードするように陰りを見せている。だがFaustやKronosなど、より細かい粒度での形式的抽象化の研究が進んだ今、改めてPLfMのソースコードを音楽を配布するためのフォーマットとして機能させるような利用可能性は無いのだろうか？
+[第4章](../chapter4_rendered#plfm1990)で見たように、1990年代以降にソフトウェアベースのリアルタイム音声合成が可能になったことによって、PLfMには単なる制作の道具としてだけでなく、音楽を届けるためのフォーマットとしての側面も現れてきた。しかし、トップダウン的に作られたSAOLのような標準規格は結局ほとんど普及することなく、ボトムアップ的に自然発生したSuperColliderにおけるSC140のような短いコードとしての音楽流通も、ライブコーディング文化の隆盛とクロスフェードするように陰りを見せている。だがFaustやKronosなど、より細かい粒度での形式的抽象化の研究が進んだ今、改めてPLfMのソースコードを音楽を配布するためのフォーマットとして機能させるような利用可能性は無いのだろうか？
 
 実際、この問いはPLfMとは一見関係無い分野の発展も踏まえ、改めて考える必要があるものになりつつある。それは、空間音響のためのオブジェクトベースドフォーマットの存在である。オブジェクトベースドオーディオとは、映画館のような、建物ごとに異なるスピーカー配置がされている中で空間音響の定位、をより明瞭にするため作られたフォーマットの1つである。そのフォーマットは、スピーカーごとに割り当てられた音声だけではなく、モノラル音源と3D仮想空間上の時間とともに変化する位置のメタデータを組み合わせた形式を取っている[@Shirayanagi2017]。このオブジェクトベースドオーディオを採用したフォーマットとして最も有名なものがDolby Atmosと呼ばれるフォーマットである。Dolby Atmosは近年では映画だけでなく音楽ストリーミングサービスにおける配信でも採用され、ヘッドトラッキング（頭の向きをセンサーで検出する）機能やバイノーラル処理[^binaural]を持つヘッドホンと組み合わせると、頭の向きに合わせて音源の向きがインタラクティブに変化するような聞き方も可能になっている[^applemusic]。
 
diff --git a/chapter7_memo.md b/chapter7_memo.md
deleted file mode 100644
index 4bdff1b..0000000
--- a/chapter7_memo.md
+++ /dev/null
@@ -1,79 +0,0 @@
-
-例えば、Pucketteはサンプリング理論に対する不満、と名付けた論考の中で、連続領域で（例えば微分方程式などの形で）構築した楽器や電気回路の数学的モデルを離散化してから計算するような例を挙げ、すべての表現がサンプリング理論に基づく、各時刻における音圧に対応した数値を計算するような音楽表現には一定の限界があることを指摘している[@Puckette2015]。たしかに、プログラミング言語を使うということは、シンボルを組み合わせることである（ときには実在しないかもしれない）現象のモデルを記述し、それをコンピューターに実行させているということなのだから、例えばバネ–マス–ダンパといったシンボルを組み合わせてある力学系のモデルをテキストとして記述することは、モデルが連続領域であろうと離散領域であろうと可能だし、連続領域のモデルとして記述されたシンボルの組み合わせを離散化する関数に通し、信号処理に利用する、といった方法の記述は1つのソースコードの中に収めることも可能なはずだ(実際、Wolframのような数値計算のための言語ではまさにそのような記述が可能である[^wolfram])。これもやはり、モデルを離散化するという計算が大抵はコンパイルしたタイミングで発生しており、いつ計算するかの意味論が存在しないことにより、連続領域のモデル記述は一度離散化したデータを読み込むといったプロセスを経なければ記述ができないという見方ができるだろう。この考え方をもう少し進めれば、例えば微分方程式のモデルを記述する、という作業を機械学習におけるモデル学習のための関数を記述する、という置き換えもできる。もちろん、現実的には機械学習のようなモデル学習に計算リソースを激しく使うようなケースでは、コードを実行するたびに学習し直しということになっては非効率極まりないので、計算した結果をキャッシュするような仕組みがコンパイラに必要になるだろうが。
-
-言い方を変えると、Wavファイルによるサンプルやウェーブテーブルも、連続領域モデルを離散化した後の重みづけパラメーターのような計算結果も、機械学習における学習語のモデルデータも、**何かしらのモデルから生成されたキャッシュ**のようなものと捉えることもできるだろう。この、いつ計算するかを意味論に明示的に加えていくことは、現在の音楽情報処理において解離してしまっている、pythonを用いて学習、Maxなどのツールを用いてモデルを実行し音声をリアルタイムで出力といったような2つの作業を1つながりの作業としてつなぎ合わせるような役割を音楽プログラミング言語に与えることに繋がる。
-
-[^wolfram]: https://reference.wolfram.com/language/howto/SolveADifferentialEquation.html.ja 2022年1月31日最終閲覧。
-
----
-
-<!-- 4章のもの -->
-
-このことから考えられるべき示唆はいくつもあるだろう。まず、今日使われているコンピューター技術は、クロード・シャノンの定理が音声の符号化に貢献したことに限らず、音や通信にまつわるテクノロジーの上に成り立っていることはより強調されて然るべきである。加えて、音響遅延線メモリーの生い立ちは、計算機技術の歴史的位置付けをCivil Engineering、つまり非軍事技術観点からさらに見直す材料にもなる。電子計算機が歴史的に軍事技術として現れてきたことはもはや否定のしようもないし、テクノロジーが常に非中立的にならざるを得ないことを工学者は頭に入れ続けなければならない。しかし同時に、計算機を戦争だけが生み出した怪物のように捉えてしまうことは、テクノロジーを責任を持って扱う今日のCivil Engieeringのあり方に何ら希望を与えてくれないという困難さも併せ持つ。ならば立てるべき問いとはこうなる。WW2無くして現代の電子計算機は生まれなかったのかもしれないが、同時にエッカートの、自らの楽しみや、身の回りの人の楽しみのために行ってきたティンカリング無くしても現代の電子計算機の姿はなかったのではないか？
-
-
-
-メディア研究者の飯田豊はこの時期、ケージとも直接的に交流のあったマーシャル・マクルーハンの思想が広く流布され、かつこの時期の電子機器の低価格化により電気や通信機器（テレビやラジオ）というメディアが芸術家の素材になり始めたタイミングと重なったことが万博で行われた芸術家たちの実験につながっていることを指摘している。
-
-> マクルーハンの芸術論における中心的な概念は、言うまでもなく「環境」である。マクルーハンによれば、メディアが環境化することによって、ある時代の現実が形成されるようになると、その影響は不可視なものになる。新しい環境が登場することで相対的に古くなり、目に見えるようになった前の時代の環境（＝「反環境」）を作品として意識化させるのが、芸術の役割に他ならない。そして，エレクトロニクスという新しいテクノロジーの環境が登場してきた現在、環境そのものが芸術として扱われる段階（＝「環境芸術」）に初めて達したのではないかと指摘する。
-
----
-
-よりテクニカルな問題としてC++を基盤としない言語を用いて開発し直すという選択肢も考えられる。具体的には、C++（17）を用いての実装において、実装の参考にしたOCamlと比べると代数データ型の扱いが複雑になることが大きな障害となった。C++17においては、標準ライブラリに`std::variant`という、代数データ型における直和型（N種類の型のうちどれか1種類が含まれているような状態を示す型）が利用できるようになったが、これはAbstract Syntax Treeを表現するための木構造に用いる再帰する代数データ型(新しく型を定義するときに自分自身の項が含まれるような型）の定義を少し遠回りな方法でなければ実現できないことによる[^recursivevariant]。加えて、N個のvariantの中から各データ型に対応する処理を記述する際、OCaml等の関数型言語においてはパターンマッチと呼ばれる記法を用いて短く処理を記述することができる。C++でvariantを使った場合、テンプレートによる静的ポリモーフィズムの複雑な記述を行う必要がありこれも開発の効率を落とす一つの要因であった。そもそもC++を開発言語として選択したのは、第5章で説明した通り音楽のための言語を実装するにあたって、メモリの確保を明示的に制御できるような言語である必要性があることを意識していたという理由があるが、これは今にして思えばランタイムの実装（C++で書かれたプログラムならコンパイルされそのプログラムは静的にメモリを確保して動く）とコンパイラの実装(何かしらの言語で書かれたプログラムがLLVMライブラリなどを通じて静的にメモリを確保するようなプログラムを動的に出力する)を混同していたため、コンパイラ部分だけの実装を別の言語で実装することは可能である。ただ、幅広いプラットフォームをサポートしようと思えばLLVMが利用できることは重要な要素であるため、公式でそれらがサポートされているOCamlや、C言語APIをラップしたライブラリが存在しているHaskellやRustのような言語が異なる実装のための候補として挙げられる。
-
-[^recursivevariant]: `std::variant`の実装の元となったboostライブラリの中には再帰するvariantが記述可能なものもある。URLなどで補足する
-
----
-
-第2章前半で論じたように、プログラミング言語を設計する研究はその評価の基準の曖昧さの一方で、各技術要素については定量/定質様々な方法で客観性を持った評価をすることは可能だというHCIにおけるインターフェースデザインの主要な研究とはやや趣が異なる研究である。mimiumの設計も、第6章で論じてきた中心的な機能以外の部分に関しては実用性を考えた別個の機能が飛び飛びに開発されている。例えば本論の中では触れなかった、外部のファイルを読み込むincludeの機能などは音楽的に関わる意味論の設計の外側であったため、単純な文字列置き換えによる場当たり的実装となっている。一方でこの機能は開発されてなければ様々なコードのテストのファイルはライブラリのような機能分割をしない全て自己完結したコードでなければならない。
-
-このような状態で、本論文の主要な主張(Claim)たる、音楽において自分のソフトウェアを自分で開発できるようなインフラストラクチャの形成という目標に対して、それを支える根拠（Evidence）は長期的目線での音楽情報インフラストラクチャの形成の必要性とそれに応じたなるべくブラックボックスを少なくするような言語の設計と実装という、いわば設計思想のみであって、個々の技術的要素、例えば、信号処理をLLVMを用いることでコードをメモリ上でコンパイルでき、リアルタイムで高速な処理が行える、といった要素は、例え厳密なベンチマークを行っていたとしても主張を支える十分な根拠とは現状なり得ない。mimiumという人工物に対するAnnotationとしてのこの主張と根拠の結びつきは、今後言語が少しづつ実用される中で初めて評価されることになる。
-
----
-
-一方であえて重視しなかった機能として、近年の高レイヤーの拡張を試みる言語が同時に行ってきたコードの動的変更、つまりライブコーディングのための工夫はほとんどされていない。とはいえ、全体のアーキテクチャの参考としたExtemporeは低レイヤーの表現の自由度を担保しながらライブコーディングができることを目指した言語であり、LLVMという低レイヤーの処理をメモリ上でコンパイルして即時動作させるインフラストラクチャを用いているという共通点を見れば、少し手を加えることで、動的にコードを変更していった時に音声がブツ切れにならないかといった細かい考慮を度外視すれば実現自体は可能だと考えられる。ただし、その機能はLLVMのJITコンパイルのためのライブラリに依存することになるため、LLVMを使わないバックエンド–具体的には、Webブラウザ向けのWebassemblyバックエンドなどを追加しようと思った時の移植性が低くなってしまうことが予想できる。現在はコードの動的変更のしやすさよりも稼働できるプラットフォームの幅の広さの方に重きを置くべきと考えている。
-
----
-
-mimiumは独自に新しく統語論の定義を行っているため、（その表面上の見た目である統語論はRustという既存のポピュラーな言語に寄せてあるものの）Internal DSLとして実装されている言語と比べてるとその学習コストは高いし、ホスト言語の既存のライブラリ資源の活用も難しい。つまり、既存の音楽プログラミング言語の利用者からの参入障壁が大きい。これはインフラストラクチャとしての言語という側面から考えると重要な問題で、給水塔という既存のインフラストラクチャに乗ることで広がる携帯電話の基地局という新しいインフラストラクチャ[@Parks2015,p2]のように、新しいインフラストラクチャを整備するために既存のインフラストラクチャを利用することは必須とは言わずとも、利用しないことによってハードルが格段に上がってしまう。設計当初、言語自体の表現力が高くできてさえいればあまり問題にならないだろうと考えていたが現在はその考えは間違えだったと感じている。すでに繰り返し述べているように音楽プログラミング言語の実装には時間がかかる。言語自体の実装やアップデートもそうだし、言語上で構築するライブラリはなおのことである。なぜなら、言語上で開発されたライブラリは言語の中核的な機能や、includeのようなモジュール読み込みのための機能が更新されたり変更されるのに伴って大きく変更される必要がままあるため、本腰を入れて開発を始めることが難しいからである。そうしたときに、外部の言語のライブラリを活用できるということは、言語の開発段階から実用性を失わずにコアな機能を少しずつ増やしていくことができることになる。
-
-今後このような言語間の相互運用性を高めるための方法としては2つの方針が考えられる。1つは、別の言語の関数呼び出しの中で最も実装が簡単なC言語ライブラリの関数呼び出しを、mimium上でライブラリ名、関数名、型名を書けば実行時にリンクして呼び出せるようにする、いわゆるForeign Function Interface(FFI)の機能を追加することだ。ただ、簡単とはいえ、mimiumでは意味論上隠蔽されているハードウェア的な要素が含まれる型の扱い、つまりポインタ型の扱いを型システムの統語論にも追加しなければならないため、簡単とはいえコンパイラに入れる手間は比較的複雑なものとなる。
-
-2つ目は、mimium自体をFaustのように、MaxやSuperColliderのUGenとして扱えるようなワークフローを整備することで他の言語の拡張機能的に使えるようにするという方法だ。Faustに限らずとも例えば現在は文字列から独自の構文解析を行う、典型的なExternal DSLであるSuperColliderもその元となった環境はPyriteというMaxのためのエクスターナルオブジェクトとして利用できるスクリプト言語だった[@McCartney2020]。これは既に、mimium自体のアーキテクチャをなるべく疎結合にしていたこともあり、アーキテクチャの図におけるオーディオドライバの部分に当たる箇所を、MaxやSuperColliderそれぞれのUGen作成のためのAPIを用いて実装すればよいため、C言語FFIの実装と比べると比較的簡単ではある。
-
-
----
-
-PLfMのための最低限の抽象計算モデルの不在を理解した上で、それでも可能な限り最低限を目指したのがmimiumの設計方針である。この最低限の抽象化の不在はPLfMの研究として大きな課題であるのは間違いない。しかし、なるべく汎用性の高い言語が仮に作れたとして、それだけで、MIDIやUGenのような埋め込まれた音楽様式と異なる音楽が作られるようなことがあるのだろうか。もっと言えば、1950、1960年代のように、コンピューターを使って音楽を作ることが、コンピューターを理解してプログラムを作るという不可分な行為であったように、音楽家が主体的にコンピューターを扱えるような環境は、汎用性の高い、ブラックボックスのなるべく少ないPLfMを作るだけで実現可能なのだろうか？その、汎用性の高いPLfM自体はいったい誰が作るのだろうか？これが、mimiumを作るなかで最も強く感じた疑問と矛盾だった。
-
-この矛盾の説明をするため、第5章で整理した、音楽プログラミング言語の実装の方針と、それに伴う特性のトレードオフがmimiumではどうなっていたかを改めて考える。
-
-mimiumの実装方針は、中間表現の粒度を限りなく小さくするために、文字列データの解析から行うExternal DSLとなっていた。コンパイラ・コンパイラであるbisonを用いることで文字列解析の実装そのものはSuperColliderやFaust同様に下げられているが、C++という低レベルプログラミング言語での実装を行っているためその実装の手間（開発コスト）は少なくない。コードの動的変更の難しさや、開発コストの増大はあらかじめ想定されていた通りである。
-
-しかしこの実装のコストは当初予想していたよりもずっと大きく、正弦波を鳴らすための音が出るまでに1年以上の時間を費やすという状況を引き起こし、開発の経験の大半は音に関連したトピックというよりもむしろ汎用プログラミング言語の開発とほとんど変わらないものになっていた。
-
-これは実際mimiumという言語に特有の問題というわけではなく、Generalityを高めようとすれば必然的に発生する問題へと一般化できる。
-
----
-
-- **イノベーションではなく、使用中(Not an Innovation but in use)**
-- **応用ではなく、基盤と周縁（Not an Application but an Infrastructure and Merginal Area）**
-- **誤用ではなく、開き直り（Not an Misuse but Being Defiant）**
-
-こうした汎用性の高い言語そのものの実装の困難さを解消するための方法として、言語同士の相互運用性が上がればよいという立場をとることもできる。つまり、mimium自体をFaustのように、MaxやSuperColliderのUGenとして扱えるようなワークフローを整備することで他の言語の拡張機能的に使えるようにするという方法だ。Faustに限らずとも、例えば現在は文字列から独自の構文解析を行う典型的なExternal DSLである、SuperColliderもその元となった環境はPyriteというMax上で利用できるスクリプト言語だった。こうした埋め込みによる相互運用は既に、mimium自体のアーキテクチャをなるべく疎結合にしていたこともあり、アーキテクチャの図におけるオーディオドライバの部分に当たる箇所を、MaxやSuperColliderそれぞれのUGen作成のためのAPIを用いて実装すればよいため、比較的簡単ではある。
-
-
-電子計算機が歴史的に軍事技術として現れてきたことはもはや否定のしようもないし、テクノロジーが常に非中立的にならざるを得ないことを工学者は頭に入れ続けなければならない。音楽のためを標榜したIRCAM 4Xが最終的に軍事目的に利用される結末に至ったことからもそれは明らかである。
-
-しかし同時に、計算機を戦争だけが生み出した怪物のように捉えてしまうことは、テクノロジーを責任を持って扱う今日のCivil Engieeringのあり方に何ら希望を与えてくれないという困難さも併せ持つ。ならば立てるべき問いとはこうなる。WW2無くして現代の電子計算機は生まれなかったのかもしれないが、同時にエッカートの、自らの楽しみや、身の回りの人の楽しみのために行ってきたティンカリング無くしても現代の電子計算機の姿はなかったのではないか？
-
----
-
-
-アマチュアリズム的態度に準じたハッキング/ティンカリング的態度に基づくテクノロジーの誤用はもはや、アクセス不可能なブラックボックスにより無効化され、コンピューターという象徴機械を介して音楽文化は無意識に画一的な方向に収束する傾向にある。
-
-そうした時代に音楽家が取れる態度はまず、テクノロジーの中身そのものを根本的に理解できるようになっていくよう変わる必要があるし、音楽文化全体においてテクノロジーの理解を促すような教育も必要である。パケットはMaxやPure Dataが比較的普及した後でも、それを使うためには教育の要素が不可欠だと主張しているが、この状況は現在になっても変わっていないと言える。
-
-> しかし、コンピュータハードウェアの低廉化によって交わされた約束に、私たちはまだ追いついていない。確かに、いまやすべての道具が入ったコンピュータを400ドル程度で購入でき、アンプとスピーカを追加すればコンピュータ音楽制作の準備が整う。しかしこれは、システムを構築し、フリーの良いソフト見つけてインストールし実行するために必要な知識があることを前提としている。コンピュータを数千ドルに、ソフトウェアを数千ドルにしたいという多くの商業的な関心が、私たちの前に立ちはだかる。
-> コンピューティングとコンピュータ音楽の民主化に不可欠な要素は、地域の知識ベースを育成することだ。将来を見据えた音楽教育者は、学生が自分のコンピュータを構築するのを促すために何時間も割いている。自家製コンピュータと自家製コンピュータ音楽ソフトウェアの国際的な文化を、いつか見たいと私は思う。過去に裕福な西側はソフトウェアを開発し、何百万ものCDを作り、買う人には誰にでも販売した。将来的には、他の世界から輸入されたソフトウェアを研究し学習するセンターを見てみたい。
-> 知識を育てるコミュニティが、特にLinuxのような非商用OSでは必要である。もしLinuxを使う友人がいなければ、動かすまでには障害があるだろう。しかし、世界の多くで少なくとも村の1人や2人に、コンピュータ音楽の専門知識（マシンの組み立て方法、OSのインストール方法、ソフトウェアの実行方法など）がある未来を想像できる。[@Puckette2002]
\ No newline at end of file
diff --git a/chapter8.md b/chapter8.md
deleted file mode 100644
index 5077345..0000000
--- a/chapter8.md
+++ /dev/null
@@ -1,33 +0,0 @@
-<!-- 第8章 結論 -->
-
-\epigraph{とってかわるべきシステムとは、人間が自己の自由と創造性とを責任をもってひきうけるシステムのことである。}{『\citetitle{Attali1983}』\\ \textcite[p144]{Attali1983}}
-
-本研究では、音楽土木工学という、音楽のために工学の基礎的要素自体の再構築する学問領域を、音楽のためのプログラミング言語mimiumの制作と、歴史の批判的再検討の繰り返しによって描き出すことを試みてきた。
-
-第2章では本研究の研究プログラム自体を、デザインリサーチの歴史を振り返り検討した。本研究はPLfMの設計と開発という実践行為を通じて、これまで所与のものとされてきた歴史を批判的に再検討することを目指した、メディア考古学的デザインリサーチという立場に立つ。その研究方法論の要点は、作ることによって自らの視点や価値観が変わる自己反映性に自覚的になることだった。
-
-第3章では表現のメディアとしてのコンピューターの歴史を批判的に再検討した。アラン・ケイらのメタメディア概念が現在のパーソナルコンピューティング環境に大きく影響を与えつつも、大量生産され多くの人にとって便利な商品化されゆく中で、プログラミングという本来コンピューターを道具として利用するのに不可分だった行為をコンピューターの利用者から遠ざけてきた。計算機の利用方法それ自体に、モデル化とシミュレーションという行為が内在されているため、コンピューターを使った音楽制作は、理論的には無限のバリエーションがあれど、根本的には作られる音や楽器の仕組みを想像することができなければ実現できないという制約が存在している。しかしこの限界は消費社会において、 「ユーザー」が装置を便利に扱えるようにするためのプロトコルや標準規格といったインフラストラクチャが、少しずつ時間をかけて容易に変更できないように形作られるため、いつしか想像することができても実現できない状況を作ってしまっている。
-
-それは第4章で確認した通り、音楽のためのプログラミング言語においても同様である。黎明期のコンピューターを用いた音楽生成の実験には、Pilot ACEのようなプログラミング言語というインターフェースでは不可能そうに思える、音響遅延線メモリーなどのハードウェアが引き出した特異な音楽実践が存在していた。1950年代に入って作られたPCMベースの実践も、元々は様々な形であり得る抽象化の1つの形としてUnit Generatorのような最低限の抽象化が考案され、その利用も基本的にはプログラミングという作業と音楽制作の作業は不可分なものだった。しかし、コンピューターが産業化される過程で、リアルタイム性の追求を背景にUGen自体をハードウェア化する試みが進み、音楽をコンピューターで生成するという行為の中でUGenのモデルが所与のものにされてしまった。
-
-その研究方法論の要点は、作ることによって自らの視点や価値観が変わる自己反映性であった。この研究とはいったい何についての研究だったのだろうか？結論としてまず、そのことを改めて確認しなくてはならない。
-
-本研究を一言で表すのであれば、それはアマチュアリズムの再定義に他ならない。博士論文という、プロフェッショナリズムの極みとも言える場でアマチュアリズムの実践を行うのは一見おかしなことではある。
-
-〜
-
-# 今後の課題
-
-## 音楽のためのコンピューター自体の仕組みの再考
-
-## 批評的、自己反映的デザイン
-
-
-
-# 結論
-
-
-
-
-
-
diff --git a/chapter_template.html.template b/chapter_template.html.template
new file mode 100644
index 0000000..db9a075
--- /dev/null
+++ b/chapter_template.html.template
@@ -0,0 +1,14 @@
+---
+$if(title)$
+title: $title$
+$endif$
+layout: single
+highlight: true
+---
+$if(title)$
+<h1>$title$</h1>
+$endif$
+
+$body$
+
+<style>$highlighting-css$</style>
\ No newline at end of file
diff --git a/gen_html.sh b/gen_html.sh
new file mode 100755
index 0000000..67ee708
--- /dev/null
+++ b/gen_html.sh
@@ -0,0 +1,16 @@
+#!/bin/zsh
+for md in $(find *.md)
+do 
+echo "processing $md"
+offset=0
+if [[ "$md" =~ chapter[0-9].md ]]
+then
+offset=$(echo "$md" | sed  -E 's/chapter([0-9])\.md/\1/')
+# offset=${BASH_REMATCH[0]}
+echo ${offset}
+fi
+echo "heading offset is $offset"
+pandoc $md --number-offset=$(($offset)) --highlight-style=espresso --shift-heading-level-by=1 --filter pandoc-crossref -M "crossrefYaml=./pandoc-crossref-config.yml" --citeproc  --bibliography=ref.bib --template=chapter_template.html.template -o  ${md%.*}_rendered.html
+done
+
+
diff --git a/gen_png.sh b/gen_png.sh
new file mode 100755
index 0000000..57d897e
--- /dev/null
+++ b/gen_png.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+for p in $(find img/*.pdf)
+do 
+newname=$(echo "$p" | sed  -E 's/(.*)\.pdf/\1.png/')
+echo "convert $p to $newname..."
+convert $p $newname
+rm -rf $p
+done
\ No newline at end of file
diff --git a/glossary.md b/glossary.md
index cd29ce2..58fb0f1 100644
--- a/glossary.md
+++ b/glossary.md
@@ -1,3 +1,7 @@
+---
+title: 用語集
+draft: true
+---
 # 略記一覧 {-}
 
 - ANT: Actor Network Theorey / アクターネットワーク理論。ミシェル・カロンやブルーノ・ラトゥールらによって提唱された科学論の中のアプローチの1つ。生物/非生物や人間/非人間の区別を付けずあらゆる要素をアクターとして扱うことで、技術決定論と社会構築論のどちらにも偏りすぎない立場を取る。
@@ -17,7 +21,7 @@
 - NIME: New Interfaces for Musical Expression / 音楽のための新しいインタフェース研究、及びその国際会議
 - OSC: Open Sound Control / マシュー・ライトらによって提唱された音楽のための自由度の高い相互通信プロトコル
 - PCM: Pulse Code Modulation / 音圧波形を一定時間ごとに標本化（Sampling）、量子化（Quantization）することで数値の列として音声信号を表現する方式
-- PLfM: Programming Language for Music / 音楽のためのプログラミング言語（本稿で独自に定義、[@sec:plfmdef]を参照）
+- PLfM: Programming Language for Music / 音楽のためのプログラミング言語（本稿で独自に定義[第4章](../chapter4_rendered#plfmdef)を参照）
 - RtD: Research through Design / デザイン実践を通じた研究
 - UGen: Unit Generator / 音楽のためのプログラミング言語で広く用いられる、フィルターやオシレーターなどDSPの基礎的な要素の総称
 - VM: Virtual Machine / ソフトウェア上で定義された仮想機械
diff --git a/img/Ladder.png b/img/Ladder.png
deleted file mode 100644
index 20a1a0a..0000000
Binary files a/img/Ladder.png and /dev/null differ
diff --git a/img/Ladder2.png b/img/Ladder2.png
deleted file mode 100644
index 050e525..0000000
Binary files a/img/Ladder2.png and /dev/null differ
diff --git a/img/Tradeoff1.png b/img/Tradeoff1.png
deleted file mode 100644
index 78c1fab..0000000
Binary files a/img/Tradeoff1.png and /dev/null differ
diff --git a/img/Tradeoff2.png b/img/Tradeoff2.png
deleted file mode 100644
index c855ecb..0000000
Binary files a/img/Tradeoff2.png and /dev/null differ
diff --git a/img/Tradeoff3.png b/img/Tradeoff3.png
deleted file mode 100644
index c07c36c..0000000
Binary files a/img/Tradeoff3.png and /dev/null differ
diff --git a/img/auger_alternativepresent.pdf b/img/auger_alternativepresent.pdf
deleted file mode 100644
index 18f0a1e..0000000
Binary files a/img/auger_alternativepresent.pdf and /dev/null differ
diff --git a/img/auger_alternativepresent.png b/img/auger_alternativepresent.png
index d88ac23..1e99f58 100644
Binary files a/img/auger_alternativepresent.png and b/img/auger_alternativepresent.png differ
diff --git a/img/brown.pdf b/img/brown.pdf
deleted file mode 100644
index 0e0a6ca..0000000
Binary files a/img/brown.pdf and /dev/null differ
diff --git a/img/brown.png b/img/brown.png
index 306f32e..9c6f37e 100644
Binary files a/img/brown.png and b/img/brown.png differ
diff --git a/img/chronic-tradeoff.pdf b/img/chronic-tradeoff.pdf
deleted file mode 100644
index 8bf5183..0000000
Binary files a/img/chronic-tradeoff.pdf and /dev/null differ
diff --git a/img/chronic-tradeoff.png b/img/chronic-tradeoff.png
index 31ef5e3..6c1d6b8 100644
Binary files a/img/chronic-tradeoff.png and b/img/chronic-tradeoff.png differ
diff --git a/img/computermedia_history.pdf b/img/computermedia_history.pdf
deleted file mode 100644
index c6245e7..0000000
Binary files a/img/computermedia_history.pdf and /dev/null differ
diff --git a/img/computermedia_history.png b/img/computermedia_history.png
new file mode 100644
index 0000000..af7d3d2
Binary files /dev/null and b/img/computermedia_history.png differ
diff --git a/img/design_history.pdf b/img/design_history.pdf
deleted file mode 100644
index 9a29237..0000000
Binary files a/img/design_history.pdf and /dev/null differ
diff --git a/img/design_history.png b/img/design_history.png
new file mode 100644
index 0000000..a2495bd
Binary files /dev/null and b/img/design_history.png differ
diff --git a/img/faust-fir.pdf b/img/faust-fir.pdf
deleted file mode 100644
index a0d4325..0000000
Binary files a/img/faust-fir.pdf and /dev/null differ
diff --git a/img/faust-fir.png b/img/faust-fir.png
new file mode 100644
index 0000000..b5da780
Binary files /dev/null and b/img/faust-fir.png differ
diff --git a/img/history_overview.png b/img/history_overview.png
deleted file mode 100644
index 883415a..0000000
Binary files a/img/history_overview.png and /dev/null differ
diff --git a/img/humanintheloop_model.pdf b/img/humanintheloop_model.pdf
deleted file mode 100644
index 1ea2c18..0000000
Binary files a/img/humanintheloop_model.pdf and /dev/null differ
diff --git a/img/humanintheloop_model.png b/img/humanintheloop_model.png
new file mode 100644
index 0000000..7789ebc
Binary files /dev/null and b/img/humanintheloop_model.png differ
diff --git a/img/ladder1.pdf b/img/ladder1.pdf
deleted file mode 100644
index 55441f6..0000000
Binary files a/img/ladder1.pdf and /dev/null differ
diff --git a/img/ladder1.png b/img/ladder1.png
new file mode 100644
index 0000000..47cd712
Binary files /dev/null and b/img/ladder1.png differ
diff --git a/img/ladder2.pdf b/img/ladder2.pdf
deleted file mode 100644
index d7ff2a9..0000000
Binary files a/img/ladder2.pdf and /dev/null differ
diff --git a/img/ladder2.png b/img/ladder2.png
new file mode 100644
index 0000000..7eca7d2
Binary files /dev/null and b/img/ladder2.png differ
diff --git a/img/max-pd-history.pdf b/img/max-pd-history.pdf
deleted file mode 100644
index 87942c1..0000000
Binary files a/img/max-pd-history.pdf and /dev/null differ
diff --git a/img/max-pd-history.png b/img/max-pd-history.png
new file mode 100644
index 0000000..0f7eb97
Binary files /dev/null and b/img/max-pd-history.png differ
diff --git a/img/mediaarchaeology_position.pdf b/img/mediaarchaeology_position.pdf
deleted file mode 100644
index 343ffb6..0000000
Binary files a/img/mediaarchaeology_position.pdf and /dev/null differ
diff --git a/img/mediaarchaeology_position.png b/img/mediaarchaeology_position.png
new file mode 100644
index 0000000..4a4fdb0
Binary files /dev/null and b/img/mediaarchaeology_position.png differ
diff --git a/img/mimium-arch-v4-affinity.pdf b/img/mimium-arch-v4-affinity.pdf
deleted file mode 100644
index 7a08e71..0000000
Binary files a/img/mimium-arch-v4-affinity.pdf and /dev/null differ
diff --git a/img/mimium-arch-v4-affinity.png b/img/mimium-arch-v4-affinity.png
new file mode 100644
index 0000000..50810e5
Binary files /dev/null and b/img/mimium-arch-v4-affinity.png differ
diff --git a/img/musiccomputing.pdf b/img/musiccomputing.pdf
deleted file mode 100644
index edb35f8..0000000
Binary files a/img/musiccomputing.pdf and /dev/null differ
diff --git a/img/musiccomputing.png b/img/musiccomputing.png
new file mode 100644
index 0000000..761f70e
Binary files /dev/null and b/img/musiccomputing.png differ
diff --git a/img/plfmhistory.pdf b/img/plfmhistory.pdf
deleted file mode 100644
index 83bc2e2..0000000
Binary files a/img/plfmhistory.pdf and /dev/null differ
diff --git a/img/plfmhistory.png b/img/plfmhistory.png
index 12fbc33..bee8d18 100644
Binary files a/img/plfmhistory.png and b/img/plfmhistory.png differ
diff --git a/img/thesis_structure.pdf b/img/thesis_structure.pdf
deleted file mode 100644
index bce6e77..0000000
Binary files a/img/thesis_structure.pdf and /dev/null differ
diff --git a/img/thesis_structure.png b/img/thesis_structure.png
new file mode 100644
index 0000000..9ed4d84
Binary files /dev/null and b/img/thesis_structure.png differ
diff --git a/img/tradeoff.pdf b/img/tradeoff.pdf
deleted file mode 100644
index 48cfe6e..0000000
Binary files a/img/tradeoff.pdf and /dev/null differ
diff --git a/img/tradeoff.png b/img/tradeoff.png
new file mode 100644
index 0000000..9bab36a
Binary files /dev/null and b/img/tradeoff.png differ
diff --git a/img/tradeoff2.pdf b/img/tradeoff2.pdf
deleted file mode 100644
index cdb29e0..0000000
Binary files a/img/tradeoff2.pdf and /dev/null differ
diff --git a/img/tradeoff2.png b/img/tradeoff2.png
new file mode 100644
index 0000000..0a6b1e9
Binary files /dev/null and b/img/tradeoff2.png differ
diff --git a/img/tradeoff3.pdf b/img/tradeoff3.pdf
deleted file mode 100644
index 7be958a..0000000
Binary files a/img/tradeoff3.pdf and /dev/null differ
diff --git a/img/tradeoff3.png b/img/tradeoff3.png
new file mode 100644
index 0000000..ace55ac
Binary files /dev/null and b/img/tradeoff3.png differ
diff --git a/img/tradeoff4.pdf b/img/tradeoff4.pdf
deleted file mode 100644
index f2ec262..0000000
Binary files a/img/tradeoff4.pdf and /dev/null differ
diff --git a/img/tradeoff4.png b/img/tradeoff4.png
new file mode 100644
index 0000000..32c339b
Binary files /dev/null and b/img/tradeoff4.png differ
diff --git a/img/tradeoff5.pdf b/img/tradeoff5.pdf
deleted file mode 100644
index 851031c..0000000
Binary files a/img/tradeoff5.pdf and /dev/null differ
diff --git a/img/tradeoff5.png b/img/tradeoff5.png
new file mode 100644
index 0000000..ea7867f
Binary files /dev/null and b/img/tradeoff5.png differ
diff --git a/img/wildpath.pdf b/img/wildpath.pdf
deleted file mode 100644
index 56b4d7e..0000000
Binary files a/img/wildpath.pdf and /dev/null differ
diff --git a/img/wildpath.png b/img/wildpath.png
index 689f0a0..81c798d 100644
Binary files a/img/wildpath.png and b/img/wildpath.png differ
diff --git a/listings-rust.sty b/listings-rust.sty
deleted file mode 100644
index 4ae22d8..0000000
--- a/listings-rust.sty
+++ /dev/null
@@ -1,75 +0,0 @@
-\NeedsTeXFormat{LaTeX2e}[1994/06/01]
-\ProvidesPackage{listings-rust}[2018/01/23 Custom Package]
-
-\RequirePackage{color}
-\RequirePackage{listings}
-
-\lstdefinelanguage{Rust}{%
-  sensitive%
-, morecomment=[l]{//}%
-, morecomment=[s]{/*}{*/}%
-, moredelim=[s][{\itshape\color[rgb]{0,0,0.75}}]{\#[}{]}%
-, morestring=[b]{"}%
-, alsodigit={}%
-, alsoother={}%
-, alsoletter={!}%
-%
-%
-% [1] reserve keywords
-% [2] traits
-% [3] primitive types
-% [4] type and value constructors
-% [5] identifier
-%
-, morekeywords={break, continue, else, for, if, in, loop, match, return, while}  % control flow keywords
-, morekeywords={as, const, let, move, mut, ref, static}  % in the context of variables
-, morekeywords={dyn, enum, fn, impl, Self, struct, trait, type, union, use, where}  % in the context of declarations
-, morekeywords={crate, extern, mod, pub, super}  % in the context of modularisation
-, morekeywords={unsafe}  % markers
-, morekeywords={abstract, alignof, become, box, do, final, macro, offsetof, override, priv, proc, pure, sizeof, typeof, unsized, virtual, yield}  % reserved identifiers
-%
-% grep 'pub trait [A-Za-z][A-Za-z0-9]*' -r . | sed 's/^.*pub trait \([A-Za-z][A-Za-z0-9]*\).*/\1/g' | sort -u | tr '\n' ',' | sed 's/^\(.*\),$/{\1}\n/g' | sed 's/,/, /g'
-, morekeywords=[2]{@,Add, AddAssign, Any, AsciiExt, AsInner, AsInnerMut, AsMut, AsRawFd, AsRawHandle, AsRawSocket, AsRef, Binary, BitAnd, BitAndAssign, Bitor, BitOr, BitOrAssign, BitXor, BitXorAssign, Borrow, BorrowMut, Boxed, BoxPlace, BufRead, BuildHasher, CastInto, CharExt, Clone, CoerceUnsized, CommandExt, Copy, Debug, DecodableFloat, Default, Deref, DerefMut, DirBuilderExt, DirEntryExt, Display, Div, DivAssign, DoubleEndedIterator, DoubleEndedSearcher, Drop, EnvKey, Eq, Error, ExactSizeIterator, ExitStatusExt, Extend, FileExt, FileTypeExt, Float, Fn, FnBox, FnMut, FnOnce, Freeze, From, FromInner, FromIterator, FromRawFd, FromRawHandle, FromRawSocket, FromStr, FullOps, FusedIterator, Generator, Hash, Hasher, Index, IndexMut, InPlace, Int, Into, IntoCow, IntoInner, IntoIterator, IntoRawFd, IntoRawHandle, IntoRawSocket, IsMinusOne, IsZero, Iterator, JoinHandleExt, LargeInt, LowerExp, LowerHex, MetadataExt, Mul, MulAssign, Neg, Not, Octal, OpenOptionsExt, Ord, OsStrExt, OsStringExt, Packet, PartialEq, PartialOrd, Pattern, PermissionsExt, Place, Placer, Pointer, Product, Put, RangeArgument, RawFloat, Read, Rem, RemAssign, Seek, Shl, ShlAssign, Shr, ShrAssign, Sized, SliceConcatExt, SliceExt, SliceIndex, Stats, Step, StrExt, Sub, SubAssign, Sum, Sync, TDynBenchFn, Terminal, Termination, ToOwned, ToSocketAddrs, ToString, Try, TryFrom, TryInto, UnicodeStr, Unsize, UpperExp, UpperHex, WideInt, Write}
-, morekeywords=[2]{Send}  % additional traits
-%
-, morekeywords=[3]{bool, char, f32, f64, i8, i16, i32, i64, isize, str, u8, u16, u32, u64, unit, usize, i128, u128,void,float}  % primitive types (added mimium types)
-%
-, morekeywords=[4]{ Err, false, None, Ok, Some, true}  % prelude value constructors
-% grep 'pub \(type\|struct\|enum\) [A-Za-z][A-Za-z0-9]*' -r . | sed 's/^.*pub \(type\|struct\|enum\) \([A-Za-z][A-Za-z0-9]*\).*/\2/g' | sort -u | tr '\n' ',' | sed 's/^\(.*\),$/{\1}\n/g' | sed 's/,/, /g'    
-, morekeywords=[3]{AccessError, Adddf3, AddI128, AddoI128, AddoU128, ADDRESS, ADDRESS64, addrinfo, ADDRINFOA, AddrParseError, Addsf3, AddU128, advice, aiocb, Alignment, AllocErr, AnonPipe, Answer, Arc, Args, ArgsInnerDebug, ArgsOs, Argument, Arguments, ArgumentV1, Ashldi3, Ashlti3, Ashrdi3, Ashrti3, AssertParamIsClone, AssertParamIsCopy, AssertParamIsEq, AssertUnwindSafe, AtomicBool, AtomicPtr, Attr, auxtype, auxv, BackPlace, BacktraceContext, Barrier, BarrierWaitResult, Bencher, BenchMode, BenchSamples, BinaryHeap, BinaryHeapPlace, blkcnt, blkcnt64, blksize, BOOL, boolean, BOOLEAN, BoolTrie, BorrowError, BorrowMutError, Bound, Box, bpf, BTreeMap, BTreeSet, Bucket, BucketState, Buf, BufReader, BufWriter, Builder, BuildHasherDefault, BY, BYTE, Bytes, CannotReallocInPlace, cc, Cell, Chain, CHAR, CharIndices, CharPredicateSearcher, Chars, CharSearcher, CharsError, CharSliceSearcher, CharTryFromError, Child, ChildPipes, ChildStderr, ChildStdin, ChildStdio, ChildStdout, Chunks, ChunksMut, ciovec, clock, clockid, Cloned, cmsgcred, cmsghdr, CodePoint, Color, ColorConfig, Command, CommandEnv, Component, Components, CONDITION, condvar, Condvar, CONSOLE, CONTEXT, Count, Cow, cpu, CRITICAL, CStr, CString, CStringArray, Cursor, Cycle, CycleIter, daddr, DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple, Decimal, Decoded, DecodeUtf16, DecodeUtf16Error, DecodeUtf8, DefaultEnvKey, DefaultHasher, dev, device, Difference, Digit32, DIR, DirBuilder, dircookie, dirent, dirent64, DirEntry, Discriminant, DISPATCHER, Display, Divdf3, Divdi3, Divmoddi4, Divmodsi4, Divsf3, Divsi3, Divti3, dl, Dl, Dlmalloc, Dns, DnsAnswer, DnsQuery, dqblk, Drain, DrainFilter, Dtor, Duration, DwarfReader, DWORD, DWORDLONG, DynamicLibrary, Edge, EHAction, EHContext, Elf32, Elf64, Empty, EmptyBucket, EncodeUtf16, EncodeWide, Entry, EntryPlace, Enumerate, Env, epoll, errno, Error, ErrorKind, EscapeDebug, EscapeDefault, EscapeUnicode, event, Event, eventrwflags, eventtype, ExactChunks, ExactChunksMut, EXCEPTION, Excess, ExchangeHeapSingleton, exit, exitcode, ExitStatus, Failure, fd, fdflags, fdsflags, fdstat, ff, fflags, File, FILE, FileAttr, filedelta, FileDesc, FilePermissions, filesize, filestat, FILETIME, filetype, FileType, Filter, FilterMap, Fixdfdi, Fixdfsi, Fixdfti, Fixsfdi, Fixsfsi, Fixsfti, Fixunsdfdi, Fixunsdfsi, Fixunsdfti, Fixunssfdi, Fixunssfsi, Fixunssfti, Flag, FlatMap, Floatdidf, FLOATING, Floatsidf, Floatsisf, Floattidf, Floattisf, Floatundidf, Floatunsidf, Floatunsisf, Floatuntidf, Floatuntisf, flock, ForceResult, FormatSpec, Formatted, Formatter, Fp, FpCategory, fpos, fpos64, fpreg, fpregset, FPUControlWord, Frame, FromBytesWithNulError, FromUtf16Error, FromUtf8Error, FrontPlace, fsblkcnt, fsfilcnt, fsflags, fsid, fstore, fsword, FullBucket, FullBucketMut, FullDecoded, Fuse, GapThenFull, GeneratorState, gid, glob, glob64, GlobalDlmalloc, greg, group, GROUP, Guard, GUID, Handle, HANDLE, Handler, HashMap, HashSet, Heap, HINSTANCE, HMODULE, hostent, HRESULT, id, idtype, if, ifaddrs, IMAGEHLP, Immut, in, in6, Incoming, Infallible, Initializer, ino, ino64, inode, InsertResult, Inspect, Instant, int16, int32, int64, int8, integer, IntermediateBox, Internal, Intersection, intmax, IntoInnerError, IntoIter, IntoStringError, intptr, InvalidSequence, iovec, ip, IpAddr, ipc, Ipv4Addr, ipv6, Ipv6Addr, Ipv6MulticastScope, Iter, IterMut, itimerspec, itimerval, jail, JoinHandle, JoinPathsError, KDHELP64, kevent, kevent64, key, Key, Keys, KV, l4, LARGE, lastlog, launchpad, Layout, Lazy, lconv, Leaf, LeafOrInternal, Lines, LinesAny, LineWriter, linger, linkcount, LinkedList, load, locale, LocalKey, LocalKeyState, Location, lock, LockResult, loff, LONG, lookup, lookupflags, LookupHost, LPBOOL, LPBY, LPBYTE, LPCSTR, LPCVOID, LPCWSTR, LPDWORD, LPFILETIME, LPHANDLE, LPOVERLAPPED, LPPROCESS, LPPROGRESS, LPSECURITY, LPSTARTUPINFO, LPSTR, LPVOID, LPWCH, LPWIN32, LPWSADATA, LPWSAPROTOCOL, LPWSTR, Lshrdi3, Lshrti3, lwpid, M128A, mach, major, Map, mcontext, Metadata, Metric, MetricMap, mflags, minor, mmsghdr, Moddi3, mode, Modsi3, Modti3, MonitorMsg, MOUNT, mprot, mq, mqd, msflags, msghdr, msginfo, msglen, msgqnum, msqid, Muldf3, Mulodi4, Mulosi4, Muloti4, Mulsf3, Multi3, Mut, Mutex, MutexGuard, MyCollection, n16, NamePadding, NativeLibBoilerplate, nfds, nl, nlink, NodeRef, NoneError, NonNull, NonZero, nthreads, NulError, OccupiedEntry, off, off64, oflags, Once, OnceState, OpenOptions, Option, Options, OptRes, Ordering, OsStr, OsString, Output, OVERLAPPED, Owned, Packet, PanicInfo, Param, ParseBoolError, ParseCharError, ParseError, ParseFloatError, ParseIntError, ParseResult, Part, passwd, Path, PathBuf, PCONDITION, PCONSOLE, Peekable, PeekMut, Permissions, PhantomData, pid, Pipes, PlaceBack, PlaceFront, PLARGE, PoisonError, pollfd, PopResult, port, Position, Powidf2, Powisf2, Prefix, PrefixComponent, PrintFormat, proc, Process, PROCESS, processentry, protoent, PSRWLOCK, pthread, ptr, ptrdiff, PVECTORED, Queue, radvisory, RandomState, Range, RangeFrom, RangeFull, RangeInclusive, RangeMut, RangeTo, RangeToInclusive, RawBucket, RawFd, RawHandle, RawPthread, RawSocket, RawTable, RawVec, Rc, ReadDir, Receiver, recv, RecvError, RecvTimeoutError, ReentrantMutex, ReentrantMutexGuard, Ref, RefCell, RefMut, REPARSE, Repeat, Result, Rev, Reverse, riflags, rights, rlim, rlim64, rlimit, rlimit64, roflags, Root, RSplit, RSplitMut, RSplitN, RSplitNMut, RUNTIME, rusage, RwLock, RWLock, RwLockReadGuard, RwLockWriteGuard, sa, SafeHash, Scan, sched, scope, sdflags, SearchResult, SearchStep, SECURITY, SeekFrom, segment, Select, SelectionResult, sem, sembuf, send, Sender, SendError, servent, sf, Shared, shmatt, shmid, ShortReader, ShouldPanic, Shutdown, siflags, sigaction, SigAction, sigevent, sighandler, siginfo, Sign, signal, signalfd, SignalToken, sigset, sigval, Sink, SipHasher, SipHasher13, SipHasher24, size, SIZE, Skip, SkipWhile, Slice, SmallBoolTrie, sockaddr, SOCKADDR, sockcred, Socket, SOCKET, SocketAddr, SocketAddrV4, SocketAddrV6, socklen, speed, Splice, Split, SplitMut, SplitN, SplitNMut, SplitPaths, SplitWhitespace, spwd, SRWLOCK, ssize, stack, STACKFRAME64, StartResult, STARTUPINFO, stat, Stat, stat64, statfs, statfs64, StaticKey, statvfs, StatVfs, statvfs64, Stderr, StderrLock, StderrTerminal, Stdin, StdinLock, Stdio, StdioPipes, Stdout, StdoutLock, StdoutTerminal, StepBy, String, StripPrefixError, StrSearcher, subclockflags, Subdf3, SubI128, SuboI128, SuboU128, subrwflags, subscription, Subsf3, SubU128, Summary, suseconds, SYMBOL, SYMBOLIC, SymmetricDifference, SyncSender, sysinfo, System, SystemTime, SystemTimeError, Take, TakeWhile, tcb, tcflag, TcpListener, TcpStream, TempDir, TermInfo, TerminfoTerminal, termios, termios2, TestDesc, TestDescAndFn, TestEvent, TestFn, TestName, TestOpts, TestResult, Thread, threadattr, threadentry, ThreadId, tid, time64, timespec, TimeSpec, timestamp, timeval, timeval32, timezone, tm, tms, ToLowercase, ToUppercase, TraitObject, TryFromIntError, TryFromSliceError, TryIter, TryLockError, TryLockResult, TryRecvError, TrySendError, TypeId, U64x2, ucontext, ucred, Udivdi3, Udivmoddi4, Udivmodsi4, Udivmodti4, Udivsi3, Udivti3, UdpSocket, uid, UINT, uint16, uint32, uint64, uint8, uintmax, uintptr, ulflags, ULONG, ULONGLONG, Umoddi3, Umodsi3, Umodti3, UnicodeVersion, Union, Unique, UnixDatagram, UnixListener, UnixStream, Unpacked, UnsafeCell, UNWIND, UpgradeResult, useconds, user, userdata, USHORT, Utf16Encoder, Utf8Error, Utf8Lossy, Utf8LossyChunk, Utf8LossyChunksIter, utimbuf, utmp, utmpx, utsname, uuid, VacantEntry, Values, ValuesMut, VarError, Variables, Vars, VarsOs, Vec, VecDeque, vm, Void, WaitTimeoutResult, WaitToken, wchar, WCHAR, Weak, whence, WIN32, WinConsole, Windows, WindowsEnvKey, winsize, WORD, Wrapping, wrlen, WSADATA, WSAPROTOCOL, WSAPROTOCOLCHAIN, Wtf8, Wtf8Buf, Wtf8CodePoints, xsw, xucred, Zip, zx}
-%
-, morekeywords=[5]{now, self,assert!, assert_eq!, assert_ne!, cfg!, column!, compile_error!, concat!, concat_idents!, debug_assert!, debug_assert_eq!, debug_assert_ne!, env!, eprint!, eprintln!, file!, format!, format_args!, include!, include_bytes!, include_str!, line!, module_path!, option_env!, panic!, print!, println!, select!, stringify!, thread_local!, try!, unimplemented!, unreachable!, vec!, write!, writeln!}  % prelude macros // add now for mimium
-}%
-
-\lstdefinestyle{colouredRust}%
-{ basicstyle=\ttfamily%
-, identifierstyle=%
-, commentstyle=\color[gray]{0.4}%
-, stringstyle=\color[rgb]{0, 0, 0.5}%
-, keywordstyle=\bfseries% reserved keywords
-, keywordstyle=[2]\color[rgb]{0.75, 0, 0}% traits
-, keywordstyle=[3]\color[rgb]{0, 0.5, 0}% primitive types
-, keywordstyle=[4]\color[rgb]{0, 0.5, 0}% type and value constructors
-, keywordstyle=[5]\color[rgb]{0, 0, 0.75}% macros
-% , columns=spaceflexible%
-, keepspaces=true%
-, showspaces=false%
-, showtabs=false%
-, showstringspaces=true%
-}%
-
-\lstdefinestyle{boxed}{
-  style=colouredRust%
-, numbers=left%
-, firstnumber=auto%
-, numberblanklines=true%
-, frame=trbL%
-% , numberstyle=\tiny%
-, frame=leftline%
-, numbersep=7pt%
-, framesep=5pt%
-, framerule=10pt%
-, xleftmargin=15pt%
-, backgroundcolor=\color[gray]{0.97}%
-, rulecolor=\color[gray]{0.90}%
-}
diff --git a/listings-scheme.sty b/listings-scheme.sty
deleted file mode 100644
index a437b97..0000000
--- a/listings-scheme.sty
+++ /dev/null
@@ -1,26 +0,0 @@
-\lstdefinelanguage{Scheme}{
-  morekeywords=[1]{define, define-syntax, define-macro, lambda, define-stream, stream-lambda},
-  morekeywords=[2]{begin, call-with-current-continuation, call/cc,
-    call-with-input-file, call-with-output-file, case, cond,
-    do, else, for-each, if,
-    let*, let, let-syntax, letrec, letrec-syntax,
-    let-values, let*-values,
-    and, or, not, delay, force,
-    quasiquote, quote, unquote, unquote-splicing,
-    map, fold, syntax, syntax-rules, eval, environment, query },
-  morekeywords=[3]{import, export},
-  alsodigit=!\$\%&*+-./:<=>?@^_~,
-  sensitive=true,
-  morecomment=[l]{;},
-  morecomment=[s]{\#|}{|\#},
-  morestring=[b]",
-  basicstyle=\small\ttfamily,
-  keywordstyle=\bf\ttfamily\color[rgb]{0,.3,.7},
-  commentstyle=\color[rgb]{0.133,0.545,0.133},
-  stringstyle={\color[rgb]{0.75,0.49,0.07}},
-  upquote=true,
-  breaklines=true,
-  breakatwhitespace=true,
-  literate=*{`}{{`}}{1},
-  showstringspaces=false
-}
diff --git a/main.md b/main.md
deleted file mode 100644
index 9a9ccec..0000000
--- a/main.md
+++ /dev/null
@@ -1,169 +0,0 @@
-# 序論
-
-## structure of the thesis
-
-## contribution of the thesis
-
-### 音楽プログラミング言語研究の理論的なフレームワークの提供
-
-### ソフトウェア設計におけるメディア研究、インフラストラクチャ研究の視点の提供
-
-
-
-
-##  limitations, not mention
-
-### live coding
-
-### latency and strict realtimeness
-
-# Background A: Computer as a Libre machine
-
-## Key's computer as a meta-medium
-
-### "Programming your own computer"
-
-## Wiser's Ubiquitous computing 
-
-### invisible machines
-
-## Black box of technologies
-
-## Operating System and Time-sharing
-現代の、Dynabookよろしく可変的に作られたコンピューターはOSの上でユーザーアプリケーションが動作している。
-この時、ユーザープログラムは自分の保存したメモリアドレスが実際の物理アドレスとしてどこにいるのかを知ることはできない。
-また、ユーザープログラムはプリエンプティブマルチタスキングなOSの元では、プログラムがいつ実行されるのかを正確に知ることはできない。
-
-キットラーのプロテクト・モード批判
-
-### Multi-tasking and "general-purpose" computer
-
-# Background B:musical medium
-
-## メディアインフラストラクチャの意図的な設計の必要性
-
-### infrastructure studies
-
-### format studies
-sterne mp3
-format matters
-## today's situation of musical medium
-
-### reproduction-tech-based music culture
-
-## specifity of computer music
-
-## object-based format
-
-## anti-"musicking"
-
-コンピューターが偏在していることを前提とした上で、新しい音楽フォーマットのあるべき形を検討する
-
-# Background C: Programming language for Sound Music(PLfSaM)
-##  What is PLfMaS?
-
-### What is Programming Language?
-
-### Sampling Theorem
-
-### Stream processing and timed discrete event
-
-### Computer music system(MUSIC-N)
-
-## 6 Elements of Computer Music Language by Dannenberg
-
-- Syntax
-- Semantics
-- Runtime
-	- implicitly means "compiler"(trade-off according to IR)
-- Library
-- IDE
-- Community
-
-## How can we evaluate the programming language for sound as "good?"
-
-### terminology
-
-### ambigious use of "general", "efficient" and "expressive"
-
-- Lazzarini2013
-- Brandt2002(Chronic's Tradeoff)
-
-### from the terminology of general-purpose language(Coblenz)
-
-### model of human-in-the-loop system in music programming.
-
-### situating cultural background to the language spec
-
-- CSound's layering "Score" "Orchestra" "Instrument"
-- How can we generalize the language as possible?
-
-> The commercial musical software we know today (all made in the West) perform abstractions and generalisations from the perspective of certain popular styles of Western music. (Magunusson thesis 2009)
-
-# Designing mimium
-
-## 基本文法
-
-```Rust
-fn hoge{
-    fuga = 2;
-    return 0
-}
-```
-
-
-## Type Systems
-
-## scheduling with @
-
-## signal procesing with self
-
-## Example Codes
-
-# Implementing mimium
-
-## overall architecture
-
-![mimium実行環境アーキテクチャ。](img/mimium-arch-v4-affinity.pdf){#fig:arch}
-
-mimiumの実行環境の基本的アーキテクチャを[@fig:arch]に示す。
-
-## implementation of the compiler
-
-### parser
-
-### Internal representation 1(lambda-like IR)
-
-### internal representation 2(SSA-imperative IR)
-
-### State Variable Analysis
-
-## implementation of the runtime
-
-### scheduler
-
-### JIT engine
-
-### audio driver
-
-## implementation of frontend?
-
-
-# Reflections from the design and implementation
-
-## Limitations
-
-### Combination of Scheduling and Signal Processing
-
-### Parametric Replication of signal processor
-
-## implications
-
-### multi-stage computation
-
-
-# Appendix A - History of Sound Programming Language
-
-## Sampling Theorem
-
-引用テスト[@Magnusson2009]
\ No newline at end of file
diff --git a/main.tex b/main.tex
deleted file mode 100644
index f2d6c7b..0000000
--- a/main.tex
+++ /dev/null
@@ -1,290 +0,0 @@
-\hypertarget{ux5e8fux8ad6}{%
-\chapter{序論}\label{ux5e8fux8ad6}}
-
-\hypertarget{structure-of-the-thesis}{%
-\section{structure of the thesis}\label{structure-of-the-thesis}}
-
-\hypertarget{contribution-of-the-thesis}{%
-\section{contribution of the thesis}\label{contribution-of-the-thesis}}
-
-\hypertarget{ux97f3ux697dux30d7ux30edux30b0ux30e9ux30dfux30f3ux30b0ux8a00ux8a9eux7814ux7a76ux306eux7406ux8ad6ux7684ux306aux30d5ux30ecux30fcux30e0ux30efux30fcux30afux306eux63d0ux4f9b}{%
-\subsection{音楽プログラミング言語研究の理論的なフレームワークの提供}\label{ux97f3ux697dux30d7ux30edux30b0ux30e9ux30dfux30f3ux30b0ux8a00ux8a9eux7814ux7a76ux306eux7406ux8ad6ux7684ux306aux30d5ux30ecux30fcux30e0ux30efux30fcux30afux306eux63d0ux4f9b}}
-
-\hypertarget{ux30bdux30d5ux30c8ux30a6ux30a7ux30a2ux8a2dux8a08ux306bux304aux3051ux308bux30e1ux30c7ux30a3ux30a2ux7814ux7a76ux30a4ux30f3ux30d5ux30e9ux30b9ux30c8ux30e9ux30afux30c1ux30e3ux7814ux7a76ux306eux8996ux70b9ux306eux63d0ux4f9b}{%
-\subsection{ソフトウェア設計におけるメディア研究、インフラストラクチャ研究の視点の提供}\label{ux30bdux30d5ux30c8ux30a6ux30a7ux30a2ux8a2dux8a08ux306bux304aux3051ux308bux30e1ux30c7ux30a3ux30a2ux7814ux7a76ux30a4ux30f3ux30d5ux30e9ux30b9ux30c8ux30e9ux30afux30c1ux30e3ux7814ux7a76ux306eux8996ux70b9ux306eux63d0ux4f9b}}
-
-\hypertarget{limitations-not-mention}{%
-\section{limitations, not mention}\label{limitations-not-mention}}
-
-\hypertarget{live-coding}{%
-\subsection{live coding}\label{live-coding}}
-
-\hypertarget{latency-and-strict-realtimeness}{%
-\subsection{latency and strict
-realtimeness}\label{latency-and-strict-realtimeness}}
-
-\hypertarget{background-a-computer-as-a-libre-machine}{%
-\chapter{Background A: Computer as a Libre
-machine}\label{background-a-computer-as-a-libre-machine}}
-
-\hypertarget{keys-computer-as-a-meta-medium}{%
-\section{Key's computer as a
-meta-medium}\label{keys-computer-as-a-meta-medium}}
-
-\hypertarget{programming-your-own-computer}{%
-\subsection{``Programming your own
-computer''}\label{programming-your-own-computer}}
-
-\hypertarget{wisers-ubiquitous-computing}{%
-\section{Wiser's Ubiquitous
-computing}\label{wisers-ubiquitous-computing}}
-
-\hypertarget{invisible-machines}{%
-\subsection{invisible machines}\label{invisible-machines}}
-
-\hypertarget{black-box-of-technologies}{%
-\section{Black box of technologies}\label{black-box-of-technologies}}
-
-\hypertarget{operating-system-and-time-sharing}{%
-\section{Operating System and
-Time-sharing}\label{operating-system-and-time-sharing}}
-
-現代の、Dynabookよろしく可変的に作られたコンピューターはOSの上でユーザーアプリケーションが動作している。
-この時、ユーザープログラムは自分の保存したメモリアドレスが実際の物理アドレスとしてどこにいるのかを知ることはできない。
-また、ユーザープログラムはプリエンプティブマルチタスキングなOSの元では、プログラムがいつ実行されるのかを正確に知ることはできない。
-
-キットラーのプロテクト・モード批判
-
-\hypertarget{multi-tasking-and-general-purpose-computer}{%
-\subsection{Multi-tasking and ``general-purpose''
-computer}\label{multi-tasking-and-general-purpose-computer}}
-
-\hypertarget{background-bmusical-medium}{%
-\chapter{Background B:musical medium}\label{background-bmusical-medium}}
-
-\hypertarget{ux30e1ux30c7ux30a3ux30a2ux30a4ux30f3ux30d5ux30e9ux30b9ux30c8ux30e9ux30afux30c1ux30e3ux306eux610fux56f3ux7684ux306aux8a2dux8a08ux306eux5fc5ux8981ux6027}{%
-\section{メディアインフラストラクチャの意図的な設計の必要性}\label{ux30e1ux30c7ux30a3ux30a2ux30a4ux30f3ux30d5ux30e9ux30b9ux30c8ux30e9ux30afux30c1ux30e3ux306eux610fux56f3ux7684ux306aux8a2dux8a08ux306eux5fc5ux8981ux6027}}
-
-\hypertarget{infrastructure-studies}{%
-\subsection{infrastructure studies}\label{infrastructure-studies}}
-
-\hypertarget{format-studies}{%
-\subsection{format studies}\label{format-studies}}
-
-sterne mp3 format matters \#\# today's situation of musical medium
-
-\hypertarget{reproduction-tech-based-music-culture}{%
-\subsection{reproduction-tech-based music
-culture}\label{reproduction-tech-based-music-culture}}
-
-\hypertarget{specifity-of-computer-music}{%
-\section{specifity of computer
-music}\label{specifity-of-computer-music}}
-
-\hypertarget{object-based-format}{%
-\section{object-based format}\label{object-based-format}}
-
-\hypertarget{anti-musicking}{%
-\section{anti-``musicking''}\label{anti-musicking}}
-
-コンピューターが偏在していることを前提とした上で、新しい音楽フォーマットのあるべき形を検討する
-
-\hypertarget{background-c-programming-language-for-sound-musicplfsam}{%
-\chapter{Background C: Programming language for Sound
-Music(PLfSaM)}\label{background-c-programming-language-for-sound-musicplfsam}}
-
-\hypertarget{what-is-plfmas}{%
-\section{What is PLfMaS?}\label{what-is-plfmas}}
-
-\hypertarget{what-is-programming-language}{%
-\subsection{What is Programming
-Language?}\label{what-is-programming-language}}
-
-\hypertarget{sampling-theorem}{%
-\subsection{Sampling Theorem}\label{sampling-theorem}}
-
-\hypertarget{stream-processing-and-timed-discrete-event}{%
-\subsection{Stream processing and timed discrete
-event}\label{stream-processing-and-timed-discrete-event}}
-
-\hypertarget{computer-music-systemmusic-n}{%
-\subsection{Computer music
-system(MUSIC-N)}\label{computer-music-systemmusic-n}}
-
-\hypertarget{elements-of-computer-music-language-by-dannenberg}{%
-\section{6 Elements of Computer Music Language by
-Dannenberg}\label{elements-of-computer-music-language-by-dannenberg}}
-
-\begin{itemize}
-\tightlist
-\item
-  Syntax
-\item
-  Semantics
-\item
-  Runtime
-
-  \begin{itemize}
-  \tightlist
-  \item
-    implicitly means ``compiler''(trade-off according to IR)
-  \end{itemize}
-\item
-  Library
-\item
-  IDE
-\item
-  Community
-\end{itemize}
-
-\hypertarget{how-can-we-evaluate-the-programming-language-for-sound-as-good}{%
-\section{How can we evaluate the programming language for sound as
-``good?''}\label{how-can-we-evaluate-the-programming-language-for-sound-as-good}}
-
-\hypertarget{terminology}{%
-\subsection{terminology}\label{terminology}}
-
-\hypertarget{ambigious-use-of-general-efficient-and-expressive}{%
-\subsection{ambigious use of ``general'', ``efficient'' and
-``expressive''}\label{ambigious-use-of-general-efficient-and-expressive}}
-
-\begin{itemize}
-\tightlist
-\item
-  Lazzarini2013
-\item
-  Brandt2002(Chronic's Tradeoff)
-\end{itemize}
-
-\hypertarget{from-the-terminology-of-general-purpose-languagecoblenz}{%
-\subsection{from the terminology of general-purpose
-language(Coblenz)}\label{from-the-terminology-of-general-purpose-languagecoblenz}}
-
-\hypertarget{model-of-human-in-the-loop-system-in-music-programming.}{%
-\subsection{model of human-in-the-loop system in music
-programming.}\label{model-of-human-in-the-loop-system-in-music-programming.}}
-
-\hypertarget{situating-cultural-background-to-the-language-spec}{%
-\subsection{situating cultural background to the language
-spec}\label{situating-cultural-background-to-the-language-spec}}
-
-\begin{itemize}
-\tightlist
-\item
-  CSound's layering ``Score'' ``Orchestra'' ``Instrument''
-\item
-  How can we generalize the language as possible?
-\end{itemize}
-
-\begin{quote}
-The commercial musical software we know today (all made in the West)
-perform abstractions and generalisations from the perspective of certain
-popular styles of Western music. (Magunusson thesis 2009)
-\end{quote}
-
-\hypertarget{designing-mimium}{%
-\chapter{Designing mimium}\label{designing-mimium}}
-
-\hypertarget{ux57faux672cux6587ux6cd5}{%
-\section{基本文法}\label{ux57faux672cux6587ux6cd5}}
-
-\begin{Shaded}
-\begin{Highlighting}[]
-\KeywordTok{fn}\NormalTok{ hoge\{}
-\NormalTok{    fuga = 2;}
-\NormalTok{    return 0}
-\NormalTok{\}}
-\end{Highlighting}
-\end{Shaded}
-
-\hypertarget{type-systems}{%
-\section{Type Systems}\label{type-systems}}
-
-\hypertarget{scheduling-with}{%
-\section{scheduling with @}\label{scheduling-with}}
-
-\hypertarget{signal-procesing-with-self}{%
-\section{signal procesing with self}\label{signal-procesing-with-self}}
-
-\hypertarget{example-codes}{%
-\section{Example Codes}\label{example-codes}}
-
-\hypertarget{implementing-mimium}{%
-\chapter{Implementing mimium}\label{implementing-mimium}}
-
-\hypertarget{overall-architecture}{%
-\section{overall architecture}\label{overall-architecture}}
-
-\begin{figure}
-\hypertarget{fig:arch}{%
-\centering
-\includegraphics{img/mimium-arch-v4-affinity.pdf}
-\caption{mimium実行環境アーキテクチャ。}\label{fig:arch}
-}
-\end{figure}
-
-mimiumの実行環境の基本的アーキテクチャを図~\ref{fig:arch}に示す。
-
-\hypertarget{implementation-of-the-compiler}{%
-\section{implementation of the
-compiler}\label{implementation-of-the-compiler}}
-
-\hypertarget{parser}{%
-\subsection{parser}\label{parser}}
-
-\hypertarget{internal-representation-1lambda-like-ir}{%
-\subsection{Internal representation 1(lambda-like
-IR)}\label{internal-representation-1lambda-like-ir}}
-
-\hypertarget{internal-representation-2ssa-imperative-ir}{%
-\subsection{internal representation 2(SSA-imperative
-IR)}\label{internal-representation-2ssa-imperative-ir}}
-
-\hypertarget{state-variable-analysis}{%
-\subsection{State Variable Analysis}\label{state-variable-analysis}}
-
-\hypertarget{implementation-of-the-runtime}{%
-\section{implementation of the
-runtime}\label{implementation-of-the-runtime}}
-
-\hypertarget{scheduler}{%
-\subsection{scheduler}\label{scheduler}}
-
-\hypertarget{jit-engine}{%
-\subsection{JIT engine}\label{jit-engine}}
-
-\hypertarget{audio-driver}{%
-\subsection{audio driver}\label{audio-driver}}
-
-\hypertarget{implementation-of-frontend}{%
-\section{implementation of frontend?}\label{implementation-of-frontend}}
-
-\hypertarget{reflections-from-the-design-and-implementation}{%
-\chapter{Reflections from the design and
-implementation}\label{reflections-from-the-design-and-implementation}}
-
-\hypertarget{limitations}{%
-\section{Limitations}\label{limitations}}
-
-\hypertarget{combination-of-scheduling-and-signal-processing}{%
-\subsection{Combination of Scheduling and Signal
-Processing}\label{combination-of-scheduling-and-signal-processing}}
-
-\hypertarget{parametric-replication-of-signal-processor}{%
-\subsection{Parametric Replication of signal
-processor}\label{parametric-replication-of-signal-processor}}
-
-\hypertarget{implications}{%
-\section{implications}\label{implications}}
-
-\hypertarget{multi-stage-computation}{%
-\subsection{multi-stage computation}\label{multi-stage-computation}}
-
-\hypertarget{appendix-a---history-of-sound-programming-language}{%
-\chapter{Appendix A - History of Sound Programming
-Language}\label{appendix-a---history-of-sound-programming-language}}
-
-\hypertarget{sampling-theorem-1}{%
-\section{Sampling Theorem}\label{sampling-theorem-1}}
-
-引用テスト\citep{Magnusson2009}
diff --git a/pandoc-crossref-config.yml b/pandoc-crossref-config.yml
index dd5c7b9..fd0a376 100644
--- a/pandoc-crossref-config.yml
+++ b/pandoc-crossref-config.yml
@@ -6,4 +6,5 @@ figPrefix: "図"
 eqnPrefix: "式"
 tblPrefix: "表"
 lstPrefix: "コード"
-secPrefix: "章"
\ No newline at end of file
+secPrefix: "章"
+codeBlockCaptions: true
\ No newline at end of file
diff --git a/readme.md b/readme.md
new file mode 100644
index 0000000..e388ec9
--- /dev/null
+++ b/readme.md
@@ -0,0 +1,6 @@
+コードの置き換え
+
+```regex
+\\begin\{lstlisting\}\[(.*)caption=(.*),label=(.*)\]\n([\s\S]*?)\\end\{lstlisting\}
+```rust\n$4\n\n: $2 {#$3}
+```
\ No newline at end of file
diff --git a/template.pdf b/template.pdf
deleted file mode 100644
index 169da6d..0000000
Binary files a/template.pdf and /dev/null differ
diff --git a/template.tex b/template.tex
deleted file mode 100644
index 5fd7388..0000000
--- a/template.tex
+++ /dev/null
@@ -1,260 +0,0 @@
-\documentclass[luatex,unicode,titlepage,pdfusetitle,a4paper,openany]{ltjsbook}
-\usepackage{luatexja}
-\usepackage{luatexja-preset}
-\usepackage{luatexja-otf}
-
-\usepackage[includeheadfoot,top=20truemm,bottom=20truemm, right=25truemm,left=25truemm]{geometry} % 余白を調製
-
-\usepackage{amsmath,amssymb}
-\usepackage{bm}
-\usepackage{ascmac}
-\usepackage{epigraph}
-
-\setlength{\epigraphwidth}{0.6\textwidth}
-
-\newcommand{\msharp}{$^\sharp$}
-
-\usepackage{color}
-\usepackage{graphicx}
-% \usepackage[draft]{graphicx} %コンパイルが遅い時はこれで枠だけにすると速くできる
-
-\usepackage{longtable} % 表組みに必要
-\usepackage{booktabs,array} % 表組みに必要
-\usepackage{subfig} % 図の横並びに必要
-\usepackage{ulem} % 取り消し線に必要
-\usepackage{url}
-
-\usepackage[font={sf,small}]{caption}
-\usepackage[language=japanese,backend=biber,backref=true,nameorder=true,date=year,style=authoryear]{biblatex-japanese}
-\DefineBibliographyStrings{english}{%
-  backrefpage = {p},% originally "cited on page"
-  backrefpages = {p},% originally "cited on pages"
-}
-% 引用にnodateを許す
-\renewbibmacro*{date}{%
-  \iffieldundef{year}
-    {\bibstring{nodate}}
-    {\printdate}}
-
-\usepackage{xcolor}
-\usepackage{fvextra}
-\usepackage{framed}
-
-% 画像を記述された場所に挿入(デフォルトではページ上部に挿入されてしまう)
-\usepackage{float}
-\let\origfigure\figure
-\let\endorigfigure\endfigure
-\renewenvironment{figure}[1][2] {
-    \expandafter\origfigure\expandafter[H]
-} {
-    \endorigfigure
-}
-
-% 画像の縦横比を保ったままサイズ変更を可能にする
-\makeatletter
-\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
-\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
-\makeatother
-\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
-
-\def\tightlist{\itemsep1pt\parskip0pt\parsep0pt} % これがないと\tightlistが動かない
-
-
-% Pandoc用ハイライトの設定、Rustのトークナイズあんまりうまく行ってない？
-\newenvironment{Shaded}{\begin{shaded}}{\end{shaded}}
-\definecolor{shadecolor}{RGB}{240,240,240}
-\DefineVerbatimEnvironment{Highlighting}{Verbatim}
-  {breaklines,breakanywhere,commandchars=\\\{\}}
-\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
-\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
-\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
-\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
-\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
-\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
-\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
-\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
-
-\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
-\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
-\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
-\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
-\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
-\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
-\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
-\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
-\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
-\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
-\newcommand{\RegionMarkerTok}[1]{{#1}}
-\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
-\newcommand{\NormalTok}[1]{{#1}}
-\newcommand{\PreprocessorTok}[1]{\ImportTok{{#1}}}
-
-
-% 手動でlisting使うとき、行番号が付く
-\usepackage{listings,listings-rust,listings-scheme}
-
-\definecolor{codegreen}{rgb}{0,0.6,0}
-\definecolor{codegray}{rgb}{0.1,0.1,0.8}
-\definecolor{codepurple}{rgb}{0.58,0,0.82}
-\definecolor{backcolour}{rgb}{0.98,0.98,0.98}
-% 行番号がコピーされないためのマクロ
-\usepackage{accsupp}
-\newcommand{\noncopynumber}[1]{%
-    \BeginAccSupp{method=escape,ActualText={}}#1\EndAccSupp{}
-}
-\lstdefinestyle{mystyle}{
-    backgroundcolor=\color{backcolour},   
-    commentstyle=\color{codegreen},
-    keywordstyle=\color{magenta},
-    keywordstyle=[2]\color[rgb]{0.75, 0, 0},% traits
-    keywordstyle=[3]\color[rgb]{0.5, 0.5, 0},% primitive types
-    keywordstyle=[4]\color[rgb]{0, 0.5, 0.75},% type and value constructors
-    keywordstyle=[5]\color[rgb]{0, 0, 0.75},% macros
-    stringstyle=\color{codepurple},
-    numberstyle=\tiny\color{codegray}\noncopynumber,
-    basicstyle=\ttfamily\footnotesize,
-    breakatwhitespace=false,         
-    breaklines=true,                 
-    captionpos=b,
-    columns=fullflexible,  
-    keepspaces=true,                 
-    numbers=left,        
-    xleftmargin=\dimexpr\fboxsep+\fboxrule\relax,
-    xrightmargin=\dimexpr\fboxsep+\fboxrule\relax,
-    framexleftmargin=0.7em,       
-    numbersep=4pt,              
-    showspaces=false,                
-    showstringspaces=false,
-    showtabs=false,                  
-    tabsize=2
-}
-
-\lstset{style=mystyle}
-\usepackage{hyperref}
-\hypersetup{% hyperrefのオプションリスト
-    colorlinks=true,% カラーリンクを使用
-    linkcolor=black,% 内部参照リンクの色
-    citecolor=black,% 文献参照リンクの色
-    filecolor=black,% ローカルファイル参照リンクの色
-    urlcolor=blue % 外部参照URLの色
-}
-
-\renewcommand{\lstlistingname}{コード}
-\renewcommand{\lstlistlistingname}{コード例目次}
-
-\providecommand{\citep}{\parencite}
-\renewcommand{\emph}[1]{\textgt{\textit{#1}}}
-
-\providecommand{\mimium}{\textit{mimium}}
-
-\addbibresource{./ref.bib}
-
-% カスタムタイトルを作る
-\makeatletter
-\renewcommand*{\maketitle}{%
-\begin{titlepage}
-    \let\footnotesize\small
-    \let\footnoterule\relax
-    \let\footnote\thanks
-    \null\vfil
-    \vskip 60\jsc@mpt
-    \begin{center}%
-      {\LARGE \@title \par}%
-      \vskip 24em%
-      {\large
-        \lineskip .75em
-        \begin{tabular}[t]{c}%
-          \@author
-        \end{tabular}\par}%
-      \vskip 1.5em
-      {\large \@date \par}%
-    \end{center}%
-    \par
-    \@thanks\vfil\null
-\end{titlepage}
-}
-\makeatother
-
-\title{音楽土木工学を設計する―\\音楽のためのプログラミング言語\mimium{}の開発を通じて\\
-\vskip 1.5em
-\Large{Designing Civil Engineering of Music\\ through the development of \mimium{}, a programming language for music}
-}
-\author{松浦 知也 \\
-        \normalsize{MATSUURA Tomoya}}
-\date{2022年3月}
-
-\begin{document}
-
-\frontmatter
-
-\maketitle
-
-\cleardoublepage
-\phantomsection
-\addcontentsline{toc}{chapter}{概要}
-\begin{abstract}
-\chapter*{概要}
-    \input{abstract}
-\chapter*{Abstract}
-    \input{abstract_en}
-\end{abstract}
-
-\phantomsection
-\addcontentsline{toc}{chapter}{目次}
-\setcounter{tocdepth}{2}
-\tableofcontents
-
-\phantomsection
-\addcontentsline{toc}{chapter}{用語集}
-\chapter*{用語集}
-\input{glossary}
-
-\phantomsection
-\addcontentsline{toc}{chapter}{図目次}
-\listoffigures
-
-\phantomsection
-\addcontentsline{toc}{chapter}{コード例目次}
-\lstlistoflistings
-
-\mainmatter
-
-\chapter{序論}\label{sec:chapter1}
-\input{chapter1}
-
-\chapter{歴史を記述しなおすデザインリサーチ}\label{sec:chapter2}
-\input{chapter2}
-
-\chapter{メタメディアとしてのコンピューター}\label{sec:chapter3}
-\input{chapter3}
-
-\chapter{PLfM史の再考}\label{sec:chapter4}
-\input{chapter4}
-
-\chapter{PLfMに関する諸用語と概念の整理}\label{sec:chapter5}
-\input{chapter5}
-
-\chapter{最小限のPLfM：mimiumの設計と実装}\label{sec:chapter6}
-\input{chapter6}
-
-\chapter{結論：音楽土木工学とは何なのか、どこへ向かうのか}\label{sec:chapter7}
-\input{chapter7}
-
-
-\appendix
-\chapter{mimiumのシンタックス定義}\label{sec:appendA}
-\input{appendixA}
-
-\backmatter
-
-\phantomsection
-\addcontentsline{toc}{chapter}{参考文献}
-\printbibliography[title = 参考文献]
-
-\phantomsection
-\addcontentsline{toc}{chapter}{謝辞}
-\chapter*{謝辞}
-\input{acknowledgement}
-
-\end{document}
-
